package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/neogan74/konsul/internal/graphql/generated"
	"github.com/neogan74/konsul/internal/graphql/model"
	"github.com/neogan74/konsul/internal/graphql/scalar"
	"github.com/neogan74/konsul/internal/logger"
	"github.com/neogan74/konsul/internal/metrics"
	"github.com/neogan74/konsul/internal/store"
)

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.SystemHealth, error) {
	// No auth required for health endpoint (public)

	// Get service stats
	allEntries := r.serviceStore.ListAll()
	activeServices := r.serviceStore.List()
	expiredCount := len(allEntries) - len(activeServices)

	// Get KV stats
	allKeys := r.kvStore.List()

	// Calculate uptime
	uptime := fmt.Sprintf("%v", time.Since(r.startTime).Round(time.Second))

	timestamp := scalar.FromTime(time.Now())

	return &model.SystemHealth{
		Status:    "healthy",
		Version:   r.version,
		Uptime:    uptime,
		Timestamp: timestamp,
		Services: &model.ServiceStats{
			Total:   len(allEntries),
			Active:  len(activeServices),
			Expired: expiredCount,
		},
		KvStore: &model.KVStats{
			TotalKeys: len(allKeys),
		},
	}, nil
}

// Kv is the resolver for the kv field.
func (r *queryResolver) Kv(ctx context.Context, key string) (*model.KVPair, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL check when ACL middleware is implemented

	// Fetch from store
	value, exists := r.kvStore.Get(key)
	if !exists {
		return nil, nil // Return nil for not found (nullable field)
	}

	r.logger.Debug("GraphQL: fetched KV pair",
		logger.String("key", key))

	return model.MapKVPairFromStore(key, value), nil
}

// KvList is the resolver for the kvList field.
func (r *queryResolver) KvList(ctx context.Context, prefix *string, limit *int, offset *int) (*model.KVListResponse, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Get all keys
	allKeys := r.kvStore.List()

	// Filter by prefix if provided
	var filteredKeys []string
	if prefix != nil && *prefix != "" {
		for _, key := range allKeys {
			if strings.HasPrefix(key, *prefix) {
				filteredKeys = append(filteredKeys, key)
			}
		}
	} else {
		filteredKeys = allKeys
	}

	total := len(filteredKeys)

	// Apply pagination
	start := 0
	if offset != nil {
		start = *offset
		if start > total {
			start = total
		}
	}

	end := total
	if limit != nil {
		end = start + *limit
		if end > total {
			end = total
		}
	}

	paginatedKeys := filteredKeys[start:end]

	// Build response
	items := make([]*model.KVPair, 0, len(paginatedKeys))
	for _, key := range paginatedKeys {
		if value, exists := r.kvStore.Get(key); exists {
			// TODO: Check ACL for each key if enabled
			items = append(items, model.MapKVPairFromStore(key, value))
		}
	}

	r.logger.Debug("GraphQL: listed KV pairs",
		logger.String("prefix", stringOrEmpty(prefix)),
		logger.Int("total", total),
		logger.Int("returned", len(items)))

	return &model.KVListResponse{
		Items:   items,
		Total:   total,
		HasMore: end < total,
	}, nil
}

// Service is the resolver for the service field.
func (r *queryResolver) Service(ctx context.Context, name string) (*model.Service, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL
	// TODO: Add ACL check when ACL middleware is implemented

	// Get all entries to find the one with expiration info
	entries := r.serviceStore.ListAll()
	var entry *store.ServiceEntry
	for _, e := range entries {
		if e.Service.Name == name {
			entry = &e
			break
		}
	}

	if entry == nil {
		return nil, nil // Return nil for not found
	}

	r.logger.Debug("GraphQL: fetched service",
		logger.String("name", name))

	return model.MapServiceFromStore(entry.Service, *entry), nil
}

// Services is the resolver for the services field.
func (r *queryResolver) Services(ctx context.Context, limit *int, offset *int) ([]*model.Service, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Get all services
	entries := r.serviceStore.ListAll()

	// Apply pagination
	start := 0
	if offset != nil {
		start = *offset
		if start > len(entries) {
			start = len(entries)
		}
	}

	end := len(entries)
	if limit != nil {
		end = start + *limit
		if end > len(entries) {
			end = len(entries)
		}
	}

	paginatedEntries := entries[start:end]

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(paginatedEntries))
	for _, entry := range paginatedEntries {
		// TODO: Check ACL for each service
		services = append(services, model.MapServiceFromStore(entry.Service, entry))
	}

	r.logger.Debug("GraphQL: listed services",
		logger.Int("total", len(entries)),
		logger.Int("returned", len(services)))

	return services, nil
}

// ServicesCount is the resolver for the servicesCount field.
func (r *queryResolver) ServicesCount(ctx context.Context) (int, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	services := r.serviceStore.List()
	return len(services), nil
}

// ServicesByTags is the resolver for the servicesByTags field.
func (r *queryResolver) ServicesByTags(ctx context.Context, tags []string) ([]*model.Service, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	r.logger.Info("GraphQL: querying services by tags",
		logger.Int("tag_count", len(tags)))

	// Query the store
	storeServices := r.serviceStore.QueryByTags(tags)

	// Create a map for quick lookup
	serviceMap := make(map[string]bool)
	for _, svc := range storeServices {
		serviceMap[svc.Name] = true
	}

	// Get all entries to include expiration info
	allEntries := r.serviceStore.ListAll()

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(storeServices))
	for _, entry := range allEntries {
		if serviceMap[entry.Service.Name] {
			services = append(services, model.MapServiceFromStore(entry.Service, entry))
		}
	}

	r.logger.Debug("GraphQL: services by tags query completed",
		logger.Int("result_count", len(services)))

	return services, nil
}

// ServicesByMetadata is the resolver for the servicesByMetadata field.
func (r *queryResolver) ServicesByMetadata(ctx context.Context, filters []*model.MetadataFilter) ([]*model.Service, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Convert GraphQL filters to map
	metaMap := make(map[string]string, len(filters))
	for _, filter := range filters {
		metaMap[filter.Key] = filter.Value
	}

	r.logger.Info("GraphQL: querying services by metadata",
		logger.Int("filter_count", len(filters)))

	// Query the store
	storeServices := r.serviceStore.QueryByMetadata(metaMap)

	// Create a map for quick lookup
	serviceMap := make(map[string]bool)
	for _, svc := range storeServices {
		serviceMap[svc.Name] = true
	}

	// Get all entries to include expiration info
	allEntries := r.serviceStore.ListAll()

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(storeServices))
	for _, entry := range allEntries {
		if serviceMap[entry.Service.Name] {
			services = append(services, model.MapServiceFromStore(entry.Service, entry))
		}
	}

	r.logger.Debug("GraphQL: services by metadata query completed",
		logger.Int("result_count", len(services)))

	return services, nil
}

// ServicesByQuery is the resolver for the servicesByQuery field.
func (r *queryResolver) ServicesByQuery(ctx context.Context, tags []string, metadata []*model.MetadataFilter) ([]*model.Service, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Handle nil tags parameter
	if tags == nil {
		tags = []string{}
	}

	// Convert GraphQL filters to map
	metaMap := make(map[string]string)
	if metadata != nil {
		for _, filter := range metadata {
			metaMap[filter.Key] = filter.Value
		}
	}

	r.logger.Info("GraphQL: querying services by tags and metadata",
		logger.Int("tag_count", len(tags)),
		logger.Int("filter_count", len(metaMap)))

	// Query the store
	storeServices := r.serviceStore.QueryByTagsAndMetadata(tags, metaMap)

	// Create a map for quick lookup
	serviceMap := make(map[string]bool)
	for _, svc := range storeServices {
		serviceMap[svc.Name] = true
	}

	// Get all entries to include expiration info
	allEntries := r.serviceStore.ListAll()

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(storeServices))
	for _, entry := range allEntries {
		if serviceMap[entry.Service.Name] {
			services = append(services, model.MapServiceFromStore(entry.Service, entry))
		}
	}

	r.logger.Debug("GraphQL: combined query completed",
		logger.Int("result_count", len(services)))

	return services, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// Helper function to convert optional string pointer to string
func stringOrEmpty(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}
