package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	hashiraft "github.com/hashicorp/raft"
	"github.com/neogan74/konsul/internal/graphql/generated"
	"github.com/neogan74/konsul/internal/graphql/model"
	"github.com/neogan74/konsul/internal/graphql/scalar"
	"github.com/neogan74/konsul/internal/logger"
	"github.com/neogan74/konsul/internal/metrics"
	konsulraft "github.com/neogan74/konsul/internal/raft"
	"github.com/neogan74/konsul/internal/store"
)

// KvSet is the resolver for the kvSet field.
func (r *mutationResolver) KvSet(ctx context.Context, key string, value string) (*model.KVPair, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL write permission check when ACL middleware is implemented

	// Set the key-value pair
	if r.raftNode != nil {
		cmd, err := konsulraft.NewCommand(konsulraft.CmdKVSet, konsulraft.KVSetPayload{
			Key:   key,
			Value: value,
		})
		if err != nil {
			return nil, err
		}
		if _, err := r.raftNode.ApplyEntry(cmd, 5*time.Second); err != nil {
			if errors.Is(err, hashiraft.ErrNotLeader) {
				return nil, fmt.Errorf("not leader: %w", err)
			}
			return nil, err
		}
	} else {
		r.kvStore.Set(key, value)
	}

	r.logger.Info("GraphQL: KV set",
		logger.String("key", key),
		logger.Int("value_length", len(value)))

	// Return the updated KV pair
	return model.MapKVPairFromStore(key, value), nil
}

// KvDelete is the resolver for the kvDelete field.
func (r *mutationResolver) KvDelete(ctx context.Context, key string) (bool, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL delete permission check when ACL middleware is implemented

	// Check if key exists before deleting
	_, exists := r.kvStore.Get(key)
	if !exists {
		return false, nil
	}

	// Delete the key
	if r.raftNode != nil {
		cmd, err := konsulraft.NewCommand(konsulraft.CmdKVDelete, konsulraft.KVDeletePayload{
			Key: key,
		})
		if err != nil {
			return false, err
		}
		if _, err := r.raftNode.ApplyEntry(cmd, 5*time.Second); err != nil {
			if errors.Is(err, hashiraft.ErrNotLeader) {
				return false, fmt.Errorf("not leader: %w", err)
			}
			return false, err
		}
	} else {
		r.kvStore.Delete(key)
	}

	r.logger.Info("GraphQL: KV deleted",
		logger.String("key", key))

	return true, nil
}

// KvCas is the resolver for the kvCAS field.
func (r *mutationResolver) KvCas(ctx context.Context, key string, value string, index int) (*model.KVPair, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL write permission check when ACL middleware is implemented

	// Perform Compare-And-Swap operation
	var newIndex uint64
	var err error
	if r.raftNode != nil {
		cmd, marshalErr := konsulraft.NewCommand(konsulraft.CmdKVSetCAS, konsulraft.KVSetCASPayload{
			Key:           key,
			Value:         value,
			ExpectedIndex: uint64(index),
		})
		if marshalErr != nil {
			return nil, marshalErr
		}
		resp, applyErr := r.raftNode.ApplyEntry(cmd, 5*time.Second)
		if applyErr != nil {
			err = applyErr
		} else if cast, ok := resp.(uint64); ok {
			newIndex = cast
		}
	} else {
		newIndex, err = r.kvStore.SetCAS(key, value, uint64(index))
	}
	if err != nil {
		// CAS failed - index mismatch
		r.logger.Warn("GraphQL: KV CAS failed",
			logger.String("key", key),
			logger.Int("expected_index", index),
			logger.Error(err))
		if store.IsCASConflict(err) || store.IsNotFound(err) {
			return nil, nil
		}
		if errors.Is(err, hashiraft.ErrNotLeader) {
			return nil, fmt.Errorf("not leader: %w", err)
		}
		return nil, err
	}

	r.logger.Info("GraphQL: KV CAS succeeded",
		logger.String("key", key),
		logger.Int("new_index", int(newIndex)))

	// Return the updated KV pair
	return model.MapKVPairFromStore(key, value), nil
}

// RegisterService is the resolver for the registerService field.
func (r *mutationResolver) RegisterService(ctx context.Context, input model.RegisterServiceInput) (*model.Service, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL register permission check when ACL middleware is implemented

	// Convert metadata from GraphQL input to map
	metadata := make(map[string]string)
	if input.Metadata != nil {
		for _, m := range input.Metadata {
			metadata[m.Key] = m.Value
		}
	}

	// Create service from input
	service := store.Service{
		Name:    input.Name,
		Address: input.Address,
		Port:    input.Port,
		Tags:    input.Tags,
		Meta:    metadata,
	}

	// Register the service
	if r.raftNode != nil {
		cmd, err := konsulraft.NewCommand(konsulraft.CmdServiceRegister, konsulraft.ServiceRegisterPayload{
			Service: service,
		})
		if err != nil {
			return nil, err
		}
		if _, err := r.raftNode.ApplyEntry(cmd, 5*time.Second); err != nil {
			if errors.Is(err, hashiraft.ErrNotLeader) {
				return nil, fmt.Errorf("not leader: %w", err)
			}
			return nil, fmt.Errorf("failed to register service: %w", err)
		}
	} else if err := r.serviceStore.Register(service); err != nil {
		r.logger.Error("GraphQL: Failed to register service",
			logger.String("name", input.Name),
			logger.Error(err))
		return nil, fmt.Errorf("failed to register service: %w", err)
	}

	r.logger.Info("GraphQL: Service registered",
		logger.String("name", input.Name),
		logger.String("address", input.Address),
		logger.Int("port", input.Port))

	// Get the registered service entry to return with expiration info
	entries := r.serviceStore.ListAll()
	var entry *store.ServiceEntry
	for _, e := range entries {
		if e.Service.Name == input.Name {
			entry = &e
			break
		}
	}

	if entry == nil {
		return nil, fmt.Errorf("service registered but not found")
	}

	return model.MapServiceFromStore(service, *entry), nil
}

// DeregisterService is the resolver for the deregisterService field.
func (r *mutationResolver) DeregisterService(ctx context.Context, name string) (bool, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL deregister permission check when ACL middleware is implemented

	// Check if service exists
	_, exists := r.serviceStore.Get(name)
	if !exists {
		return false, nil
	}

	// Deregister the service
	if r.raftNode != nil {
		cmd, err := konsulraft.NewCommand(konsulraft.CmdServiceDeregister, konsulraft.ServiceDeregisterPayload{
			Name: name,
		})
		if err != nil {
			return false, err
		}
		if _, err := r.raftNode.ApplyEntry(cmd, 5*time.Second); err != nil {
			if errors.Is(err, hashiraft.ErrNotLeader) {
				return false, fmt.Errorf("not leader: %w", err)
			}
			return false, err
		}
	} else {
		r.serviceStore.Deregister(name)
	}

	r.logger.Info("GraphQL: Service deregistered",
		logger.String("name", name))

	return true, nil
}

// UpdateHeartbeat is the resolver for the updateHeartbeat field.
func (r *mutationResolver) UpdateHeartbeat(ctx context.Context, name string) (*model.Service, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL heartbeat permission check when ACL middleware is implemented

	// Update heartbeat
	success := false
	if r.raftNode != nil {
		cmd, err := konsulraft.NewCommand(konsulraft.CmdServiceHeartbeat, konsulraft.ServiceHeartbeatPayload{
			Name: name,
		})
		if err != nil {
			return nil, err
		}
		resp, err := r.raftNode.ApplyEntry(cmd, 5*time.Second)
		if err != nil {
			if errors.Is(err, hashiraft.ErrNotLeader) {
				return nil, fmt.Errorf("not leader: %w", err)
			}
			return nil, err
		}
		if cast, ok := resp.(bool); ok {
			success = cast
		}
	} else {
		success = r.serviceStore.Heartbeat(name)
	}
	if !success {
		r.logger.Warn("GraphQL: Heartbeat failed - service not found",
			logger.String("name", name))
		return nil, fmt.Errorf("service not found: %s", name)
	}

	r.logger.Debug("GraphQL: Heartbeat updated",
		logger.String("name", name))

	// Get the updated service entry
	entries := r.serviceStore.ListAll()
	var entry *store.ServiceEntry
	for _, e := range entries {
		if e.Service.Name == name {
			entry = &e
			break
		}
	}

	if entry == nil {
		return nil, fmt.Errorf("service not found after heartbeat")
	}

	return model.MapServiceFromStore(entry.Service, *entry), nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.SystemHealth, error) {
	// No auth required for health endpoint (public)

	// Get service stats
	allEntries := r.serviceStore.ListAll()
	activeServices := r.serviceStore.List()
	expiredCount := len(allEntries) - len(activeServices)

	// Get KV stats
	allKeys := r.kvStore.List()

	// Calculate uptime
	uptime := fmt.Sprintf("%v", time.Since(r.startTime).Round(time.Second))

	timestamp := scalar.FromTime(time.Now())

	return &model.SystemHealth{
		Status:    "healthy",
		Version:   r.version,
		Uptime:    uptime,
		Timestamp: timestamp,
		Services: &model.ServiceStats{
			Total:   len(allEntries),
			Active:  len(activeServices),
			Expired: expiredCount,
		},
		KvStore: &model.KVStats{
			TotalKeys: len(allKeys),
		},
	}, nil
}

// Kv is the resolver for the kv field.
func (r *queryResolver) Kv(ctx context.Context, key string) (*model.KVPair, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL permissions if enabled
	// TODO: Add ACL check when ACL middleware is implemented

	// Fetch from store
	value, exists := r.kvStore.Get(key)
	if !exists {
		return nil, nil // Return nil for not found (nullable field)
	}

	r.logger.Debug("GraphQL: fetched KV pair",
		logger.String("key", key))

	return model.MapKVPairFromStore(key, value), nil
}

// KvList is the resolver for the kvList field.
func (r *queryResolver) KvList(ctx context.Context, prefix *string, limit *int, offset *int) (*model.KVListResponse, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Get all keys
	allKeys := r.kvStore.List()

	// Filter by prefix if provided
	var filteredKeys []string
	if prefix != nil && *prefix != "" {
		for _, key := range allKeys {
			if strings.HasPrefix(key, *prefix) {
				filteredKeys = append(filteredKeys, key)
			}
		}
	} else {
		filteredKeys = allKeys
	}

	total := len(filteredKeys)

	// Apply pagination
	start := 0
	if offset != nil {
		start = *offset
		if start > total {
			start = total
		}
	}

	end := total
	if limit != nil {
		end = start + *limit
		if end > total {
			end = total
		}
	}

	paginatedKeys := filteredKeys[start:end]

	// Build response
	items := make([]*model.KVPair, 0, len(paginatedKeys))
	for _, key := range paginatedKeys {
		if value, exists := r.kvStore.Get(key); exists {
			// TODO: Check ACL for each key if enabled
			items = append(items, model.MapKVPairFromStore(key, value))
		}
	}

	r.logger.Debug("GraphQL: listed KV pairs",
		logger.String("prefix", stringOrEmpty(prefix)),
		logger.Int("total", total),
		logger.Int("returned", len(items)))

	return &model.KVListResponse{
		Items:   items,
		Total:   total,
		HasMore: end < total,
	}, nil
}

// Service is the resolver for the service field.
func (r *queryResolver) Service(ctx context.Context, name string) (*model.Service, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Check ACL
	// TODO: Add ACL check when ACL middleware is implemented

	// Get all entries to find the one with expiration info
	entries := r.serviceStore.ListAll()
	var entry *store.ServiceEntry
	for _, e := range entries {
		if e.Service.Name == name {
			entry = &e
			break
		}
	}

	if entry == nil {
		return nil, nil // Return nil for not found
	}

	r.logger.Debug("GraphQL: fetched service",
		logger.String("name", name))

	return model.MapServiceFromStore(entry.Service, *entry), nil
}

// Services is the resolver for the services field.
func (r *queryResolver) Services(ctx context.Context, limit *int, offset *int) ([]*model.Service, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Get all services
	entries := r.serviceStore.ListAll()

	// Apply pagination
	start := 0
	if offset != nil {
		start = *offset
		if start > len(entries) {
			start = len(entries)
		}
	}

	end := len(entries)
	if limit != nil {
		end = start + *limit
		if end > len(entries) {
			end = len(entries)
		}
	}

	paginatedEntries := entries[start:end]

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(paginatedEntries))
	for _, entry := range paginatedEntries {
		// TODO: Check ACL for each service
		services = append(services, model.MapServiceFromStore(entry.Service, entry))
	}

	r.logger.Debug("GraphQL: listed services",
		logger.Int("total", len(entries)),
		logger.Int("returned", len(services)))

	return services, nil
}

// ServicesCount is the resolver for the servicesCount field.
func (r *queryResolver) ServicesCount(ctx context.Context) (int, error) {
	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	services := r.serviceStore.List()
	return len(services), nil
}

// ServicesByTags is the resolver for the servicesByTags field.
func (r *queryResolver) ServicesByTags(ctx context.Context, tags []string) ([]*model.Service, error) {
	startTime := time.Now()
	queryName := "servicesByTags"

	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	r.logger.Info("GraphQL: querying services by tags",
		logger.Int("tag_count", len(tags)))

	// Track query complexity (number of tags)
	metrics.GraphQLComplexity.WithLabelValues(queryName).Observe(float64(len(tags)))

	// Query the store
	storeServices := r.serviceStore.QueryByTags(tags)

	// Create a map for quick lookup
	serviceMap := make(map[string]bool)
	for _, svc := range storeServices {
		serviceMap[svc.Name] = true
	}

	// Get all entries to include expiration info
	allEntries := r.serviceStore.ListAll()

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(storeServices))
	for _, entry := range allEntries {
		if serviceMap[entry.Service.Name] {
			services = append(services, model.MapServiceFromStore(entry.Service, entry))
		}
	}

	// Record metrics
	duration := time.Since(startTime).Seconds()
	metrics.GraphQLResolverDuration.WithLabelValues(queryName).Observe(duration)
	metrics.GraphQLQueryDuration.WithLabelValues(queryName).Observe(duration)
	metrics.GraphQLQueryResultsCount.WithLabelValues(queryName).Observe(float64(len(services)))
	metrics.GraphQLQueriesTotal.WithLabelValues(queryName, "success").Inc()

	r.logger.Debug("GraphQL: services by tags query completed",
		logger.Int("result_count", len(services)))

	return services, nil
}

// ServicesByMetadata is the resolver for the servicesByMetadata field.
func (r *queryResolver) ServicesByMetadata(ctx context.Context, filters []*model.MetadataFilter) ([]*model.Service, error) {
	startTime := time.Now()
	queryName := "servicesByMetadata"

	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Convert GraphQL filters to map
	metaMap := make(map[string]string, len(filters))
	for _, filter := range filters {
		metaMap[filter.Key] = filter.Value
	}

	r.logger.Info("GraphQL: querying services by metadata",
		logger.Int("filter_count", len(filters)))

	// Track query complexity (number of metadata filters)
	metrics.GraphQLComplexity.WithLabelValues(queryName).Observe(float64(len(filters)))

	// Query the store
	storeServices := r.serviceStore.QueryByMetadata(metaMap)

	// Create a map for quick lookup
	serviceMap := make(map[string]bool)
	for _, svc := range storeServices {
		serviceMap[svc.Name] = true
	}

	// Get all entries to include expiration info
	allEntries := r.serviceStore.ListAll()

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(storeServices))
	for _, entry := range allEntries {
		if serviceMap[entry.Service.Name] {
			services = append(services, model.MapServiceFromStore(entry.Service, entry))
		}
	}

	// Record metrics
	duration := time.Since(startTime).Seconds()
	metrics.GraphQLResolverDuration.WithLabelValues(queryName).Observe(duration)
	metrics.GraphQLQueryDuration.WithLabelValues(queryName).Observe(duration)
	metrics.GraphQLQueryResultsCount.WithLabelValues(queryName).Observe(float64(len(services)))
	metrics.GraphQLQueriesTotal.WithLabelValues(queryName, "success").Inc()

	r.logger.Debug("GraphQL: services by metadata query completed",
		logger.Int("result_count", len(services)))

	return services, nil
}

// ServicesByQuery is the resolver for the servicesByQuery field.
func (r *queryResolver) ServicesByQuery(ctx context.Context, tags []string, metadata []*model.MetadataFilter) ([]*model.Service, error) {
	startTime := time.Now()
	queryName := "servicesByQuery"

	// Check authentication
	// TODO: Add authentication check when auth middleware is implemented

	// Handle nil tags parameter
	if tags == nil {
		tags = []string{}
	}

	// Convert GraphQL filters to map
	metaMap := make(map[string]string)
	for _, filter := range metadata {
		metaMap[filter.Key] = filter.Value
	}

	r.logger.Info("GraphQL: querying services by tags and metadata",
		logger.Int("tag_count", len(tags)),
		logger.Int("filter_count", len(metaMap)))

	// Track query complexity (tags + metadata filters)
	complexity := len(tags) + len(metaMap)
	metrics.GraphQLComplexity.WithLabelValues(queryName).Observe(float64(complexity))

	// Query the store
	storeServices := r.serviceStore.QueryByTagsAndMetadata(tags, metaMap)

	// Create a map for quick lookup
	serviceMap := make(map[string]bool)
	for _, svc := range storeServices {
		serviceMap[svc.Name] = true
	}

	// Get all entries to include expiration info
	allEntries := r.serviceStore.ListAll()

	// Map to GraphQL models
	services := make([]*model.Service, 0, len(storeServices))
	for _, entry := range allEntries {
		if serviceMap[entry.Service.Name] {
			services = append(services, model.MapServiceFromStore(entry.Service, entry))
		}
	}

	// Record metrics
	duration := time.Since(startTime).Seconds()
	metrics.GraphQLResolverDuration.WithLabelValues(queryName).Observe(duration)
	metrics.GraphQLQueryDuration.WithLabelValues(queryName).Observe(duration)
	metrics.GraphQLQueryResultsCount.WithLabelValues(queryName).Observe(float64(len(services)))
	metrics.GraphQLQueriesTotal.WithLabelValues(queryName, "success").Inc()

	r.logger.Debug("GraphQL: combined query completed",
		logger.Int("result_count", len(services)))

	return services, nil
}

// KvChanged is the resolver for the kvChanged field.
func (r *subscriptionResolver) KvChanged(ctx context.Context, key *string, prefix *string) (<-chan *model.KVChangeEvent, error) {
	// Check authentication if required
	// TODO: Add authentication check when auth middleware is implemented

	// Determine watch pattern
	pattern := ""
	if key != nil && *key != "" {
		pattern = *key
	} else if prefix != nil && *prefix != "" {
		// Use ** for prefix watch to match all nested keys
		pattern = *prefix + "**"
	} else {
		// Watch all keys
		pattern = "**"
	}

	// Create watcher through watch manager
	// TODO: Get ACL policies from context when ACL is implemented
	watcher, err := r.watchManager.AddWatcher(pattern, []string{}, "graphql", "")
	if err != nil {
		r.logger.Error("GraphQL: Failed to create KV watcher",
			logger.String("pattern", pattern),
			logger.Error(err))
		return nil, fmt.Errorf("failed to create watcher: %w", err)
	}

	r.logger.Info("GraphQL: KV subscription created",
		logger.String("pattern", pattern),
		logger.String("watcher_id", watcher.ID))

	// Create channel for GraphQL events
	eventChan := make(chan *model.KVChangeEvent, 100)

	// Start goroutine to convert watch events to GraphQL events
	go func() {
		defer func() {
			r.watchManager.RemoveWatcher(watcher.ID)
			close(eventChan)
			r.logger.Debug("GraphQL: KV subscription closed",
				logger.String("watcher_id", watcher.ID))
		}()

		for {
			select {
			case <-ctx.Done():
				// Context cancelled - subscription ended
				return
			case watchEvent, ok := <-watcher.Events:
				if !ok {
					// Channel closed
					return
				}

				// Convert watch event to GraphQL event
				eventType := model.KVEventType(watchEvent.Type)
				timestamp := scalar.FromTime(time.Unix(watchEvent.Timestamp, 0))

				gqlEvent := &model.KVChangeEvent{
					Type:      eventType,
					Key:       watchEvent.Key,
					Timestamp: timestamp,
				}

				// Add value for set events
				if watchEvent.Type == "set" {
					gqlEvent.Value = &watchEvent.Value
				}

				// Add old value if available
				if watchEvent.OldValue != "" {
					gqlEvent.OldValue = &watchEvent.OldValue
				}

				// Send event to GraphQL subscriber
				select {
				case eventChan <- gqlEvent:
					// Event sent successfully
				case <-ctx.Done():
					// Context cancelled while sending
					return
				}
			}
		}
	}()

	return eventChan, nil
}

// ServiceChanged is the resolver for the serviceChanged field.
func (r *subscriptionResolver) ServiceChanged(ctx context.Context, name *string) (<-chan *model.ServiceChangeEvent, error) {
	// TODO: Implement service watch system
	// Services don't currently have a watch/notification system like KV store does.
	// This would require adding event notifications to ServiceStore similar to KVStore.

	r.logger.Warn("GraphQL: ServiceChanged subscription not yet implemented",
		logger.String("name", stringOrEmpty(name)))

	return nil, fmt.Errorf("service subscriptions are not yet implemented - see TODO in code")
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
