# ADR-0015: Template Engine for Configuration Management

**Date**: 2025-10-10

**Status**: Proposed

**Deciders**: Konsul Core Team

**Tags**: configuration, automation, templates, integration

## Context

Applications often need to generate configuration files dynamically based on service discovery data, KV store values, and infrastructure state. Requirements:

- Generate configuration files from templates using data from Konsul
- Watch for changes and regenerate configs automatically
- Support multiple template formats (text, JSON, YAML, TOML, etc.)
- Execute commands after successful config generation (reload, restart)
- Minimal external dependencies
- Work as both standalone tool and embedded library
- Compatible with existing consul-template workflows

Common use cases include:
- Generating nginx/HAProxy configurations based on discovered services
- Creating application configs from KV store values
- Populating environment files for containers
- Updating service mesh configurations
- Managing firewall rules based on active services

## Decision

We will implement a **template engine system** inspired by consul-template that:

- Uses Go's `text/template` and `html/template` packages as the base
- Provides a standalone `konsul-template` CLI tool
- Offers an embeddable Go library for integration
- Watches KV store and service catalog for changes
- Supports custom template functions (sprig library)
- Executes post-render commands (reload/restart hooks)
- Implements de-duplication and rate limiting for rerenders
- Provides dry-run and once-mode for testing

### Architecture Components

**1. Template Engine Core**
```go
type TemplateEngine struct {
    client     *KonsulClient
    templates  []*Template
    watchers   []Watcher
    renderer   *Renderer
    executor   *CommandExecutor
}
```

**2. Template Configuration**
```hcl
template {
  source      = "/etc/konsul-template/nginx.conf.tpl"
  destination = "/etc/nginx/nginx.conf"
  command     = "nginx -s reload"
  perms       = 0644
  backup      = true
}

kv_prefix "config/app" {}
service "web" {}
```

**3. Template Functions**
- `kv "key"` - Get KV value
- `kvTree "prefix"` - Get all keys under prefix
- `service "name"` - Get service instances
- `services` - List all services
- `env "VAR"` - Get environment variable
- `file "path"` - Read file content
- Sprig functions (strings, math, crypto, etc.)

**4. Watch Mechanisms**
- KV prefix watching (via HTTP long-polling or SSE)
- Service catalog watching
- File system watching for template changes
- Intelligent batching to avoid thundering herd

### Example Template

```nginx
# Generated by konsul-template
upstream backend {
{{- range service "web" }}
    server {{ .Address }}:{{ .Port }} max_fails=3 fail_timeout=30s;
{{- end }}
}

server {
    listen 80;
    server_name {{ kv "config/domain" }};

    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
    }
}
```

### CLI Tool Design

```bash
# Run continuously with watch mode
konsul-template -config /etc/konsul-template/config.hcl

# One-shot mode (generate once and exit)
konsul-template -config config.hcl -once

# Dry-run (preview without writing)
konsul-template -config config.hcl -dry

# Template from stdin
echo '{{ kv "greeting" }}' | konsul-template -stdin -once
```

## Alternatives Considered

### Alternative 1: Use consul-template directly
- **Pros**:
  - Mature, battle-tested solution
  - Rich ecosystem and documentation
  - No development effort needed
  - Full feature parity with Consul
- **Cons**:
  - External dependency on HashiCorp tools
  - Not optimized for Konsul's API
  - Larger binary size
  - No control over roadmap
  - May have features we don't need
- **Reason for rejection**: Want native integration with Konsul; opportunity to simplify for our use case

### Alternative 2: Confd (config management tool)
- **Pros**:
  - Supports multiple backends (etcd, Consul, etc.)
  - Active community
  - TOML-based configuration
  - Proven in production
- **Cons**:
  - Generic tool, not optimized for our stack
  - Additional dependency
  - Less template function flexibility
  - Different configuration format
- **Reason for rejection**: Want purpose-built tool for Konsul with simpler interface

### Alternative 3: Envsubst + scripts
- **Pros**:
  - Simple, built into most systems
  - No additional tools needed
  - Easy to understand
- **Cons**:
  - No service discovery integration
  - Manual API calls needed
  - No watch functionality
  - Error-prone scripting
  - No template validation
- **Reason for rejection**: Too primitive; lacks automation and service discovery features

### Alternative 4: Custom scripting per application
- **Pros**:
  - Maximum flexibility
  - Application-specific logic
  - No additional tools
- **Cons**:
  - Code duplication across services
  - Maintenance burden
  - No standardization
  - Each team reinvents the wheel
  - Testing complexity
- **Reason for rejection**: Want consistent, reusable solution across all applications

### Alternative 5: Kubernetes ConfigMaps with init containers
- **Pros**:
  - Native Kubernetes integration
  - Declarative configuration
  - Built-in versioning
- **Cons**:
  - Kubernetes-only solution
  - No dynamic updates based on service changes
  - Requires custom controllers for dynamic content
  - Not suitable for non-K8s environments
- **Reason for rejection**: Need solution that works outside Kubernetes

## Consequences

### Positive
- Dynamic configuration generation without code changes
- Automatic config updates when services change
- Reduces manual configuration errors
- Standardized approach across all applications
- Compatible with existing tools expecting consul-template
- Native integration with Konsul's API
- Smaller binary than consul-template
- Full control over features and roadmap
- Can optimize for Konsul-specific use cases

### Negative
- Another tool to maintain and support
- Template syntax learning curve for operators
- Potential for config errors if templates are wrong
- Need to implement security features (sandbox execution)
- Command execution could be security risk if misused
- Watch mechanism increases server load
- Need comprehensive error handling for failed renders
- Breaking changes if template syntax evolves

### Neutral
- Operators need to write and test templates
- Requires understanding of Go template syntax
- File permissions and ownership management needed
- Backup/rollback strategy required for critical configs
- Logging and monitoring setup for template engine
- Documentation and examples needed

## Implementation Notes

### Phase 1: Core Template Engine (MVP)
- Basic template rendering with `text/template`
- KV store integration (`kv`, `kvTree` functions)
- Service discovery integration (`service`, `services` functions)
- File writing with permissions
- Once-mode (generate and exit)

### Phase 2: Watch & Auto-reload
- Watch KV prefixes for changes
- Watch service catalog
- Intelligent de-duplication (avoid rapid rerenders)
- Command execution after successful render
- Backup before overwriting

### Phase 3: Advanced Features
- Extended template functions (sprig integration)
- Multiple template support in one process
- Dry-run mode
- Template validation
- Configuration file format (HCL/YAML)

### Phase 4: Production Hardening
- Metrics (render count, duration, errors)
- Structured logging
- Health check endpoint
- Graceful shutdown
- Signal handling (SIGHUP to reload templates)
- Security: sandboxed command execution

### Configuration Format (HCL)

```hcl
konsul {
  address = "localhost:8500"
  token   = "secret"
}

template {
  source      = "templates/nginx.conf.tpl"
  destination = "/etc/nginx/nginx.conf"
  command     = "systemctl reload nginx"
  perms       = "0644"
  backup      = true
  wait {
    min = "2s"
    max = "10s"
  }
}

template {
  source      = "templates/env.tpl"
  destination = "/app/.env"
  perms       = "0600"
}
```

### Security Considerations

- Validate template syntax before execution
- Restrict command execution (whitelist approach)
- File permission controls
- User/group ownership settings
- Audit logging for renders and command executions
- Rate limiting to prevent abuse
- Template size limits
- Timeout for long-running commands

### Error Handling

- Retry failed renders with exponential backoff
- Continue on partial failures (some templates fail, others succeed)
- Alert on persistent failures
- Preserve previous config if render fails (atomic writes)
- Detailed error messages with template line numbers

### Testing Strategy

- Unit tests for template functions
- Integration tests with mock Konsul API
- End-to-end tests with real Konsul instance
- Template validation tests
- Command execution tests (sandboxed)
- Watch mechanism tests

### Metrics to Track

- `konsul_template_renders_total` - Total renders
- `konsul_template_render_duration_seconds` - Render latency
- `konsul_template_render_errors_total` - Failed renders
- `konsul_template_commands_executed_total` - Commands run
- `konsul_template_commands_failed_total` - Failed commands
- `konsul_template_file_writes_total` - Files written

### Library Usage Example

```go
import "github.com/yourusername/konsul/pkg/template"

engine := template.New(template.Config{
    KonsulAddr: "localhost:8500",
    Templates: []template.TemplateSpec{
        {
            Source: "app.conf.tpl",
            Dest:   "/etc/app.conf",
            Perms:  0644,
        },
    },
})

if err := engine.RunOnce(); err != nil {
    log.Fatal(err)
}

// Or watch mode
if err := engine.Run(ctx); err != nil {
    log.Fatal(err)
}
```

### Migration Path

For users migrating from consul-template:
1. Most templates work as-is (same syntax)
2. Configuration format slightly different (document mapping)
3. Some advanced features may not be implemented initially
4. Provide migration guide and compatibility matrix
5. consul-template can run alongside during transition

### Future Enhancements

- WebAssembly plugin support for custom functions
- Remote template storage (fetch from KV store)
- Template versioning and rollback
- Multi-datacenter template support
- Diff preview before applying changes
- Integration with secret management systems
- Support for additional formats (Jsonnet, CUE)

## References

- [consul-template](https://github.com/hashicorp/consul-template)
- [Go text/template](https://pkg.go.dev/text/template)
- [Sprig Template Functions](http://masterminds.github.io/sprig/)
- [confd](https://github.com/kelseyhightower/confd)
- [Go HCL Parser](https://github.com/hashicorp/hcl)
- [Konsul TODO: Template Engine](../../TODO.md#9-consul-inspired-features-high-value)

---

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2025-10-10 | Konsul Team | Initial version |
