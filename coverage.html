
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>konsul-template: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/neogan74/konsul/cmd/konsul-template/client.go (0.0%)</option>
				
				<option value="file1">github.com/neogan74/konsul/cmd/konsul-template/main.go (0.0%)</option>
				
				<option value="file2">github.com/neogan74/konsul/cmd/konsul/main.go (0.0%)</option>
				
				<option value="file3">github.com/neogan74/konsul/cmd/konsulctl/backup_commands.go (0.0%)</option>
				
				<option value="file4">github.com/neogan74/konsul/cmd/konsulctl/cli.go (0.0%)</option>
				
				<option value="file5">github.com/neogan74/konsul/cmd/konsulctl/client.go (0.0%)</option>
				
				<option value="file6">github.com/neogan74/konsul/cmd/konsulctl/dns_commands.go (0.0%)</option>
				
				<option value="file7">github.com/neogan74/konsul/cmd/konsulctl/kv_commands.go (0.0%)</option>
				
				<option value="file8">github.com/neogan74/konsul/cmd/konsulctl/main.go (0.0%)</option>
				
				<option value="file9">github.com/neogan74/konsul/cmd/konsulctl/ratelimit_commands.go (0.0%)</option>
				
				<option value="file10">github.com/neogan74/konsul/cmd/konsulctl/service_commands.go (0.0%)</option>
				
				<option value="file11">github.com/neogan74/konsul/internal/acl/evaluator.go (59.4%)</option>
				
				<option value="file12">github.com/neogan74/konsul/internal/acl/types.go (69.6%)</option>
				
				<option value="file13">github.com/neogan74/konsul/internal/auth/apikey.go (97.6%)</option>
				
				<option value="file14">github.com/neogan74/konsul/internal/auth/jwt.go (84.4%)</option>
				
				<option value="file15">github.com/neogan74/konsul/internal/config/config.go (44.0%)</option>
				
				<option value="file16">github.com/neogan74/konsul/internal/dns/server.go (94.4%)</option>
				
				<option value="file17">github.com/neogan74/konsul/internal/graphql/generated/generated.go (0.0%)</option>
				
				<option value="file18">github.com/neogan74/konsul/internal/graphql/model/mappers.go (0.0%)</option>
				
				<option value="file19">github.com/neogan74/konsul/internal/graphql/model/models_gen.go (0.0%)</option>
				
				<option value="file20">github.com/neogan74/konsul/internal/graphql/resolver/resolver.go (0.0%)</option>
				
				<option value="file21">github.com/neogan74/konsul/internal/graphql/resolver/schema.resolvers.go (0.0%)</option>
				
				<option value="file22">github.com/neogan74/konsul/internal/graphql/scalar/duration.go (0.0%)</option>
				
				<option value="file23">github.com/neogan74/konsul/internal/graphql/scalar/time.go (0.0%)</option>
				
				<option value="file24">github.com/neogan74/konsul/internal/graphql/server.go (0.0%)</option>
				
				<option value="file25">github.com/neogan74/konsul/internal/handlers/acl.go (0.0%)</option>
				
				<option value="file26">github.com/neogan74/konsul/internal/handlers/auth.go (0.0%)</option>
				
				<option value="file27">github.com/neogan74/konsul/internal/handlers/backup.go (0.0%)</option>
				
				<option value="file28">github.com/neogan74/konsul/internal/handlers/health.go (94.4%)</option>
				
				<option value="file29">github.com/neogan74/konsul/internal/handlers/healthcheck.go (0.0%)</option>
				
				<option value="file30">github.com/neogan74/konsul/internal/handlers/kv.go (84.2%)</option>
				
				<option value="file31">github.com/neogan74/konsul/internal/handlers/ratelimit.go (90.5%)</option>
				
				<option value="file32">github.com/neogan74/konsul/internal/handlers/service.go (100.0%)</option>
				
				<option value="file33">github.com/neogan74/konsul/internal/healthcheck/grpc.go (0.0%)</option>
				
				<option value="file34">github.com/neogan74/konsul/internal/healthcheck/http.go (0.0%)</option>
				
				<option value="file35">github.com/neogan74/konsul/internal/healthcheck/manager.go (0.0%)</option>
				
				<option value="file36">github.com/neogan74/konsul/internal/healthcheck/tcp.go (0.0%)</option>
				
				<option value="file37">github.com/neogan74/konsul/internal/logger/logger.go (84.8%)</option>
				
				<option value="file38">github.com/neogan74/konsul/internal/middleware/acl.go (0.0%)</option>
				
				<option value="file39">github.com/neogan74/konsul/internal/middleware/apikey.go (0.0%)</option>
				
				<option value="file40">github.com/neogan74/konsul/internal/middleware/errors.go (0.0%)</option>
				
				<option value="file41">github.com/neogan74/konsul/internal/middleware/jwt.go (0.0%)</option>
				
				<option value="file42">github.com/neogan74/konsul/internal/middleware/logging.go (0.0%)</option>
				
				<option value="file43">github.com/neogan74/konsul/internal/middleware/metrics.go (0.0%)</option>
				
				<option value="file44">github.com/neogan74/konsul/internal/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file45">github.com/neogan74/konsul/internal/middleware/tracing.go (0.0%)</option>
				
				<option value="file46">github.com/neogan74/konsul/internal/persistence/badger.go (65.1%)</option>
				
				<option value="file47">github.com/neogan74/konsul/internal/persistence/factory.go (0.0%)</option>
				
				<option value="file48">github.com/neogan74/konsul/internal/persistence/memory.go (87.8%)</option>
				
				<option value="file49">github.com/neogan74/konsul/internal/ratelimit/limiter.go (53.5%)</option>
				
				<option value="file50">github.com/neogan74/konsul/internal/store/kv.go (21.3%)</option>
				
				<option value="file51">github.com/neogan74/konsul/internal/store/service.go (40.4%)</option>
				
				<option value="file52">github.com/neogan74/konsul/internal/telemetry/tracing.go (0.0%)</option>
				
				<option value="file53">github.com/neogan74/konsul/internal/template/engine.go (0.0%)</option>
				
				<option value="file54">github.com/neogan74/konsul/internal/template/executor.go (3.1%)</option>
				
				<option value="file55">github.com/neogan74/konsul/internal/template/functions.go (68.3%)</option>
				
				<option value="file56">github.com/neogan74/konsul/internal/template/renderer.go (56.8%)</option>
				
				<option value="file57">github.com/neogan74/konsul/internal/template/watcher.go (0.0%)</option>
				
				<option value="file58">github.com/neogan74/konsul/internal/tls/cert.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/template"
)

// KonsulClient is a simple HTTP client for Konsul
type KonsulClient struct {
        addr       string
        httpClient *http.Client
        log        logger.Logger
        kvCache    *KVCache
        svcCache   *ServiceCache
}

// NewKonsulClient creates a new Konsul client
func NewKonsulClient(addr string, log logger.Logger) *KonsulClient <span class="cov0" title="0">{
        return &amp;KonsulClient{
                addr: addr,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                log:      log,
                kvCache:  NewKVCache(),
                svcCache: NewServiceCache(),
        }
}</span>

// KVStore returns the KV store interface
func (c *KonsulClient) KVStore() template.KVStoreReader <span class="cov0" title="0">{
        // Fetch initial data
        c.refreshKV()
        return c.kvCache
}</span>

// ServiceStore returns the service store interface
func (c *KonsulClient) ServiceStore() template.ServiceStoreReader <span class="cov0" title="0">{
        // Fetch initial data
        c.refreshServices()
        return c.svcCache
}</span>

// refreshKV fetches KV data from Konsul
func (c *KonsulClient) refreshKV() error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/kv", c.addr)
        resp, err := c.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Warn("Failed to fetch KV data", logger.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                c.log.Warn("KV endpoint returned non-200 status",
                        logger.Int("status", resp.StatusCode))
                return fmt.Errorf("unexpected status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var kvData map[string]string
        if err := json.Unmarshal(body, &amp;kvData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.kvCache.Update(kvData)
        return nil</span>
}

// refreshServices fetches service data from Konsul
func (c *KonsulClient) refreshServices() error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/services", c.addr)
        resp, err := c.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Warn("Failed to fetch service data", logger.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                c.log.Warn("Services endpoint returned non-200 status",
                        logger.Int("status", resp.StatusCode))
                return fmt.Errorf("unexpected status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var services []template.Service
        if err := json.Unmarshal(body, &amp;services); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.svcCache.Update(services)
        return nil</span>
}

// KVCache caches KV data
type KVCache struct {
        mu   sync.RWMutex
        data map[string]string
}

// NewKVCache creates a new KV cache
func NewKVCache() *KVCache <span class="cov0" title="0">{
        return &amp;KVCache{
                data: make(map[string]string),
        }
}</span>

func (c *KVCache) Get(key string) (string, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        val, ok := c.data[key]
        return val, ok
}</span>

func (c *KVCache) List() []string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        keys := make([]string, 0, len(c.data))
        for k := range c.data </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

func (c *KVCache) Update(data map[string]string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.data = data
}</span>

// ServiceCache caches service data
type ServiceCache struct {
        mu       sync.RWMutex
        services map[string]template.Service
}

// NewServiceCache creates a new service cache
func NewServiceCache() *ServiceCache <span class="cov0" title="0">{
        return &amp;ServiceCache{
                services: make(map[string]template.Service),
        }
}</span>

func (c *ServiceCache) Get(name string) (template.Service, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        svc, ok := c.services[name]
        return svc, ok
}</span>

func (c *ServiceCache) List() []template.Service <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        services := make([]template.Service, 0, len(c.services))
        for _, svc := range c.services </span><span class="cov0" title="0">{
                services = append(services, svc)
        }</span>
        <span class="cov0" title="0">return services</span>
}

func (c *ServiceCache) Update(services []template.Service) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.services = make(map[string]template.Service)
        for _, svc := range services </span><span class="cov0" title="0">{
                c.services[svc.Name] = svc
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/template"
)

const version = "0.1.0"

func main() <span class="cov0" title="0">{
        // Command line flags
        var (
                configFile  = flag.String("config", "", "Path to configuration file (HCL or JSON)")
                once        = flag.Bool("once", false, "Run once and exit (don't watch for changes)")
                dryRun      = flag.Bool("dry", false, "Dry run mode (render but don't write files)")
                konsulAddr  = flag.String("konsul", "http://localhost:8500", "Konsul server address")
                templateSrc = flag.String("template", "", "Single template source file")
                dest        = flag.String("dest", "", "Single template destination file")
                showVersion = flag.Bool("version", false, "Show version and exit")
        )

        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("konsul-template version %s\n", version)
                os.Exit(0)
        }</span>

        // Setup logger
        <span class="cov0" title="0">log := logger.GetDefault()

        // For now, we'll implement a simple mode that works with command-line args
        // Later we can add HCL/JSON config file support
        if *templateSrc == "" &amp;&amp; *configFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Error: either -template or -config must be specified")
                flag.Usage()
                os.Exit(1)
        }</span>

        // Create a simple client that connects to Konsul
        <span class="cov0" title="0">client := NewKonsulClient(*konsulAddr, log)

        // Build configuration
        config := template.Config{
                Once:       *once,
                DryRun:     *dryRun,
                KonsulAddr: *konsulAddr,
        }

        // Add template from command line if specified
        if *templateSrc != "" </span><span class="cov0" title="0">{
                if *dest == "" </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Error: -dest must be specified when using -template")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">config.Templates = []template.TemplateConfig{
                        {
                                Source:      *templateSrc,
                                Destination: *dest,
                                Perms:       0644,
                        },
                }</span>
        }

        // Create template engine
        <span class="cov0" title="0">engine := template.New(config, client.KVStore(), client.ServiceStore(), log)

        if *once </span><span class="cov0" title="0">{
                // Run once mode
                log.Info("Running in once mode")
                if err := engine.RunOnce(); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to run templates", logger.Error(err))
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">log.Info("Templates rendered successfully")
                return</span>
        }

        // Watch mode
        <span class="cov0" title="0">log.Info("Starting watch mode (press Ctrl+C to stop)")

        // Setup signal handling
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)

        // Start engine in background
        errCh := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                errCh &lt;- engine.Run(ctx)
        }</span>()

        // Wait for signal or error
        <span class="cov0" title="0">select </span>{
        case &lt;-sigCh:<span class="cov0" title="0">
                log.Info("Received interrupt signal, shutting down...")
                cancel()
                // Give engine time to clean up
                time.Sleep(1 * time.Second)</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Engine error", logger.Error(err))
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">log.Info("Shutdown complete")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "embed"
        "fmt"
        "io/fs"
        "log"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "syscall"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/adaptor"
        "github.com/gofiber/fiber/v2/middleware/filesystem"
        "github.com/neogan74/konsul/internal/acl"
        "github.com/neogan74/konsul/internal/auth"
        "github.com/neogan74/konsul/internal/config"
        "github.com/neogan74/konsul/internal/dns"
        "github.com/neogan74/konsul/internal/graphql"
        "github.com/neogan74/konsul/internal/graphql/resolver"
        "github.com/neogan74/konsul/internal/handlers"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/metrics"
        "github.com/neogan74/konsul/internal/middleware"
        "github.com/neogan74/konsul/internal/persistence"
        "github.com/neogan74/konsul/internal/ratelimit"
        "github.com/neogan74/konsul/internal/store"
        "github.com/neogan74/konsul/internal/telemetry"
        konsultls "github.com/neogan74/konsul/internal/tls"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

//go:embed all:ui
var adminUI embed.FS

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Initialize structured logger
        <span class="cov0" title="0">appLogger := logger.NewFromConfig(cfg.Log.Level, cfg.Log.Format)
        logger.SetDefault(appLogger)

        version := "0.1.0"
        appLogger.Info("Starting Konsul",
                logger.String("version", version),
                logger.String("address", cfg.Address()),
                logger.String("log_level", cfg.Log.Level),
                logger.String("log_format", cfg.Log.Format),
                logger.String("persistence_enabled", fmt.Sprintf("%t", cfg.Persistence.Enabled)),
                logger.String("persistence_type", cfg.Persistence.Type))

        // Set build info metrics
        metrics.BuildInfo.WithLabelValues(version, runtime.Version()).Set(1)

        // Initialize OpenTelemetry tracing
        ctx := context.Background()
        tracingCfg := telemetry.TracingConfig{
                Enabled:        cfg.Tracing.Enabled,
                Endpoint:       cfg.Tracing.Endpoint,
                ServiceName:    cfg.Tracing.ServiceName,
                ServiceVersion: cfg.Tracing.ServiceVersion,
                Environment:    cfg.Tracing.Environment,
                SamplingRatio:  cfg.Tracing.SamplingRatio,
                InsecureConn:   cfg.Tracing.InsecureConn,
        }

        tracerProvider, err := telemetry.InitTracing(ctx, tracingCfg)
        if err != nil </span><span class="cov0" title="0">{
                appLogger.Error("Failed to initialize tracing", logger.Error(err))
        }</span> else<span class="cov0" title="0"> if cfg.Tracing.Enabled </span><span class="cov0" title="0">{
                appLogger.Info("OpenTelemetry tracing initialized",
                        logger.String("endpoint", cfg.Tracing.Endpoint),
                        logger.String("service_name", cfg.Tracing.ServiceName))

                // Ensure graceful shutdown of tracer provider
                defer func() </span><span class="cov0" title="0">{
                        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                        defer cancel()
                        if err := tracerProvider.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                                appLogger.Error("Failed to shutdown tracer provider", logger.Error(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">app := fiber.New()

        // Add middleware
        app.Use(middleware.RequestLogging(appLogger))
        app.Use(middleware.MetricsMiddleware())

        // Add tracing middleware if enabled
        if cfg.Tracing.Enabled </span><span class="cov0" title="0">{
                app.Use(middleware.TracingMiddleware(cfg.Tracing.ServiceName))
        }</span>

        // Initialize rate limiting
        <span class="cov0" title="0">var rateLimitService *ratelimit.Service
        if cfg.RateLimit.Enabled </span><span class="cov0" title="0">{
                rateLimitService = ratelimit.NewService(ratelimit.Config{
                        Enabled:         cfg.RateLimit.Enabled,
                        RequestsPerSec:  cfg.RateLimit.RequestsPerSec,
                        Burst:           cfg.RateLimit.Burst,
                        ByIP:            cfg.RateLimit.ByIP,
                        ByAPIKey:        cfg.RateLimit.ByAPIKey,
                        CleanupInterval: cfg.RateLimit.CleanupInterval,
                })

                app.Use(middleware.RateLimitMiddleware(rateLimitService))

                appLogger.Info("Rate limiting enabled",
                        logger.String("requests_per_sec", fmt.Sprintf("%.1f", cfg.RateLimit.RequestsPerSec)),
                        logger.Int("burst", cfg.RateLimit.Burst),
                        logger.String("by_ip", fmt.Sprintf("%t", cfg.RateLimit.ByIP)),
                        logger.String("by_apikey", fmt.Sprintf("%t", cfg.RateLimit.ByAPIKey)),
                )

                // Update rate limit metrics periodically
                go func() </span><span class="cov0" title="0">{
                        ticker := time.NewTicker(10 * time.Second)
                        defer ticker.Stop()
                        for range ticker.C </span><span class="cov0" title="0">{
                                stats := rateLimitService.Stats()
                                if ipCount, ok := stats["ip_limiters"].(int); ok </span><span class="cov0" title="0">{
                                        metrics.RateLimitActiveClients.WithLabelValues("ip").Set(float64(ipCount))
                                }</span>
                                <span class="cov0" title="0">if keyCount, ok := stats["apikey_limiters"].(int); ok </span><span class="cov0" title="0">{
                                        metrics.RateLimitActiveClients.WithLabelValues("apikey").Set(float64(keyCount))
                                }</span>
                        }
                }()
        }

        // Initialize persistence engine
        <span class="cov0" title="0">var engine persistence.Engine
        if cfg.Persistence.Enabled </span><span class="cov0" title="0">{
                engine, err = persistence.NewEngine(persistence.Config{
                        Enabled:    cfg.Persistence.Enabled,
                        Type:       cfg.Persistence.Type,
                        DataDir:    cfg.Persistence.DataDir,
                        BackupDir:  cfg.Persistence.BackupDir,
                        SyncWrites: cfg.Persistence.SyncWrites,
                        WALEnabled: cfg.Persistence.WALEnabled,
                }, appLogger)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to initialize persistence engine: %v", err)
                }</span>

                // Ensure graceful shutdown
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if err := engine.Close(); err != nil </span><span class="cov0" title="0">{
                                appLogger.Error("Failed to close persistence engine", logger.Error(err))
                        }</span>
                }()
        }

        // Initialize stores
        <span class="cov0" title="0">var kv *store.KVStore
        var svcStore *store.ServiceStore

        if cfg.Persistence.Enabled </span><span class="cov0" title="0">{
                kv, err = store.NewKVStoreWithPersistence(engine, appLogger)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to initialize KV store: %v", err)
                }</span>

                <span class="cov0" title="0">svcStore, err = store.NewServiceStoreWithPersistence(cfg.Service.TTL, engine, appLogger)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to initialize service store: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                kv = store.NewKVStore()
                svcStore = store.NewServiceStoreWithTTL(cfg.Service.TTL)
        }</span>

        // Ensure stores are closed on shutdown
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := kv.Close(); err != nil </span><span class="cov0" title="0">{
                        appLogger.Error("Failed to close KV store", logger.Error(err))
                }</span>
                <span class="cov0" title="0">if err := svcStore.Close(); err != nil </span><span class="cov0" title="0">{
                        appLogger.Error("Failed to close service store", logger.Error(err))
                }</span>
        }()

        // Initialize handlers
        <span class="cov0" title="0">kvHandler := handlers.NewKVHandler(kv)
        serviceHandler := handlers.NewServiceHandler(svcStore)
        healthHandler := handlers.NewHealthHandler(kv, svcStore, version)
        healthCheckHandler := handlers.NewHealthCheckHandler(svcStore)
        backupHandler := handlers.NewBackupHandler(engine, appLogger)

        // Initialize store metrics
        metrics.KVStoreSize.Set(float64(len(kv.List())))
        metrics.RegisteredServicesTotal.Set(float64(len(svcStore.List())))

        // Initialize auth services if enabled
        var jwtService *auth.JWTService
        var authHandler *handlers.AuthHandler
        if cfg.Auth.Enabled </span><span class="cov0" title="0">{
                jwtService = auth.NewJWTService(
                        cfg.Auth.JWTSecret,
                        cfg.Auth.JWTExpiry,
                        cfg.Auth.RefreshExpiry,
                        cfg.Auth.Issuer,
                )
                apiKeyService := auth.NewAPIKeyService(cfg.Auth.APIKeyPrefix)
                authHandler = handlers.NewAuthHandler(jwtService, apiKeyService)
        }</span>

        // Initialize ACL system if enabled
        <span class="cov0" title="0">var aclEvaluator *acl.Evaluator
        var aclHandler *handlers.ACLHandler
        if cfg.ACL.Enabled </span><span class="cov0" title="0">{
                aclEvaluator = acl.NewEvaluator(appLogger)
                aclHandler = handlers.NewACLHandler(aclEvaluator, cfg.ACL.PolicyDir, appLogger)

                // Load policies from disk
                if err := aclHandler.LoadPolicies(); err != nil </span><span class="cov0" title="0">{
                        appLogger.Error("Failed to load ACL policies", logger.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        policyCount := aclEvaluator.Count()
                        metrics.ACLPoliciesLoaded.Set(float64(policyCount))
                        appLogger.Info("ACL system initialized",
                                logger.Int("policies", policyCount),
                                logger.String("policy_dir", cfg.ACL.PolicyDir))
                }</span>
        }

        // Auth endpoints (public)
        <span class="cov0" title="0">if cfg.Auth.Enabled </span><span class="cov0" title="0">{
                app.Post("/auth/login", authHandler.Login)
                app.Post("/auth/refresh", authHandler.Refresh)
                app.Get("/auth/verify", middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths), authHandler.Verify)

                // API key management endpoints (protected)
                app.Post("/auth/apikeys", middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths), authHandler.CreateAPIKey)
                app.Get("/auth/apikeys", middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths), authHandler.ListAPIKeys)
                app.Get("/auth/apikeys/:id", middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths), authHandler.GetAPIKey)
                app.Put("/auth/apikeys/:id", middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths), authHandler.UpdateAPIKey)
                app.Delete("/auth/apikeys/:id", middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths), authHandler.DeleteAPIKey)
                app.Post("/auth/apikeys/:id/revoke", middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths), authHandler.RevokeAPIKey)
        }</span>

        // Apply auth middleware to protected routes if required
        <span class="cov0" title="0">if cfg.Auth.RequireAuth &amp;&amp; cfg.Auth.Enabled </span><span class="cov0" title="0">{
                app.Use(middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths))
        }</span>

        // ACL management endpoints (requires admin ACL permission)
        <span class="cov0" title="0">if cfg.ACL.Enabled </span><span class="cov0" title="0">{
                aclRoutes := app.Group("/acl")
                if cfg.Auth.Enabled </span><span class="cov0" title="0">{
                        aclRoutes.Use(middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths))
                        aclRoutes.Use(middleware.ACLMiddleware(aclEvaluator, acl.ResourceTypeAdmin, acl.CapabilityWrite))
                }</span>
                <span class="cov0" title="0">aclRoutes.Post("/policies", aclHandler.CreatePolicy)
                aclRoutes.Get("/policies", aclHandler.ListPolicies)
                aclRoutes.Get("/policies/:name", aclHandler.GetPolicy)
                aclRoutes.Put("/policies/:name", aclHandler.UpdatePolicy)
                aclRoutes.Delete("/policies/:name", aclHandler.DeletePolicy)
                aclRoutes.Post("/test", aclHandler.TestPolicy)</span>
        }

        // Rate limit management endpoints (requires admin permission)
        <span class="cov0" title="0">if cfg.RateLimit.Enabled </span><span class="cov0" title="0">{
                rateLimitHandler := handlers.NewRateLimitHandler(rateLimitService, appLogger)
                adminRateLimitRoutes := app.Group("/admin/ratelimit")

                // Apply authentication and ACL middleware
                if cfg.Auth.Enabled </span><span class="cov0" title="0">{
                        adminRateLimitRoutes.Use(middleware.JWTAuth(jwtService, cfg.Auth.PublicPaths))
                        if cfg.ACL.Enabled </span><span class="cov0" title="0">{
                                adminRateLimitRoutes.Use(middleware.ACLMiddleware(aclEvaluator, acl.ResourceTypeAdmin, acl.CapabilityWrite))
                        }</span>
                }

                // Read-only endpoints (for monitoring)
                <span class="cov0" title="0">adminRateLimitRoutes.Get("/stats", rateLimitHandler.GetStats)
                adminRateLimitRoutes.Get("/config", rateLimitHandler.GetConfig)
                adminRateLimitRoutes.Get("/clients", rateLimitHandler.GetActiveClients)
                adminRateLimitRoutes.Get("/client/:identifier", rateLimitHandler.GetClientStatus)

                // Write endpoints (for management)
                adminRateLimitRoutes.Post("/reset/ip/:ip", rateLimitHandler.ResetIP)
                adminRateLimitRoutes.Post("/reset/apikey/:key_id", rateLimitHandler.ResetAPIKey)
                adminRateLimitRoutes.Post("/reset/all", rateLimitHandler.ResetAll)
                adminRateLimitRoutes.Put("/config", rateLimitHandler.UpdateConfig)

                appLogger.Info("Rate limit admin endpoints registered")</span>
        }

        // KV endpoints - with ACL enforcement if enabled
        <span class="cov0" title="0">if cfg.ACL.Enabled </span><span class="cov0" title="0">{
                app.Get("/kv/", middleware.ACLMiddleware(aclEvaluator, acl.ResourceTypeKV, acl.CapabilityList), kvHandler.List)
                app.Get("/kv/:key", middleware.ACLMiddleware(aclEvaluator, acl.ResourceTypeKV, acl.CapabilityRead), kvHandler.Get)
                app.Put("/kv/:key", middleware.ACLMiddleware(aclEvaluator, acl.ResourceTypeKV, acl.CapabilityWrite), kvHandler.Set)
                app.Delete("/kv/:key", middleware.ACLMiddleware(aclEvaluator, acl.ResourceTypeKV, acl.CapabilityDelete), kvHandler.Delete)
        }</span> else<span class="cov0" title="0"> {
                app.Get("/kv/", kvHandler.List)
                app.Get("/kv/:key", kvHandler.Get)
                app.Put("/kv/:key", kvHandler.Set)
                app.Delete("/kv/:key", kvHandler.Delete)
        }</span>

        // Service discovery endpoints
        <span class="cov0" title="0">app.Put("/register", serviceHandler.Register)
        app.Get("/services/", serviceHandler.List)
        app.Get("/services/:name", serviceHandler.Get)
        app.Delete("/deregister/:name", serviceHandler.Deregister)
        app.Put("/heartbeat/:name", serviceHandler.Heartbeat)

        // Health check endpoints
        app.Get("/health", healthHandler.Check)
        app.Get("/health/live", healthHandler.Liveness)
        app.Get("/health/ready", healthHandler.Readiness)

        // Service health check endpoints
        app.Get("/health/checks", healthCheckHandler.ListChecks)
        app.Get("/health/service/:name", healthCheckHandler.GetServiceChecks)
        app.Put("/health/check/:id", healthCheckHandler.UpdateTTLCheck)

        // Backup/restore endpoints
        app.Post("/backup", backupHandler.CreateBackup)
        app.Post("/restore", backupHandler.RestoreBackup)
        app.Get("/export", backupHandler.ExportData)
        app.Post("/import", backupHandler.ImportData)
        app.Get("/backups", backupHandler.ListBackups)

        // Metrics endpoint for Prometheus
        app.Get("/metrics", adaptor.HTTPHandler(promhttp.Handler()))

        // Admin UI (embedded static files)
        uiFS, err := fs.Sub(adminUI, "ui")
        if err != nil </span><span class="cov0" title="0">{
                appLogger.Warn("Failed to load embedded admin UI", logger.Error(err))
        }</span> else<span class="cov0" title="0"> {
                app.Use("/ui", filesystem.New(filesystem.Config{
                        Root:       http.FS(uiFS),
                        PathPrefix: "",
                        Browse:     false,
                        Index:      "index.html",
                }))

                // Redirect root to UI
                app.Get("/", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                        return c.Redirect("/ui")
                }</span>)

                <span class="cov0" title="0">appLogger.Info("Admin UI available at /ui")</span>
        }

        // GraphQL setup (if enabled)
        <span class="cov0" title="0">if cfg.GraphQL.Enabled </span><span class="cov0" title="0">{
                gqlDeps := resolver.ResolverDependencies{
                        KVStore:      kv,
                        ServiceStore: svcStore,
                        ACLEvaluator: aclEvaluator,
                        JWTService:   jwtService,
                        Logger:       appLogger,
                        Version:      version,
                }

                gqlServer := graphql.NewServer(gqlDeps)

                // GraphQL endpoint
                app.All("/graphql", adaptor.HTTPHandlerFunc(gqlServer.Handler().ServeHTTP))

                // GraphQL Playground (disable in production)
                if cfg.GraphQL.PlaygroundEnabled </span><span class="cov0" title="0">{
                        app.Get("/graphql/playground", adaptor.HTTPHandlerFunc(gqlServer.PlaygroundHandler().ServeHTTP))
                        appLogger.Info("GraphQL Playground available at /graphql/playground")
                }</span>

                <span class="cov0" title="0">appLogger.Info("GraphQL API enabled at /graphql")</span>
        }

        // Start background cleanup process
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(cfg.Service.CleanupInterval)
                defer ticker.Stop()
                for range ticker.C </span><span class="cov0" title="0">{
                        count := svcStore.CleanupExpired()
                        if count &gt; 0 </span><span class="cov0" title="0">{
                                appLogger.Info("Cleaned up expired services", logger.Int("count", count))
                                metrics.ExpiredServicesTotal.Add(float64(count))
                                metrics.RegisteredServicesTotal.Set(float64(len(svcStore.List())))
                        }</span>
                }
        }()

        // Start DNS server if enabled
        <span class="cov0" title="0">var dnsServer *dns.Server
        if cfg.DNS.Enabled </span><span class="cov0" title="0">{
                dnsConfig := dns.Config{
                        Host:   cfg.DNS.Host,
                        Port:   cfg.DNS.Port,
                        Domain: cfg.DNS.Domain,
                }
                dnsServer = dns.NewServer(dnsConfig, svcStore, appLogger)
                if err := dnsServer.Start(); err != nil </span><span class="cov0" title="0">{
                        appLogger.Error("Failed to start DNS server", logger.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        appLogger.Info("DNS server started",
                                logger.String("domain", cfg.DNS.Domain),
                                logger.Int("port", cfg.DNS.Port))
                }</span>
        }

        // Handle TLS configuration
        <span class="cov0" title="0">if cfg.Server.TLS.Enabled </span><span class="cov0" title="0">{
                if cfg.Server.TLS.AutoCert </span><span class="cov0" title="0">{
                        certFile := "./certs/server.crt"
                        keyFile := "./certs/server.key"

                        // Create certs directory if it doesn't exist
                        if err := os.MkdirAll("./certs", 0755); err != nil </span><span class="cov0" title="0">{
                                appLogger.Error("Failed to create certs directory", logger.Error(err))
                                log.Fatalf("Failed to create certs directory: %v", err)
                        }</span>

                        // Generate self-signed certificate if files don't exist
                        <span class="cov0" title="0">if _, err := os.Stat(certFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                appLogger.Info("Generating self-signed TLS certificate for development")
                                if err := konsultls.GenerateSelfSignedCert(certFile, keyFile); err != nil </span><span class="cov0" title="0">{
                                        appLogger.Error("Failed to generate self-signed certificate", logger.Error(err))
                                        log.Fatalf("Failed to generate certificate: %v", err)
                                }</span>
                                <span class="cov0" title="0">appLogger.Info("Self-signed certificate generated",
                                        logger.String("cert", certFile),
                                        logger.String("key", keyFile))</span>
                        }

                        <span class="cov0" title="0">cfg.Server.TLS.CertFile = certFile
                        cfg.Server.TLS.KeyFile = keyFile</span>
                }

                <span class="cov0" title="0">appLogger.Info("Server starting with TLS",
                        logger.String("address", cfg.Address()),
                        logger.String("cert", cfg.Server.TLS.CertFile),
                        logger.String("key", cfg.Server.TLS.KeyFile))</span>
        } else<span class="cov0" title="0"> {
                appLogger.Info("Server starting", logger.String("address", cfg.Address()))
        }</span>

        // Graceful shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                if cfg.Server.TLS.Enabled </span><span class="cov0" title="0">{
                        if err := app.ListenTLS(cfg.Address(), cfg.Server.TLS.CertFile, cfg.Server.TLS.KeyFile); err != nil </span><span class="cov0" title="0">{
                                appLogger.Error("Failed to start TLS server", logger.Error(err))
                                log.Fatalf("Listen TLS error: %v", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := app.Listen(cfg.Address()); err != nil </span><span class="cov0" title="0">{
                                appLogger.Error("Failed to start server", logger.Error(err))
                                log.Fatalf("Listen error: %v", err)
                        }</span>
                }
        }()
        <span class="cov0" title="0">&lt;-quit
        appLogger.Info("Shutting down server...")

        // Shutdown DNS server if running
        if dnsServer != nil </span><span class="cov0" title="0">{
                if err := dnsServer.Stop(); err != nil </span><span class="cov0" title="0">{
                        appLogger.Error("Failed to stop DNS server", logger.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        appLogger.Info("DNS server stopped")
                }</span>
        }

        <span class="cov0" title="0">if err := app.Shutdown(); err != nil </span><span class="cov0" title="0">{
                appLogger.Error("Server forced to shutdown", logger.Error(err))
                log.Fatalf("Server forced to shutdown: %v", err)
        }</span>
        <span class="cov0" title="0">appLogger.Info("Server exited gracefully")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
)

// BackupCommands handles all backup and restore related commands
type BackupCommands struct {
        cli *CLI
}

// NewBackupCommands creates a new backup commands handler
func NewBackupCommands(cli *CLI) *BackupCommands <span class="cov0" title="0">{
        return &amp;BackupCommands{cli: cli}
}</span>

// Handle routes backup subcommands
func (b *BackupCommands) Handle(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                b.cli.Errorln("Backup subcommand required")
                b.cli.Errorln("Usage: konsulctl backup &lt;create|restore|list|export&gt; [options]")
                b.cli.Exit(1)
                return
        }</span>

        <span class="cov0" title="0">subcommand := args[0]
        subArgs := args[1:]

        switch subcommand </span>{
        case "create":<span class="cov0" title="0">
                b.Create(subArgs)</span>
        case "restore":<span class="cov0" title="0">
                b.Restore(subArgs)</span>
        case "list":<span class="cov0" title="0">
                b.List(subArgs)</span>
        case "export":<span class="cov0" title="0">
                b.Export(subArgs)</span>
        default:<span class="cov0" title="0">
                b.cli.Errorf("Unknown backup subcommand: %s\n", subcommand)
                b.cli.Errorln("Available: create, restore, list, export")
                b.cli.Exit(1)</span>
        }
}

// Create creates a new backup
func (b *BackupCommands) Create(args []string) <span class="cov0" title="0">{
        config, remaining, err := b.cli.ParseGlobalFlags(args, "create")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                b.cli.Println("Usage: konsulctl backup create [options]")
                return
        }</span>
        <span class="cov0" title="0">b.cli.HandleError(err, "parsing flags")
        b.cli.ValidateExactArgs(remaining, 0, "Usage: konsulctl backup create")

        client := b.cli.CreateClient(config)

        filename, err := client.CreateBackup()
        b.cli.HandleError(err, "creating backup")

        b.cli.Printf("Successfully created backup: %s\n", filename)</span>
}

// Restore restores from a backup file
func (b *BackupCommands) Restore(args []string) <span class="cov0" title="0">{
        config, remaining, err := b.cli.ParseGlobalFlags(args, "restore")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                b.cli.Println("Usage: konsulctl backup restore &lt;backup-file&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">b.cli.HandleError(err, "parsing flags")
        b.cli.ValidateExactArgs(remaining, 1, "Usage: konsulctl backup restore &lt;backup-file&gt;")

        backupFile := remaining[0]
        client := b.cli.CreateClient(config)

        err = client.RestoreBackup(backupFile)
        b.cli.HandleError(err, "restoring backup")

        b.cli.Printf("Successfully restored from backup: %s\n", backupFile)</span>
}

// List lists all available backups
func (b *BackupCommands) List(args []string) <span class="cov0" title="0">{
        config, remaining, err := b.cli.ParseGlobalFlags(args, "list")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                b.cli.Println("Usage: konsulctl backup list [options]")
                return
        }</span>
        <span class="cov0" title="0">b.cli.HandleError(err, "parsing flags")
        b.cli.ValidateExactArgs(remaining, 0, "Usage: konsulctl backup list")

        client := b.cli.CreateClient(config)

        backups, err := client.ListBackups()
        b.cli.HandleError(err, "listing backups")

        if len(backups) == 0 </span><span class="cov0" title="0">{
                b.cli.Println("No backups found")
                return
        }</span>

        <span class="cov0" title="0">b.cli.Println("Available backups:")
        for _, backup := range backups </span><span class="cov0" title="0">{
                b.cli.Printf("  %s\n", backup)
        }</span>
}

// Export exports all data as JSON
func (b *BackupCommands) Export(args []string) <span class="cov0" title="0">{
        config, remaining, err := b.cli.ParseGlobalFlags(args, "export")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                b.cli.Println("Usage: konsulctl backup export [options]")
                return
        }</span>
        <span class="cov0" title="0">b.cli.HandleError(err, "parsing flags")
        b.cli.ValidateExactArgs(remaining, 0, "Usage: konsulctl backup export")

        client := b.cli.CreateClient(config)

        data, err := client.ExportData()
        b.cli.HandleError(err, "exporting data")

        b.cli.Printf("%s\n", data)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "flag"
        "fmt"
        "io"
        "os"
        "strings"
)

// CLI represents the command-line interface with dependencies
type CLI struct {
        Output io.Writer
        Error  io.Writer
        Exit   func(int)
}

// NewCLI creates a new CLI instance with default dependencies
func NewCLI() *CLI <span class="cov0" title="0">{
        return &amp;CLI{
                Output: os.Stdout,
                Error:  os.Stderr,
                Exit:   os.Exit,
        }
}</span>

// GlobalConfig holds common configuration for all commands
type GlobalConfig struct {
        ServerURL     string
        TLSSkipVerify bool
        TLSCACert     string
        TLSClientCert string
        TLSClientKey  string
}

// ParseGlobalFlags parses common flags and returns GlobalConfig and remaining args
func (cli *CLI) ParseGlobalFlags(args []string, commandName string) (*GlobalConfig, []string, error) <span class="cov0" title="0">{
        config := &amp;GlobalConfig{}

        flagSet := flag.NewFlagSet(commandName, flag.ContinueOnError)
        flagSet.SetOutput(cli.Error)
        flagSet.StringVar(&amp;config.ServerURL, "server", "http://localhost:8888", "Konsul server URL")
        flagSet.BoolVar(&amp;config.TLSSkipVerify, "tls-skip-verify", false, "Skip TLS certificate verification")
        flagSet.StringVar(&amp;config.TLSCACert, "ca-cert", "", "Path to CA certificate file")
        flagSet.StringVar(&amp;config.TLSClientCert, "client-cert", "", "Path to client certificate file")
        flagSet.StringVar(&amp;config.TLSClientKey, "client-key", "", "Path to client key file")

        if len(args) &gt; 0 &amp;&amp; (args[0] == "-h" || args[0] == "--help") </span><span class="cov0" title="0">{
                return nil, nil, flag.ErrHelp
        }</span>

        <span class="cov0" title="0">err := flagSet.Parse(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return config, flagSet.Args(), nil</span>
}

// CreateClient creates a KonsulClient from GlobalConfig
func (cli *CLI) CreateClient(config *GlobalConfig) *KonsulClient <span class="cov0" title="0">{
        tlsConfig := &amp;TLSConfig{
                Enabled:        strings.HasPrefix(config.ServerURL, "https://"),
                SkipVerify:     config.TLSSkipVerify,
                CACertFile:     config.TLSCACert,
                ClientCertFile: config.TLSClientCert,
                ClientKeyFile:  config.TLSClientKey,
        }

        return NewKonsulClientWithTLS(config.ServerURL, tlsConfig)
}</span>

// Printf writes formatted output to the output writer
func (cli *CLI) Printf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintf(cli.Output, format, args...)
}</span>

// Println writes a line to the output writer
func (cli *CLI) Println(args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintln(cli.Output, args...)
}</span>

// Errorf writes formatted error to the error writer
func (cli *CLI) Errorf(format string, args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintf(cli.Error, format, args...)
}</span>

// Errorln writes an error line to the error writer
func (cli *CLI) Errorln(args ...interface{}) <span class="cov0" title="0">{
        fmt.Fprintln(cli.Error, args...)
}</span>

// ExitError prints an error message and exits
func (cli *CLI) ExitError(format string, args ...interface{}) <span class="cov0" title="0">{
        cli.Errorf(format, args...)
        cli.Exit(1)
}</span>

// HandleError checks if error exists, prints it and exits
func (cli *CLI) HandleError(err error, context string) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                cli.ExitError("Error %s: %v\n", context, err)
        }</span>
}

// ValidateArgs checks if the number of arguments is within the expected range
func (cli *CLI) ValidateArgs(args []string, min, max int, usage string) <span class="cov0" title="0">{
        if len(args) &lt; min || len(args) &gt; max </span><span class="cov0" title="0">{
                cli.Errorln(usage)
                cli.Exit(1)
        }</span>
}

// ValidateExactArgs checks if exactly n arguments are provided
func (cli *CLI) ValidateExactArgs(args []string, n int, usage string) <span class="cov0" title="0">{
        cli.ValidateArgs(args, n, n, usage)
}</span>

// ValidateMinArgs checks if at least n arguments are provided
func (cli *CLI) ValidateMinArgs(args []string, n int, usage string) <span class="cov0" title="0">{
        if len(args) &lt; n </span><span class="cov0" title="0">{
                cli.Errorln(usage)
                cli.Exit(1)
        }</span>
}

// ValidateMaxArgs checks if at most n arguments are provided
func (cli *CLI) ValidateMaxArgs(args []string, n int, usage string) <span class="cov0" title="0">{
        if len(args) &gt; n </span><span class="cov0" title="0">{
                cli.Errorln(usage)
                cli.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "bytes"
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"
)

type KonsulClient struct {
        BaseURL    string
        HTTPClient *http.Client
}

// TLSConfig holds TLS configuration for the client
type TLSConfig struct {
        Enabled        bool
        SkipVerify     bool
        CACertFile     string
        ClientCertFile string
        ClientKeyFile  string
}

type KVRequest struct {
        Value string `json:"value"`
}

type KVResponse struct {
        Key   string `json:"key"`
        Value string `json:"value"`
}

type ErrorResponse struct {
        Error     string `json:"error"`
        Message   string `json:"message"`
        RequestID string `json:"request_id,omitempty"`
        Timestamp string `json:"timestamp,omitempty"`
}

type Service struct {
        Name    string `json:"name"`
        Address string `json:"address"`
        Port    int    `json:"port"`
}

type CheckDefinition struct {
        ID            string            `json:"id,omitempty"`
        Name          string            `json:"name"`
        ServiceID     string            `json:"service_id,omitempty"`
        HTTP          string            `json:"http,omitempty"`
        TCP           string            `json:"tcp,omitempty"`
        GRPC          string            `json:"grpc,omitempty"`
        TTL           string            `json:"ttl,omitempty"`
        Interval      string            `json:"interval,omitempty"`
        Timeout       string            `json:"timeout,omitempty"`
        Method        string            `json:"method,omitempty"`
        Headers       map[string]string `json:"headers,omitempty"`
        TLSSkipVerify bool              `json:"tls_skip_verify,omitempty"`
        GRPCUseTLS    bool              `json:"grpc_use_tls,omitempty"`
}

type ServiceRegisterRequest struct {
        Name    string             `json:"name"`
        Address string             `json:"address"`
        Port    int                `json:"port"`
        Checks  []*CheckDefinition `json:"checks,omitempty"`
}

type BackupResponse struct {
        Message    string `json:"message"`
        BackupFile string `json:"backup_file"`
}

type RestoreRequest struct {
        BackupPath string `json:"backup_path"`
}

// Rate limit types
type RateLimitStats struct {
        Success bool                   `json:"success"`
        Data    map[string]interface{} `json:"data"`
}

type RateLimitConfig struct {
        Success bool `json:"success"`
        Config  struct {
                Enabled         bool    `json:"enabled"`
                RequestsPerSec  float64 `json:"requests_per_sec"`
                Burst           int     `json:"burst"`
                ByIP            bool    `json:"by_ip"`
                ByAPIKey        bool    `json:"by_apikey"`
                CleanupInterval string  `json:"cleanup_interval"`
        } `json:"config"`
}

type RateLimitClient struct {
        Identifier string  `json:"identifier"`
        Type       string  `json:"type"`
        Tokens     float64 `json:"tokens"`
        MaxTokens  int     `json:"max_tokens"`
        Rate       float64 `json:"rate"`
        LastUpdate string  `json:"last_update"`
}

type RateLimitClientsResponse struct {
        Success bool               `json:"success"`
        Count   int                `json:"count"`
        Clients []*RateLimitClient `json:"clients"`
}

type RateLimitClientStatus struct {
        Success bool             `json:"success"`
        Client  *RateLimitClient `json:"client"`
}

type RateLimitResetResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        IP      string `json:"ip,omitempty"`
        KeyID   string `json:"key_id,omitempty"`
        Type    string `json:"type,omitempty"`
}

type RateLimitConfigUpdate struct {
        RequestsPerSec *float64 `json:"requests_per_sec,omitempty"`
        Burst          *int     `json:"burst,omitempty"`
}

type RateLimitConfigUpdateResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        Config  struct {
                RequestsPerSec float64 `json:"requests_per_sec"`
                Burst          int     `json:"burst"`
        } `json:"config,omitempty"`
}

func NewKonsulClient(baseURL string) *KonsulClient <span class="cov0" title="0">{
        return NewKonsulClientWithTLS(baseURL, nil)
}</span>

func NewKonsulClientWithTLS(baseURL string, tlsConfig *TLSConfig) *KonsulClient <span class="cov0" title="0">{
        transport := &amp;http.Transport{}

        // Configure TLS if provided
        if tlsConfig != nil &amp;&amp; (tlsConfig.Enabled || strings.HasPrefix(baseURL, "https://")) </span><span class="cov0" title="0">{
                tlsClientConfig := &amp;tls.Config{
                        InsecureSkipVerify: tlsConfig.SkipVerify,
                }

                // Load CA certificate if provided
                if tlsConfig.CACertFile != "" </span><span class="cov0" title="0">{
                        caCert, err := os.ReadFile(tlsConfig.CACertFile)
                        if err == nil </span><span class="cov0" title="0">{
                                caCertPool := x509.NewCertPool()
                                caCertPool.AppendCertsFromPEM(caCert)
                                tlsClientConfig.RootCAs = caCertPool
                        }</span>
                }

                // Load client certificate if provided
                <span class="cov0" title="0">if tlsConfig.ClientCertFile != "" &amp;&amp; tlsConfig.ClientKeyFile != "" </span><span class="cov0" title="0">{
                        cert, err := tls.LoadX509KeyPair(tlsConfig.ClientCertFile, tlsConfig.ClientKeyFile)
                        if err == nil </span><span class="cov0" title="0">{
                                tlsClientConfig.Certificates = []tls.Certificate{cert}
                        }</span>
                }

                <span class="cov0" title="0">transport.TLSClientConfig = tlsClientConfig</span>
        }

        <span class="cov0" title="0">return &amp;KonsulClient{
                BaseURL: strings.TrimRight(baseURL, "/"),
                HTTPClient: &amp;http.Client{
                        Timeout:   30 * time.Second,
                        Transport: transport,
                },
        }</span>
}

func (c *KonsulClient) GetKV(key string) (string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/kv/%s", c.BaseURL, key)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("key not found")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var kvResp KVResponse
        if err := json.Unmarshal(body, &amp;kvResp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return kvResp.Value, nil</span>
}

func (c *KonsulClient) SetKV(key, value string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/kv/%s", c.BaseURL, key)

        reqBody := KVRequest{Value: value}
        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) DeleteKV(key string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/kv/%s", c.BaseURL, key)

        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return fmt.Errorf("key not found")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) ListKV() ([]string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/kv/", c.BaseURL)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var keys []string
        if err := json.Unmarshal(body, &amp;keys); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return keys, nil</span>
}

func (c *KonsulClient) RegisterService(name, address, port string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/register", c.BaseURL)

        // Convert port to int
        portInt := 0
        if _, err := fmt.Sscanf(port, "%d", &amp;portInt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port: %s", port)
        }</span>

        <span class="cov0" title="0">reqBody := ServiceRegisterRequest{
                Name:    name,
                Address: address,
                Port:    portInt,
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) RegisterServiceWithChecks(name, address, port string, checks []*CheckDefinition) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/register", c.BaseURL)

        // Convert port to int
        portInt := 0
        if _, err := fmt.Sscanf(port, "%d", &amp;portInt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port: %s", port)
        }</span>

        <span class="cov0" title="0">reqBody := ServiceRegisterRequest{
                Name:    name,
                Address: address,
                Port:    portInt,
                Checks:  checks,
        }

        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) ListServices() ([]Service, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/services/", c.BaseURL)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var services []Service
        if err := json.Unmarshal(body, &amp;services); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return services, nil</span>
}

func (c *KonsulClient) DeregisterService(name string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/deregister/%s", c.BaseURL, name)

        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return fmt.Errorf("service not found")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) ServiceHeartbeat(name string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/heartbeat/%s", c.BaseURL, name)

        req, err := http.NewRequest("PUT", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return fmt.Errorf("service not found")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) CreateBackup() (string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/backup", c.BaseURL)

        req, err := http.NewRequest("POST", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var backupResp BackupResponse
        if err := json.Unmarshal(body, &amp;backupResp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return backupResp.BackupFile, nil</span>
}

func (c *KonsulClient) RestoreBackup(backupPath string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/restore", c.BaseURL)

        reqBody := RestoreRequest{BackupPath: backupPath}
        jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) ListBackups() ([]string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/backups", c.BaseURL)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var backups []string
        if err := json.Unmarshal(body, &amp;backups); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return backups, nil</span>
}

func (c *KonsulClient) ExportData() (string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/export", c.BaseURL)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return string(body), nil</span>
}

// Rate limit admin methods

func (c *KonsulClient) GetRateLimitStats() (*RateLimitStats, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/stats", c.BaseURL)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var stats RateLimitStats
        if err := json.Unmarshal(body, &amp;stats); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

func (c *KonsulClient) GetRateLimitConfig() (*RateLimitConfig, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/config", c.BaseURL)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var config RateLimitConfig
        if err := json.Unmarshal(body, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (c *KonsulClient) GetRateLimitClients(limiterType string) (*RateLimitClientsResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/clients?type=%s", c.BaseURL, limiterType)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var clients RateLimitClientsResponse
        if err := json.Unmarshal(body, &amp;clients); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;clients, nil</span>
}

func (c *KonsulClient) GetRateLimitClientStatus(identifier string) (*RateLimitClient, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/client/%s", c.BaseURL, identifier)

        resp, err := c.HTTPClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client not found")
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var status RateLimitClientStatus
        if err := json.Unmarshal(body, &amp;status); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return status.Client, nil</span>
}

func (c *KonsulClient) ResetRateLimitIP(ip string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/reset/ip/%s", c.BaseURL, ip)

        req, err := http.NewRequest("POST", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) ResetRateLimitAPIKey(keyID string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/reset/apikey/%s", c.BaseURL, keyID)

        req, err := http.NewRequest("POST", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) ResetRateLimitAll(limiterType string) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/reset/all?type=%s", c.BaseURL, limiterType)

        req, err := http.NewRequest("POST", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *KonsulClient) UpdateRateLimitConfig(requestsPerSec *float64, burst *int) (*RateLimitConfigUpdateResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/admin/ratelimit/config", c.BaseURL)

        update := RateLimitConfigUpdate{
                RequestsPerSec: requestsPerSec,
                Burst:          burst,
        }

        jsonData, err := json.Marshal(update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("PUT", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server error: %s - %s", errResp.Error, errResp.Message)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">var updateResp RateLimitConfigUpdateResponse
        if err := json.Unmarshal(body, &amp;updateResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;updateResp, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "flag"
)

// DNSCommands handles all DNS query related commands
type DNSCommands struct {
        cli *CLI
}

// NewDNSCommands creates a new DNS commands handler
func NewDNSCommands(cli *CLI) *DNSCommands <span class="cov0" title="0">{
        return &amp;DNSCommands{cli: cli}
}</span>

// Handle routes DNS subcommands
func (d *DNSCommands) Handle(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                d.cli.Errorln("DNS subcommand required")
                d.cli.Errorln("Usage: konsulctl dns &lt;query&gt; &lt;service-name&gt; [options]")
                d.cli.Errorln("  query: 'srv' or 'a' (record type)")
                d.cli.Exit(1)
                return
        }</span>

        <span class="cov0" title="0">if len(args) &lt; 2 </span><span class="cov0" title="0">{
                d.cli.Errorln("Service name required")
                d.cli.Exit(1)
                return
        }</span>

        <span class="cov0" title="0">queryType := args[0]
        serviceName := args[1]
        queryArgs := args[2:]

        switch queryType </span>{
        case "srv":<span class="cov0" title="0">
                d.SRV(serviceName, queryArgs)</span>
        case "a":<span class="cov0" title="0">
                d.A(serviceName, queryArgs)</span>
        default:<span class="cov0" title="0">
                d.cli.Errorf("Unknown DNS query type: %s\n", queryType)
                d.cli.Errorln("Supported types: srv, a")
                d.cli.Exit(1)</span>
        }
}

// SRV shows SRV record query for a service
func (d *DNSCommands) SRV(serviceName string, args []string) <span class="cov0" title="0">{
        var dnsServer string
        var dnsPort int

        flagSet := flag.NewFlagSet("srv", flag.ContinueOnError)
        flagSet.SetOutput(d.cli.Error)
        flagSet.StringVar(&amp;dnsServer, "server", "localhost", "DNS server address")
        flagSet.IntVar(&amp;dnsPort, "port", 8600, "DNS server port")

        err := flagSet.Parse(args)
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                d.cli.Println("Usage: konsulctl dns srv &lt;service-name&gt; [--server &lt;addr&gt;] [--port &lt;port&gt;]")
                return
        }</span>
        <span class="cov0" title="0">d.cli.HandleError(err, "parsing flags")

        d.cli.Printf("DNS SRV query for service '%s' (server: %s:%d)\n", serviceName, dnsServer, dnsPort)
        d.cli.Printf("SRV Record: _%s._tcp.service.consul\n", serviceName)
        d.cli.Printf("Run: dig @%s -p %d _%s._tcp.service.consul SRV\n", dnsServer, dnsPort, serviceName)</span>
}

// A shows A record query for a service
func (d *DNSCommands) A(serviceName string, args []string) <span class="cov0" title="0">{
        var dnsServer string
        var dnsPort int

        flagSet := flag.NewFlagSet("a", flag.ContinueOnError)
        flagSet.SetOutput(d.cli.Error)
        flagSet.StringVar(&amp;dnsServer, "server", "localhost", "DNS server address")
        flagSet.IntVar(&amp;dnsPort, "port", 8600, "DNS server port")

        err := flagSet.Parse(args)
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                d.cli.Println("Usage: konsulctl dns a &lt;service-name&gt; [--server &lt;addr&gt;] [--port &lt;port&gt;]")
                return
        }</span>
        <span class="cov0" title="0">d.cli.HandleError(err, "parsing flags")

        d.cli.Printf("DNS A query for service '%s' (server: %s:%d)\n", serviceName, dnsServer, dnsPort)
        d.cli.Printf("A Record: %s.service.consul\n", serviceName)
        d.cli.Printf("Run: dig @%s -p %d %s.service.consul A\n", dnsServer, dnsPort, serviceName)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "flag"
)

// KVCommands handles all KV store related commands
type KVCommands struct {
        cli *CLI
}

// NewKVCommands creates a new KV commands handler
func NewKVCommands(cli *CLI) *KVCommands <span class="cov0" title="0">{
        return &amp;KVCommands{cli: cli}
}</span>

// Handle routes KV subcommands
func (k *KVCommands) Handle(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                k.cli.Errorln("KV subcommand required")
                k.cli.Errorln("Usage: konsulctl kv &lt;get|set|delete|list&gt; [options]")
                k.cli.Exit(1)
                return
        }</span>

        <span class="cov0" title="0">subcommand := args[0]
        subArgs := args[1:]

        switch subcommand </span>{
        case "get":<span class="cov0" title="0">
                k.Get(subArgs)</span>
        case "set":<span class="cov0" title="0">
                k.Set(subArgs)</span>
        case "delete":<span class="cov0" title="0">
                k.Delete(subArgs)</span>
        case "list":<span class="cov0" title="0">
                k.List(subArgs)</span>
        default:<span class="cov0" title="0">
                k.cli.Errorf("Unknown KV subcommand: %s\n", subcommand)
                k.cli.Errorln("Available: get, set, delete, list")
                k.cli.Exit(1)</span>
        }
}

// Get retrieves a value by key
func (k *KVCommands) Get(args []string) <span class="cov0" title="0">{
        config, remaining, err := k.cli.ParseGlobalFlags(args, "get")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                k.cli.Println("Usage: konsulctl kv get &lt;key&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">k.cli.HandleError(err, "parsing flags")
        k.cli.ValidateExactArgs(remaining, 1, "Usage: konsulctl kv get &lt;key&gt;")

        key := remaining[0]
        client := k.cli.CreateClient(config)

        value, err := client.GetKV(key)
        k.cli.HandleError(err, "getting key '"+key+"'")

        k.cli.Printf("%s\n", value)</span>
}

// Set sets a key-value pair
func (k *KVCommands) Set(args []string) <span class="cov0" title="0">{
        config, remaining, err := k.cli.ParseGlobalFlags(args, "set")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                k.cli.Println("Usage: konsulctl kv set &lt;key&gt; &lt;value&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">k.cli.HandleError(err, "parsing flags")
        k.cli.ValidateExactArgs(remaining, 2, "Usage: konsulctl kv set &lt;key&gt; &lt;value&gt;")

        key := remaining[0]
        value := remaining[1]
        client := k.cli.CreateClient(config)

        err = client.SetKV(key, value)
        k.cli.HandleError(err, "setting key '"+key+"'")

        k.cli.Printf("Successfully set %s = %s\n", key, value)</span>
}

// Delete deletes a key
func (k *KVCommands) Delete(args []string) <span class="cov0" title="0">{
        config, remaining, err := k.cli.ParseGlobalFlags(args, "delete")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                k.cli.Println("Usage: konsulctl kv delete &lt;key&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">k.cli.HandleError(err, "parsing flags")
        k.cli.ValidateExactArgs(remaining, 1, "Usage: konsulctl kv delete &lt;key&gt;")

        key := remaining[0]
        client := k.cli.CreateClient(config)

        err = client.DeleteKV(key)
        k.cli.HandleError(err, "deleting key '"+key+"'")

        k.cli.Printf("Successfully deleted key: %s\n", key)</span>
}

// List lists all keys
func (k *KVCommands) List(args []string) <span class="cov0" title="0">{
        config, remaining, err := k.cli.ParseGlobalFlags(args, "list")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                k.cli.Println("Usage: konsulctl kv list [options]")
                return
        }</span>
        <span class="cov0" title="0">k.cli.HandleError(err, "parsing flags")
        k.cli.ValidateExactArgs(remaining, 0, "Usage: konsulctl kv list")

        client := k.cli.CreateClient(config)

        keys, err := client.ListKV()
        k.cli.HandleError(err, "listing keys")

        if len(keys) == 0 </span><span class="cov0" title="0">{
                k.cli.Println("No keys found")
                return
        }</span>

        <span class="cov0" title="0">k.cli.Println("Keys:")
        for _, key := range keys </span><span class="cov0" title="0">{
                k.cli.Printf("  %s\n", key)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "os"
)

const version = "1.0.0"

func main() <span class="cov0" title="0">{
        cli := NewCLI()

        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                cli.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]
        args := os.Args[2:]

        switch command </span>{
        case "kv":<span class="cov0" title="0">
                kvCmd := NewKVCommands(cli)
                kvCmd.Handle(args)</span>
        case "service":<span class="cov0" title="0">
                serviceCmd := NewServiceCommands(cli)
                serviceCmd.Handle(args)</span>
        case "backup":<span class="cov0" title="0">
                backupCmd := NewBackupCommands(cli)
                backupCmd.Handle(args)</span>
        case "dns":<span class="cov0" title="0">
                dnsCmd := NewDNSCommands(cli)
                dnsCmd.Handle(args)</span>
        case "ratelimit":<span class="cov0" title="0">
                rateLimitCmd := NewRateLimitCommands(cli)
                rateLimitCmd.Handle(args)</span>
        case "version":<span class="cov0" title="0">
                cli.Printf("konsulctl version %s\n", version)</span>
        case "help", "-h", "--help":<span class="cov0" title="0">
                printUsage()</span>
        default:<span class="cov0" title="0">
                cli.Printf("Unknown command: %s\n", command)
                printUsage()
                cli.Exit(1)</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Println("konsulctl - Konsul CLI Tool")
        fmt.Println()
        fmt.Println("Usage: konsulctl &lt;command&gt; [options]")
        fmt.Println()
        fmt.Println("Commands:")
        fmt.Println("  kv &lt;subcommand&gt;    Key-value operations")
        fmt.Println("    get &lt;key&gt;        Get value by key")
        fmt.Println("    set &lt;key&gt; &lt;value&gt;  Set key-value pair")
        fmt.Println("    delete &lt;key&gt;     Delete key")
        fmt.Println("    list             List all keys")
        fmt.Println()
        fmt.Println("  service &lt;subcommand&gt;  Service operations")
        fmt.Println("    register &lt;name&gt; &lt;address&gt; &lt;port&gt;  Register service")
        fmt.Println("    list             List all services")
        fmt.Println("    deregister &lt;name&gt;  Deregister service")
        fmt.Println("    heartbeat &lt;name&gt;   Send heartbeat for service")
        fmt.Println()
        fmt.Println("  backup &lt;subcommand&gt;   Backup operations")
        fmt.Println("    create           Create a backup")
        fmt.Println("    restore &lt;file&gt;   Restore from backup file")
        fmt.Println("    list             List available backups")
        fmt.Println("    export           Export data as JSON")
        fmt.Println()
        fmt.Println("  dns &lt;query&gt; &lt;service&gt;     DNS operations")
        fmt.Println("    srv &lt;service&gt;    Show SRV record query for service")
        fmt.Println("    a &lt;service&gt;      Show A record query for service")
        fmt.Println()
        fmt.Println("  ratelimit &lt;subcommand&gt;    Rate limit operations")
        fmt.Println("    stats            Show rate limit statistics")
        fmt.Println("    config           Show rate limit configuration")
        fmt.Println("    clients [--type &lt;type&gt;]  List active rate-limited clients")
        fmt.Println("    client &lt;id&gt;      Show specific client status")
        fmt.Println("    reset ip &lt;ip&gt;    Reset rate limit for IP")
        fmt.Println("    reset apikey &lt;key&gt;  Reset rate limit for API key")
        fmt.Println("    reset all [--type &lt;type&gt;]  Reset all rate limiters")
        fmt.Println("    update &lt;--rate &lt;n&gt; | --burst &lt;n&gt;&gt;  Update configuration")
        fmt.Println()
        fmt.Println("  version            Show version")
        fmt.Println("  help               Show this help")
        fmt.Println()
        fmt.Println("Global Options:")
        fmt.Println("  --server &lt;url&gt;     Konsul server URL (default: http://localhost:8888)")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "flag"
)

// RateLimitCommands handles all rate limit related commands
type RateLimitCommands struct {
        cli *CLI
}

// NewRateLimitCommands creates a new rate limit commands handler
func NewRateLimitCommands(cli *CLI) *RateLimitCommands <span class="cov0" title="0">{
        return &amp;RateLimitCommands{cli: cli}
}</span>

// Handle routes rate limit subcommands
func (r *RateLimitCommands) Handle(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                r.cli.Errorln("Rate limit subcommand required")
                r.cli.Errorln("Usage: konsulctl ratelimit &lt;stats|config|clients|client|reset|update&gt; [options]")
                r.cli.Exit(1)
                return
        }</span>

        <span class="cov0" title="0">subcommand := args[0]
        subArgs := args[1:]

        switch subcommand </span>{
        case "stats":<span class="cov0" title="0">
                r.Stats(subArgs)</span>
        case "config":<span class="cov0" title="0">
                r.Config(subArgs)</span>
        case "clients":<span class="cov0" title="0">
                r.Clients(subArgs)</span>
        case "client":<span class="cov0" title="0">
                r.ClientStatus(subArgs)</span>
        case "reset":<span class="cov0" title="0">
                r.Reset(subArgs)</span>
        case "update":<span class="cov0" title="0">
                r.Update(subArgs)</span>
        default:<span class="cov0" title="0">
                r.cli.Errorf("Unknown rate limit subcommand: %s\n", subcommand)
                r.cli.Errorln("Available: stats, config, clients, client, reset, update")
                r.cli.Exit(1)</span>
        }
}

// Stats shows rate limit statistics
func (r *RateLimitCommands) Stats(args []string) <span class="cov0" title="0">{
        config, remaining, err := r.cli.ParseGlobalFlags(args, "stats")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                r.cli.Println("Usage: konsulctl ratelimit stats [options]")
                return
        }</span>
        <span class="cov0" title="0">r.cli.HandleError(err, "parsing flags")
        r.cli.ValidateExactArgs(remaining, 0, "Usage: konsulctl ratelimit stats")

        client := r.cli.CreateClient(config)
        stats, err := client.GetRateLimitStats()
        r.cli.HandleError(err, "getting rate limit stats")

        r.cli.Println("Rate Limit Statistics:")
        r.cli.Printf("  IP Limiters: %v\n", stats.Data["ip_limiters"])
        r.cli.Printf("  API Key Limiters: %v\n", stats.Data["apikey_limiters"])</span>
}

// Config shows rate limit configuration
func (r *RateLimitCommands) Config(args []string) <span class="cov0" title="0">{
        config, remaining, err := r.cli.ParseGlobalFlags(args, "config")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                r.cli.Println("Usage: konsulctl ratelimit config [options]")
                return
        }</span>
        <span class="cov0" title="0">r.cli.HandleError(err, "parsing flags")
        r.cli.ValidateExactArgs(remaining, 0, "Usage: konsulctl ratelimit config")

        client := r.cli.CreateClient(config)
        rlConfig, err := client.GetRateLimitConfig()
        r.cli.HandleError(err, "getting rate limit config")

        r.cli.Println("Rate Limit Configuration:")
        r.cli.Printf("  Enabled: %t\n", rlConfig.Config.Enabled)
        r.cli.Printf("  Requests per second: %.1f\n", rlConfig.Config.RequestsPerSec)
        r.cli.Printf("  Burst: %d\n", rlConfig.Config.Burst)
        r.cli.Printf("  By IP: %t\n", rlConfig.Config.ByIP)
        r.cli.Printf("  By API Key: %t\n", rlConfig.Config.ByAPIKey)
        r.cli.Printf("  Cleanup interval: %s\n", rlConfig.Config.CleanupInterval)</span>
}

// Clients lists active rate-limited clients
func (r *RateLimitCommands) Clients(args []string) <span class="cov0" title="0">{
        var clientType string
        flagSet := flag.NewFlagSet("clients", flag.ContinueOnError)
        flagSet.SetOutput(r.cli.Error)
        flagSet.StringVar(&amp;clientType, "type", "all", "Client type: all, ip, or apikey")

        config, remaining, err := r.cli.ParseGlobalFlags(args, "clients")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                r.cli.Println("Usage: konsulctl ratelimit clients [--type &lt;type&gt;] [options]")
                return
        }</span>
        <span class="cov0" title="0">r.cli.HandleError(err, "parsing flags")

        err = flagSet.Parse(remaining)
        r.cli.HandleError(err, "parsing client flags")

        client := r.cli.CreateClient(config)
        clients, err := client.GetRateLimitClients(clientType)
        r.cli.HandleError(err, "getting rate limit clients")

        if clients.Count == 0 </span><span class="cov0" title="0">{
                r.cli.Println("No active rate-limited clients")
                return
        }</span>

        <span class="cov0" title="0">r.cli.Printf("Active Rate-Limited Clients (%d):\n", clients.Count)
        r.cli.Println()
        for _, c := range clients.Clients </span><span class="cov0" title="0">{
                r.cli.Printf("  Identifier: %s\n", c.Identifier)
                r.cli.Printf("  Type: %s\n", c.Type)
                r.cli.Printf("  Tokens: %.2f / %d\n", c.Tokens, c.MaxTokens)
                r.cli.Printf("  Rate: %.1f req/s\n", c.Rate)
                r.cli.Printf("  Last update: %s\n", c.LastUpdate)
                r.cli.Println()
        }</span>
}

// ClientStatus shows status for a specific client
func (r *RateLimitCommands) ClientStatus(args []string) <span class="cov0" title="0">{
        config, remaining, err := r.cli.ParseGlobalFlags(args, "client")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                r.cli.Println("Usage: konsulctl ratelimit client &lt;identifier&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">r.cli.HandleError(err, "parsing flags")
        r.cli.ValidateExactArgs(remaining, 1, "Usage: konsulctl ratelimit client &lt;identifier&gt;")

        identifier := remaining[0]
        client := r.cli.CreateClient(config)
        status, err := client.GetRateLimitClientStatus(identifier)
        r.cli.HandleError(err, "getting client status")

        r.cli.Printf("Client Status: %s\n", status.Identifier)
        r.cli.Printf("  Type: %s\n", status.Type)
        r.cli.Printf("  Tokens: %.2f / %d\n", status.Tokens, status.MaxTokens)
        r.cli.Printf("  Rate: %.1f req/s\n", status.Rate)
        r.cli.Printf("  Last update: %s\n", status.LastUpdate)

        // Show percentage
        percentage := (status.Tokens / float64(status.MaxTokens)) * 100
        r.cli.Printf("  Capacity: %.1f%%\n", percentage)</span>
}

// Reset handles rate limit reset operations
func (r *RateLimitCommands) Reset(args []string) <span class="cov0" title="0">{
        config, remaining, err := r.cli.ParseGlobalFlags(args, "reset")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                r.cli.Println("Usage: konsulctl ratelimit reset &lt;ip|apikey|all&gt; &lt;value&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">r.cli.HandleError(err, "parsing flags")
        r.cli.ValidateMinArgs(remaining, 1, "Usage: konsulctl ratelimit reset &lt;ip|apikey|all&gt; &lt;value&gt;")

        resetType := remaining[0]
        client := r.cli.CreateClient(config)

        switch resetType </span>{
        case "ip":<span class="cov0" title="0">
                r.cli.ValidateExactArgs(remaining, 2, "Usage: konsulctl ratelimit reset ip &lt;ip-address&gt;")
                ip := remaining[1]
                err := client.ResetRateLimitIP(ip)
                r.cli.HandleError(err, "resetting rate limit for IP")
                r.cli.Printf("Successfully reset rate limit for IP: %s\n", ip)</span>

        case "apikey":<span class="cov0" title="0">
                r.cli.ValidateExactArgs(remaining, 2, "Usage: konsulctl ratelimit reset apikey &lt;key-id&gt;")
                keyID := remaining[1]
                err := client.ResetRateLimitAPIKey(keyID)
                r.cli.HandleError(err, "resetting rate limit for API key")
                r.cli.Printf("Successfully reset rate limit for API key: %s\n", keyID)</span>

        case "all":<span class="cov0" title="0">
                var limiterType string
                flagSet := flag.NewFlagSet("reset-all", flag.ContinueOnError)
                flagSet.SetOutput(r.cli.Error)
                flagSet.StringVar(&amp;limiterType, "type", "all", "Limiter type: all, ip, or apikey")
                err := flagSet.Parse(remaining[1:])
                r.cli.HandleError(err, "parsing reset flags")

                err = client.ResetRateLimitAll(limiterType)
                r.cli.HandleError(err, "resetting rate limiters")
                r.cli.Printf("Successfully reset all %s rate limiters\n", limiterType)</span>

        default:<span class="cov0" title="0">
                r.cli.Errorf("Unknown reset type: %s\n", resetType)
                r.cli.Errorln("Available: ip, apikey, all")
                r.cli.Exit(1)</span>
        }
}

// Update updates rate limit configuration
func (r *RateLimitCommands) Update(args []string) <span class="cov0" title="0">{
        var rate float64
        var burst int

        flagSet := flag.NewFlagSet("update", flag.ContinueOnError)
        flagSet.SetOutput(r.cli.Error)
        flagSet.Float64Var(&amp;rate, "rate", 0, "Requests per second")
        flagSet.IntVar(&amp;burst, "burst", 0, "Burst size")

        config, remaining, err := r.cli.ParseGlobalFlags(args, "update")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                r.cli.Println("Usage: konsulctl ratelimit update --rate &lt;n&gt; --burst &lt;n&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">r.cli.HandleError(err, "parsing flags")

        err = flagSet.Parse(remaining)
        r.cli.HandleError(err, "parsing update flags")

        if rate == 0 &amp;&amp; burst == 0 </span><span class="cov0" title="0">{
                r.cli.Errorln("Usage: konsulctl ratelimit update --rate &lt;n&gt; --burst &lt;n&gt;")
                r.cli.Errorln("  At least one of --rate or --burst must be specified")
                r.cli.Exit(1)
                return
        }</span>

        <span class="cov0" title="0">client := r.cli.CreateClient(config)

        var ratePtr *float64
        var burstPtr *int
        if rate &gt; 0 </span><span class="cov0" title="0">{
                ratePtr = &amp;rate
        }</span>
        <span class="cov0" title="0">if burst &gt; 0 </span><span class="cov0" title="0">{
                burstPtr = &amp;burst
        }</span>

        <span class="cov0" title="0">resp, err := client.UpdateRateLimitConfig(ratePtr, burstPtr)
        r.cli.HandleError(err, "updating rate limit config")

        r.cli.Printf("%s\n", resp.Message)
        if resp.Config.RequestsPerSec &gt; 0 || resp.Config.Burst &gt; 0 </span><span class="cov0" title="0">{
                r.cli.Println("Updated configuration:")
                if resp.Config.RequestsPerSec &gt; 0 </span><span class="cov0" title="0">{
                        r.cli.Printf("  Requests per second: %.1f\n", resp.Config.RequestsPerSec)
                }</span>
                <span class="cov0" title="0">if resp.Config.Burst &gt; 0 </span><span class="cov0" title="0">{
                        r.cli.Printf("  Burst: %d\n", resp.Config.Burst)
                }</span>
                <span class="cov0" title="0">r.cli.Println()
                r.cli.Println("Note: Changes apply to new limiters only.")
                r.cli.Println("To apply to existing clients, run: konsulctl ratelimit reset all")</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "flag"
        "fmt"
)

// ServiceCommands handles all service discovery related commands
type ServiceCommands struct {
        cli *CLI
}

// NewServiceCommands creates a new service commands handler
func NewServiceCommands(cli *CLI) *ServiceCommands <span class="cov0" title="0">{
        return &amp;ServiceCommands{cli: cli}
}</span>

// Handle routes service subcommands
func (s *ServiceCommands) Handle(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                s.cli.Errorln("Service subcommand required")
                s.cli.Errorln("Usage: konsulctl service &lt;register|list|deregister|heartbeat&gt; [options]")
                s.cli.Exit(1)
                return
        }</span>

        <span class="cov0" title="0">subcommand := args[0]
        subArgs := args[1:]

        switch subcommand </span>{
        case "register":<span class="cov0" title="0">
                s.Register(subArgs)</span>
        case "list":<span class="cov0" title="0">
                s.List(subArgs)</span>
        case "deregister":<span class="cov0" title="0">
                s.Deregister(subArgs)</span>
        case "heartbeat":<span class="cov0" title="0">
                s.Heartbeat(subArgs)</span>
        default:<span class="cov0" title="0">
                s.cli.Errorf("Unknown service subcommand: %s\n", subcommand)
                s.cli.Errorln("Available: register, list, deregister, heartbeat")
                s.cli.Exit(1)</span>
        }
}

// Register registers a new service
func (s *ServiceCommands) Register(args []string) <span class="cov0" title="0">{
        config, remaining, err := s.cli.ParseGlobalFlags(args, "register")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                s.cli.Println("Usage: konsulctl service register &lt;name&gt; &lt;address&gt; &lt;port&gt; [--check-http &lt;url&gt;] [--check-tcp &lt;addr&gt;] [--check-ttl &lt;duration&gt;] [options]")
                return
        }</span>
        <span class="cov0" title="0">s.cli.HandleError(err, "parsing flags")
        s.cli.ValidateMinArgs(remaining, 3, "Usage: konsulctl service register &lt;name&gt; &lt;address&gt; &lt;port&gt; [--check-http &lt;url&gt;] [--check-tcp &lt;addr&gt;] [--check-ttl &lt;duration&gt;]")

        name := remaining[0]
        address := remaining[1]
        port := remaining[2]

        // Parse health check flags
        checks, err := s.parseHealthChecks(name, remaining[3:])
        s.cli.HandleError(err, "parsing health checks")

        client := s.cli.CreateClient(config)
        err = client.RegisterServiceWithChecks(name, address, port, checks)
        s.cli.HandleError(err, "registering service '"+name+"'")

        checkInfo := ""
        if len(checks) &gt; 0 </span><span class="cov0" title="0">{
                checkInfo = fmt.Sprintf(" with %d health check(s)", len(checks))
        }</span>

        <span class="cov0" title="0">s.cli.Printf("Successfully registered service: %s at %s:%s%s\n", name, address, port, checkInfo)</span>
}

// parseHealthChecks parses health check flags from arguments
func (s *ServiceCommands) parseHealthChecks(serviceName string, args []string) ([]*CheckDefinition, error) <span class="cov0" title="0">{
        var checks []*CheckDefinition

        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                switch args[i] </span>{
                case "--check-http":<span class="cov0" title="0">
                        if i+1 &gt;= len(args) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("--check-http requires a URL")
                        }</span>
                        <span class="cov0" title="0">checks = append(checks, &amp;CheckDefinition{
                                Name:     fmt.Sprintf("%s-http-check", serviceName),
                                HTTP:     args[i+1],
                                Interval: "30s",
                                Timeout:  "10s",
                        })
                        i++</span> // Skip the URL argument

                case "--check-tcp":<span class="cov0" title="0">
                        if i+1 &gt;= len(args) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("--check-tcp requires an address")
                        }</span>
                        <span class="cov0" title="0">checks = append(checks, &amp;CheckDefinition{
                                Name:     fmt.Sprintf("%s-tcp-check", serviceName),
                                TCP:      args[i+1],
                                Interval: "30s",
                                Timeout:  "10s",
                        })
                        i++</span> // Skip the address argument

                case "--check-ttl":<span class="cov0" title="0">
                        if i+1 &gt;= len(args) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("--check-ttl requires a duration")
                        }</span>
                        <span class="cov0" title="0">checks = append(checks, &amp;CheckDefinition{
                                Name: fmt.Sprintf("%s-ttl-check", serviceName),
                                TTL:  args[i+1],
                        })
                        i++</span> // Skip the duration argument

                default:<span class="cov0" title="0">
                        // Ignore unknown flags (might be global flags already parsed)
                        if args[i][0] == '-' </span><span class="cov0" title="0">{
                                // Skip flag and its potential value
                                if i+1 &lt; len(args) &amp;&amp; args[i+1][0] != '-' </span><span class="cov0" title="0">{
                                        i++
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return checks, nil</span>
}

// List lists all registered services
func (s *ServiceCommands) List(args []string) <span class="cov0" title="0">{
        config, remaining, err := s.cli.ParseGlobalFlags(args, "list")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                s.cli.Println("Usage: konsulctl service list [options]")
                return
        }</span>
        <span class="cov0" title="0">s.cli.HandleError(err, "parsing flags")
        s.cli.ValidateExactArgs(remaining, 0, "Usage: konsulctl service list")

        client := s.cli.CreateClient(config)

        services, err := client.ListServices()
        s.cli.HandleError(err, "listing services")

        if len(services) == 0 </span><span class="cov0" title="0">{
                s.cli.Println("No services found")
                return
        }</span>

        <span class="cov0" title="0">s.cli.Println("Services:")
        for _, service := range services </span><span class="cov0" title="0">{
                s.cli.Printf("  %s - %s:%d\n", service.Name, service.Address, service.Port)
        }</span>
}

// Deregister removes a service registration
func (s *ServiceCommands) Deregister(args []string) <span class="cov0" title="0">{
        config, remaining, err := s.cli.ParseGlobalFlags(args, "deregister")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                s.cli.Println("Usage: konsulctl service deregister &lt;name&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">s.cli.HandleError(err, "parsing flags")
        s.cli.ValidateExactArgs(remaining, 1, "Usage: konsulctl service deregister &lt;name&gt;")

        name := remaining[0]
        client := s.cli.CreateClient(config)

        err = client.DeregisterService(name)
        s.cli.HandleError(err, "deregistering service '"+name+"'")

        s.cli.Printf("Successfully deregistered service: %s\n", name)</span>
}

// Heartbeat sends a heartbeat for a service
func (s *ServiceCommands) Heartbeat(args []string) <span class="cov0" title="0">{
        config, remaining, err := s.cli.ParseGlobalFlags(args, "heartbeat")
        if err == flag.ErrHelp </span><span class="cov0" title="0">{
                s.cli.Println("Usage: konsulctl service heartbeat &lt;name&gt; [options]")
                return
        }</span>
        <span class="cov0" title="0">s.cli.HandleError(err, "parsing flags")
        s.cli.ValidateExactArgs(remaining, 1, "Usage: konsulctl service heartbeat &lt;name&gt;")

        name := remaining[0]
        client := s.cli.CreateClient(config)

        err = client.ServiceHeartbeat(name)
        s.cli.HandleError(err, "sending heartbeat for service '"+name+"'")

        s.cli.Printf("Successfully sent heartbeat for service: %s\n", name)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package acl

import (
        "sync"
        "time"

        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/metrics"
)

// Evaluator evaluates ACL policies for authorization
type Evaluator struct {
        policies map[string]*Policy
        mu       sync.RWMutex
        log      logger.Logger
}

// NewEvaluator creates a new ACL evaluator
func NewEvaluator(log logger.Logger) *Evaluator <span class="cov5" title="5">{
        return &amp;Evaluator{
                policies: make(map[string]*Policy),
                log:      log,
        }
}</span>

// AddPolicy adds a policy to the evaluator
func (e *Evaluator) AddPolicy(policy *Policy) error <span class="cov6" title="6">{
        if err := policy.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="6">e.mu.Lock()
        defer e.mu.Unlock()

        if _, exists := e.policies[policy.Name]; exists </span><span class="cov1" title="1">{
                return ErrPolicyExists
        }</span>

        <span class="cov5" title="5">e.policies[policy.Name] = policy
        e.log.Info("ACL policy added", logger.String("policy", policy.Name))
        return nil</span>
}

// UpdatePolicy updates an existing policy
func (e *Evaluator) UpdatePolicy(policy *Policy) error <span class="cov1" title="1">{
        if err := policy.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">e.mu.Lock()
        defer e.mu.Unlock()

        if _, exists := e.policies[policy.Name]; !exists </span><span class="cov0" title="0">{
                return ErrPolicyNotFound
        }</span>

        <span class="cov1" title="1">e.policies[policy.Name] = policy
        e.log.Info("ACL policy updated", logger.String("policy", policy.Name))
        return nil</span>
}

// DeletePolicy removes a policy
func (e *Evaluator) DeletePolicy(name string) error <span class="cov1" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if _, exists := e.policies[name]; !exists </span><span class="cov0" title="0">{
                return ErrPolicyNotFound
        }</span>

        <span class="cov1" title="1">delete(e.policies, name)
        e.log.Info("ACL policy deleted", logger.String("policy", name))
        return nil</span>
}

// GetPolicy retrieves a policy by name
func (e *Evaluator) GetPolicy(name string) (*Policy, error) <span class="cov3" title="2">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        policy, exists := e.policies[name]
        if !exists </span><span class="cov1" title="1">{
                return nil, ErrPolicyNotFound
        }</span>

        <span class="cov1" title="1">return policy, nil</span>
}

// ListPolicies returns all policy names
func (e *Evaluator) ListPolicies() []string <span class="cov1" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        names := make([]string, 0, len(e.policies))
        for name := range e.policies </span><span class="cov1" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov1" title="1">return names</span>
}

// Evaluate checks if the given policies allow the specified capability on a resource
// Returns true if access is allowed, false if denied
func (e *Evaluator) Evaluate(policyNames []string, resource Resource, capability Capability) bool <span class="cov9" title="17">{
        start := time.Now()
        e.mu.RLock()
        defer e.mu.RUnlock()

        var allowed bool
        defer func() </span><span class="cov9" title="17">{
                // Record metrics
                duration := time.Since(start).Seconds()
                result := "deny"
                if allowed </span><span class="cov7" title="9">{
                        result = "allow"
                }</span>
                <span class="cov9" title="17">metrics.ACLEvaluationsTotal.WithLabelValues(string(resource.Type), string(capability), result).Inc()
                metrics.ACLEvaluationDuration.WithLabelValues(string(resource.Type)).Observe(duration)</span>
        }()

        <span class="cov9" title="17">if len(policyNames) == 0 </span><span class="cov1" title="1">{
                e.log.Debug("No policies provided - denying by default")
                return false
        }</span>

        // Collect all applicable policies
        <span class="cov9" title="16">policies := make([]*Policy, 0, len(policyNames))
        for _, name := range policyNames </span><span class="cov9" title="18">{
                if policy, exists := e.policies[name]; exists </span><span class="cov9" title="17">{
                        policies = append(policies, policy)
                }</span> else<span class="cov1" title="1"> {
                        e.log.Warn("Policy not found", logger.String("policy", name))
                }</span>
        }

        <span class="cov9" title="16">if len(policies) == 0 </span><span class="cov1" title="1">{
                e.log.Debug("No valid policies found - denying by default")
                return false
        }</span>

        // Evaluate policies based on resource type
        <span class="cov9" title="15">switch resource.Type </span>{
        case ResourceTypeKV:<span class="cov7" title="10">
                allowed = e.evaluateKV(policies, resource.Path, capability)</span>
        case ResourceTypeService:<span class="cov5" title="5">
                allowed = e.evaluateService(policies, resource.Path, capability)</span>
        case ResourceTypeHealth:<span class="cov0" title="0">
                allowed = e.evaluateHealth(policies, capability)</span>
        case ResourceTypeBackup:<span class="cov0" title="0">
                allowed = e.evaluateBackup(policies, capability)</span>
        case ResourceTypeAdmin:<span class="cov0" title="0">
                allowed = e.evaluateAdmin(policies, capability)</span>
        default:<span class="cov0" title="0">
                e.log.Warn("Unknown resource type", logger.String("type", string(resource.Type)))
                allowed = false</span>
        }

        <span class="cov9" title="15">return allowed</span>
}

// evaluateKV evaluates KV rules
func (e *Evaluator) evaluateKV(policies []*Policy, kvPath string, capability Capability) bool <span class="cov7" title="10">{
        e.log.Debug("Evaluating KV access",
                logger.String("path", kvPath),
                logger.String("capability", string(capability)),
                logger.Int("policies", len(policies)))

        for _, policy := range policies </span><span class="cov8" title="11">{
                for _, rule := range policy.KV </span><span class="cov10" title="20">{
                        if rule.Matches(kvPath) </span><span class="cov7" title="10">{
                                // Check for explicit deny
                                if rule.HasCapability(CapabilityDeny) </span><span class="cov1" title="1">{
                                        e.log.Debug("Explicit deny found",
                                                logger.String("policy", policy.Name),
                                                logger.String("path", kvPath),
                                                logger.String("rule_path", rule.Path))
                                        return false
                                }</span>

                                // Check if capability is allowed
                                <span class="cov7" title="9">if rule.HasCapability(capability) </span><span class="cov6" title="6">{
                                        e.log.Debug("Access granted",
                                                logger.String("policy", policy.Name),
                                                logger.String("path", kvPath),
                                                logger.String("capability", string(capability)))
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov4" title="3">e.log.Debug("No matching rule found - denying by default",
                logger.String("path", kvPath),
                logger.String("capability", string(capability)))
        return false</span>
}

// evaluateService evaluates service rules
func (e *Evaluator) evaluateService(policies []*Policy, serviceName string, capability Capability) bool <span class="cov5" title="5">{
        e.log.Debug("Evaluating service access",
                logger.String("service", serviceName),
                logger.String("capability", string(capability)),
                logger.Int("policies", len(policies)))

        for _, policy := range policies </span><span class="cov5" title="5">{
                for _, rule := range policy.Service </span><span class="cov7" title="8">{
                        if rule.Matches(serviceName) </span><span class="cov5" title="5">{
                                // Check for explicit deny
                                if rule.HasCapability(CapabilityDeny) </span><span class="cov0" title="0">{
                                        e.log.Debug("Explicit deny found",
                                                logger.String("policy", policy.Name),
                                                logger.String("service", serviceName))
                                        return false
                                }</span>

                                // Check if capability is allowed
                                <span class="cov5" title="5">if rule.HasCapability(capability) </span><span class="cov4" title="3">{
                                        e.log.Debug("Access granted",
                                                logger.String("policy", policy.Name),
                                                logger.String("service", serviceName),
                                                logger.String("capability", string(capability)))
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov3" title="2">e.log.Debug("No matching rule found - denying by default",
                logger.String("service", serviceName),
                logger.String("capability", string(capability)))
        return false</span>
}

// evaluateHealth evaluates health rules
func (e *Evaluator) evaluateHealth(policies []*Policy, capability Capability) bool <span class="cov0" title="0">{
        e.log.Debug("Evaluating health access",
                logger.String("capability", string(capability)),
                logger.Int("policies", len(policies)))

        for _, policy := range policies </span><span class="cov0" title="0">{
                for _, rule := range policy.Health </span><span class="cov0" title="0">{
                        // Check for explicit deny
                        if rule.HasCapability(CapabilityDeny) </span><span class="cov0" title="0">{
                                e.log.Debug("Explicit deny found", logger.String("policy", policy.Name))
                                return false
                        }</span>

                        // Check if capability is allowed
                        <span class="cov0" title="0">if rule.HasCapability(capability) </span><span class="cov0" title="0">{
                                e.log.Debug("Access granted",
                                        logger.String("policy", policy.Name),
                                        logger.String("capability", string(capability)))
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">e.log.Debug("No matching rule found - denying by default")
        return false</span>
}

// evaluateBackup evaluates backup rules
func (e *Evaluator) evaluateBackup(policies []*Policy, capability Capability) bool <span class="cov0" title="0">{
        e.log.Debug("Evaluating backup access",
                logger.String("capability", string(capability)),
                logger.Int("policies", len(policies)))

        for _, policy := range policies </span><span class="cov0" title="0">{
                for _, rule := range policy.Backup </span><span class="cov0" title="0">{
                        // Check for explicit deny
                        if rule.HasCapability(CapabilityDeny) </span><span class="cov0" title="0">{
                                e.log.Debug("Explicit deny found", logger.String("policy", policy.Name))
                                return false
                        }</span>

                        // Check if capability is allowed
                        <span class="cov0" title="0">if rule.HasCapability(capability) </span><span class="cov0" title="0">{
                                e.log.Debug("Access granted",
                                        logger.String("policy", policy.Name),
                                        logger.String("capability", string(capability)))
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">e.log.Debug("No matching rule found - denying by default")
        return false</span>
}

// evaluateAdmin evaluates admin rules
func (e *Evaluator) evaluateAdmin(policies []*Policy, capability Capability) bool <span class="cov0" title="0">{
        e.log.Debug("Evaluating admin access",
                logger.String("capability", string(capability)),
                logger.Int("policies", len(policies)))

        for _, policy := range policies </span><span class="cov0" title="0">{
                for _, rule := range policy.Admin </span><span class="cov0" title="0">{
                        // Check for explicit deny
                        if rule.HasCapability(CapabilityDeny) </span><span class="cov0" title="0">{
                                e.log.Debug("Explicit deny found", logger.String("policy", policy.Name))
                                return false
                        }</span>

                        // Check if capability is allowed
                        <span class="cov0" title="0">if rule.HasCapability(capability) </span><span class="cov0" title="0">{
                                e.log.Debug("Access granted",
                                        logger.String("policy", policy.Name),
                                        logger.String("capability", string(capability)))
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">e.log.Debug("No matching rule found - denying by default")
        return false</span>
}

// LoadPolicies loads multiple policies at once
func (e *Evaluator) LoadPolicies(policies []*Policy) error <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        for _, policy := range policies </span><span class="cov0" title="0">{
                if err := policy.Validate(); err != nil </span><span class="cov0" title="0">{
                        e.log.Error("Invalid policy",
                                logger.String("policy", policy.Name),
                                logger.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">e.policies[policy.Name] = policy</span>
        }

        <span class="cov0" title="0">e.log.Info("ACL policies loaded", logger.Int("count", len(policies)))
        return nil</span>
}

// Count returns the number of policies
func (e *Evaluator) Count() int <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return len(e.policies)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package acl

import (
        "encoding/json"
        "path"
        "regexp"
        "strings"
)

// Capability represents an ACL permission
type Capability string

const (
        // KV capabilities
        CapabilityRead   Capability = "read"
        CapabilityWrite  Capability = "write"
        CapabilityList   Capability = "list"
        CapabilityDelete Capability = "delete"
        CapabilityDeny   Capability = "deny"

        // Service capabilities
        CapabilityRegister   Capability = "register"
        CapabilityDeregister Capability = "deregister"

        // Backup capabilities
        CapabilityCreate  Capability = "create"
        CapabilityRestore Capability = "restore"
        CapabilityExport  Capability = "export"
        CapabilityImport  Capability = "import"

        // Admin capabilities
        CapabilityAdmin Capability = "admin"
)

// ResourceType represents the type of resource being accessed
type ResourceType string

const (
        ResourceTypeKV      ResourceType = "kv"
        ResourceTypeService ResourceType = "service"
        ResourceTypeHealth  ResourceType = "health"
        ResourceTypeBackup  ResourceType = "backup"
        ResourceTypeAdmin   ResourceType = "admin"
)

// Policy defines access control rules
type Policy struct {
        Name        string        `json:"name"`
        Description string        `json:"description"`
        KV          []KVRule      `json:"kv,omitempty"`
        Service     []ServiceRule `json:"service,omitempty"`
        Health      []HealthRule  `json:"health,omitempty"`
        Backup      []BackupRule  `json:"backup,omitempty"`
        Admin       []AdminRule   `json:"admin,omitempty"`
}

// KVRule defines rules for KV store access
type KVRule struct {
        Path         string       `json:"path"`         // Path pattern (supports * wildcard)
        Capabilities []Capability `json:"capabilities"` // List of allowed capabilities
        compiled     *regexp.Regexp
}

// ServiceRule defines rules for service access
type ServiceRule struct {
        Name         string       `json:"name"`         // Service name pattern (supports * wildcard)
        Capabilities []Capability `json:"capabilities"` // List of allowed capabilities
        compiled     *regexp.Regexp
}

// HealthRule defines rules for health check access
type HealthRule struct {
        Capabilities []Capability `json:"capabilities"` // List of allowed capabilities
}

// BackupRule defines rules for backup operations
type BackupRule struct {
        Capabilities []Capability `json:"capabilities"` // List of allowed capabilities
}

// AdminRule defines rules for admin operations
type AdminRule struct {
        Capabilities []Capability `json:"capabilities"` // List of allowed capabilities
}

// Matches checks if a KV rule matches the given path
func (r *KVRule) Matches(kvPath string) bool <span class="cov9" title="26">{
        if r.compiled == nil </span><span class="cov0" title="0">{
                r.Compile()
        }</span>
        <span class="cov9" title="26">return r.compiled.MatchString(kvPath)</span>
}

// Compile converts the path pattern to a regex
func (r *KVRule) Compile() <span class="cov7" title="12">{
        pattern := r.Path

        // Escape special regex characters except *
        pattern = strings.ReplaceAll(pattern, ".", "\\.")
        pattern = strings.ReplaceAll(pattern, "+", "\\+")
        pattern = strings.ReplaceAll(pattern, "?", "\\?")
        pattern = strings.ReplaceAll(pattern, "[", "\\[")
        pattern = strings.ReplaceAll(pattern, "]", "\\]")
        pattern = strings.ReplaceAll(pattern, "(", "\\(")
        pattern = strings.ReplaceAll(pattern, ")", "\\)")
        pattern = strings.ReplaceAll(pattern, "{", "\\{")
        pattern = strings.ReplaceAll(pattern, "}", "\\}")

        // Convert wildcards to regex
        // * matches any characters within a path segment
        // ** matches any characters including path separators
        pattern = strings.ReplaceAll(pattern, "**", "DOUBLESTAR")
        pattern = strings.ReplaceAll(pattern, "*", "[^/]*")
        pattern = strings.ReplaceAll(pattern, "DOUBLESTAR", ".*")

        // Anchor the pattern
        if !strings.HasPrefix(pattern, "^") </span><span class="cov7" title="12">{
                pattern = "^" + pattern
        }</span>
        <span class="cov7" title="12">if !strings.HasSuffix(pattern, "$") </span><span class="cov7" title="12">{
                pattern = pattern + "$"
        }</span>

        <span class="cov7" title="12">r.compiled = regexp.MustCompile(pattern)</span>
}

// HasCapability checks if the rule has a specific capability
func (r *KVRule) HasCapability(cap Capability) bool <span class="cov9" title="19">{
        for _, c := range r.Capabilities </span><span class="cov10" title="27">{
                if c == cap </span><span class="cov6" title="7">{
                        return true
                }</span>
        }
        <span class="cov7" title="12">return false</span>
}

// Matches checks if a service rule matches the given service name
func (r *ServiceRule) Matches(serviceName string) bool <span class="cov6" title="8">{
        if r.compiled == nil </span><span class="cov0" title="0">{
                r.Compile()
        }</span>
        <span class="cov6" title="8">return r.compiled.MatchString(serviceName)</span>
}

// Compile converts the name pattern to a regex
func (r *ServiceRule) Compile() <span class="cov2" title="2">{
        pattern := r.Name

        // Escape special regex characters except *
        pattern = strings.ReplaceAll(pattern, ".", "\\.")
        pattern = strings.ReplaceAll(pattern, "+", "\\+")
        pattern = strings.ReplaceAll(pattern, "?", "\\?")
        pattern = strings.ReplaceAll(pattern, "[", "\\[")
        pattern = strings.ReplaceAll(pattern, "]", "\\]")
        pattern = strings.ReplaceAll(pattern, "(", "\\(")
        pattern = strings.ReplaceAll(pattern, ")", "\\)")
        pattern = strings.ReplaceAll(pattern, "{", "\\{")
        pattern = strings.ReplaceAll(pattern, "}", "\\}")

        // Convert wildcards to regex
        pattern = strings.ReplaceAll(pattern, "*", ".*")

        // Anchor the pattern
        if !strings.HasPrefix(pattern, "^") </span><span class="cov2" title="2">{
                pattern = "^" + pattern
        }</span>
        <span class="cov2" title="2">if !strings.HasSuffix(pattern, "$") </span><span class="cov2" title="2">{
                pattern = pattern + "$"
        }</span>

        <span class="cov2" title="2">r.compiled = regexp.MustCompile(pattern)</span>
}

// HasCapability checks if the rule has a specific capability
func (r *ServiceRule) HasCapability(cap Capability) bool <span class="cov7" title="10">{
        for _, c := range r.Capabilities </span><span class="cov8" title="15">{
                if c == cap </span><span class="cov4" title="3">{
                        return true
                }</span>
        }
        <span class="cov6" title="7">return false</span>
}

// HasCapability checks if the rule has a specific capability
func (r *HealthRule) HasCapability(cap Capability) bool <span class="cov0" title="0">{
        for _, c := range r.Capabilities </span><span class="cov0" title="0">{
                if c == cap </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HasCapability checks if the rule has a specific capability
func (r *BackupRule) HasCapability(cap Capability) bool <span class="cov0" title="0">{
        for _, c := range r.Capabilities </span><span class="cov0" title="0">{
                if c == cap </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HasCapability checks if the rule has a specific capability
func (r *AdminRule) HasCapability(cap Capability) bool <span class="cov0" title="0">{
        for _, c := range r.Capabilities </span><span class="cov0" title="0">{
                if c == cap </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Resource represents a resource being accessed
type Resource struct {
        Type ResourceType
        Path string // For KV: key path, For Service: service name
}

// NewKVResource creates a new KV resource
func NewKVResource(keyPath string) Resource <span class="cov7" title="9">{
        return Resource{
                Type: ResourceTypeKV,
                Path: path.Clean(keyPath),
        }
}</span>

// NewServiceResource creates a new service resource
func NewServiceResource(serviceName string) Resource <span class="cov5" title="5">{
        return Resource{
                Type: ResourceTypeService,
                Path: serviceName,
        }
}</span>

// NewHealthResource creates a new health resource
func NewHealthResource() Resource <span class="cov0" title="0">{
        return Resource{
                Type: ResourceTypeHealth,
        }
}</span>

// NewBackupResource creates a new backup resource
func NewBackupResource() Resource <span class="cov0" title="0">{
        return Resource{
                Type: ResourceTypeBackup,
        }
}</span>

// NewAdminResource creates a new admin resource
func NewAdminResource() Resource <span class="cov0" title="0">{
        return Resource{
                Type: ResourceTypeAdmin,
        }
}</span>

// Validate checks if the policy is valid
func (p *Policy) Validate() error <span class="cov7" title="10">{
        if p.Name == "" </span><span class="cov1" title="1">{
                return ErrInvalidPolicy
        }</span>

        // Compile all patterns
        <span class="cov7" title="9">for i := range p.KV </span><span class="cov5" title="6">{
                p.KV[i].Compile()
        }</span>
        <span class="cov7" title="9">for i := range p.Service </span><span class="cov2" title="2">{
                p.Service[i].Compile()
        }</span>

        <span class="cov7" title="9">return nil</span>
}

// ToJSON converts the policy to JSON
func (p *Policy) ToJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(p)
}</span>

// FromJSON parses a policy from JSON
func FromJSON(data []byte) (*Policy, error) <span class="cov0" title="0">{
        var policy Policy
        if err := json.Unmarshal(data, &amp;policy); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := policy.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;policy, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/google/uuid"
)

var (
        ErrAPIKeyNotFound = errors.New("API key not found")
        ErrAPIKeyExpired  = errors.New("API key has expired")
        ErrAPIKeyDisabled = errors.New("API key is disabled")
)

type APIKey struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        KeyHash     string            `json:"key_hash"`
        Permissions []string          `json:"permissions"`
        Metadata    map[string]string `json:"metadata"`
        CreatedAt   time.Time         `json:"created_at"`
        ExpiresAt   *time.Time        `json:"expires_at,omitempty"`
        LastUsedAt  *time.Time        `json:"last_used_at,omitempty"`
        Enabled     bool              `json:"enabled"`
}

type APIKeyService struct {
        keys   map[string]*APIKey // key hash -&gt; APIKey
        mu     sync.RWMutex
        prefix string
}

func NewAPIKeyService(prefix string) *APIKeyService <span class="cov8" title="10">{
        if prefix == "" </span><span class="cov1" title="1">{
                prefix = "konsul"
        }</span>
        <span class="cov8" title="10">return &amp;APIKeyService{
                keys:   make(map[string]*APIKey),
                prefix: prefix,
        }</span>
}

func (a *APIKeyService) GenerateAPIKey(name string, permissions []string, metadata map[string]string, expiresAt *time.Time) (string, *APIKey, error) <span class="cov10" title="15">{
        if name == "" </span><span class="cov1" title="1">{
                return "", nil, errors.New("API key name cannot be empty")
        }</span>

        // Generate random key
        <span class="cov9" title="14">keyBytes := make([]byte, 32)
        if _, err := rand.Read(keyBytes); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to generate random key: %w", err)
        }</span>

        // Create the full key with prefix
        <span class="cov9" title="14">keyString := fmt.Sprintf("%s_%s", a.prefix, hex.EncodeToString(keyBytes))

        // Hash the key for storage
        hasher := sha256.New()
        hasher.Write([]byte(keyString))
        keyHash := hex.EncodeToString(hasher.Sum(nil))

        apiKey := &amp;APIKey{
                ID:          uuid.New().String(),
                Name:        name,
                KeyHash:     keyHash,
                Permissions: permissions,
                Metadata:    metadata,
                CreatedAt:   time.Now(),
                ExpiresAt:   expiresAt,
                Enabled:     true,
        }

        a.mu.Lock()
        a.keys[keyHash] = apiKey
        a.mu.Unlock()

        return keyString, apiKey, nil</span>
}

func (a *APIKeyService) ValidateAPIKey(keyString string) (*APIKey, error) <span class="cov7" title="7">{
        if keyString == "" </span><span class="cov1" title="1">{
                return nil, ErrAPIKeyNotFound
        }</span>

        // Hash the provided key
        <span class="cov6" title="6">hasher := sha256.New()
        hasher.Write([]byte(keyString))
        keyHash := hex.EncodeToString(hasher.Sum(nil))

        a.mu.RLock()
        apiKey, exists := a.keys[keyHash]
        a.mu.RUnlock()

        if !exists </span><span class="cov3" title="2">{
                return nil, ErrAPIKeyNotFound
        }</span>

        <span class="cov5" title="4">if !apiKey.Enabled </span><span class="cov3" title="2">{
                return nil, ErrAPIKeyDisabled
        }</span>

        <span class="cov3" title="2">if apiKey.ExpiresAt != nil &amp;&amp; time.Now().After(*apiKey.ExpiresAt) </span><span class="cov1" title="1">{
                return nil, ErrAPIKeyExpired
        }</span>

        // Update last used time
        <span class="cov1" title="1">a.mu.Lock()
        now := time.Now()
        apiKey.LastUsedAt = &amp;now
        a.mu.Unlock()

        return apiKey, nil</span>
}

func (a *APIKeyService) RevokeAPIKey(keyID string) error <span class="cov4" title="3">{
        a.mu.Lock()
        defer a.mu.Unlock()

        for _, apiKey := range a.keys </span><span class="cov6" title="5">{
                if apiKey.ID == keyID </span><span class="cov3" title="2">{
                        apiKey.Enabled = false
                        return nil
                }</span>
        }

        <span class="cov1" title="1">return ErrAPIKeyNotFound</span>
}

func (a *APIKeyService) DeleteAPIKey(keyID string) error <span class="cov3" title="2">{
        a.mu.Lock()
        defer a.mu.Unlock()

        for keyHash, apiKey := range a.keys </span><span class="cov1" title="1">{
                if apiKey.ID == keyID </span><span class="cov1" title="1">{
                        delete(a.keys, keyHash)
                        return nil
                }</span>
        }

        <span class="cov1" title="1">return ErrAPIKeyNotFound</span>
}

func (a *APIKeyService) ListAPIKeys() []*APIKey <span class="cov4" title="3">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        keys := make([]*APIKey, 0, len(a.keys))
        for _, apiKey := range a.keys </span><span class="cov6" title="5">{
                // Create a copy without sensitive data
                keyCopy := &amp;APIKey{
                        ID:          apiKey.ID,
                        Name:        apiKey.Name,
                        Permissions: apiKey.Permissions,
                        Metadata:    apiKey.Metadata,
                        CreatedAt:   apiKey.CreatedAt,
                        ExpiresAt:   apiKey.ExpiresAt,
                        LastUsedAt:  apiKey.LastUsedAt,
                        Enabled:     apiKey.Enabled,
                }
                keys = append(keys, keyCopy)
        }</span>

        <span class="cov4" title="3">return keys</span>
}

func (a *APIKeyService) GetAPIKey(keyID string) (*APIKey, error) <span class="cov3" title="2">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        for _, apiKey := range a.keys </span><span class="cov3" title="2">{
                if apiKey.ID == keyID </span><span class="cov1" title="1">{
                        // Create a copy without sensitive data
                        keyCopy := &amp;APIKey{
                                ID:          apiKey.ID,
                                Name:        apiKey.Name,
                                Permissions: apiKey.Permissions,
                                Metadata:    apiKey.Metadata,
                                CreatedAt:   apiKey.CreatedAt,
                                ExpiresAt:   apiKey.ExpiresAt,
                                LastUsedAt:  apiKey.LastUsedAt,
                                Enabled:     apiKey.Enabled,
                        }
                        return keyCopy, nil
                }</span>
        }

        <span class="cov1" title="1">return nil, ErrAPIKeyNotFound</span>
}

func (a *APIKeyService) UpdateAPIKey(keyID string, name string, permissions []string, metadata map[string]string, enabled *bool) error <span class="cov5" title="4">{
        a.mu.Lock()
        defer a.mu.Unlock()

        for _, apiKey := range a.keys </span><span class="cov5" title="4">{
                if apiKey.ID == keyID </span><span class="cov4" title="3">{
                        if name != "" </span><span class="cov1" title="1">{
                                apiKey.Name = name
                        }</span>
                        <span class="cov4" title="3">if permissions != nil </span><span class="cov1" title="1">{
                                apiKey.Permissions = permissions
                        }</span>
                        <span class="cov4" title="3">if metadata != nil </span><span class="cov0" title="0">{
                                apiKey.Metadata = metadata
                        }</span>
                        <span class="cov4" title="3">if enabled != nil </span><span class="cov1" title="1">{
                                apiKey.Enabled = *enabled
                        }</span>
                        <span class="cov4" title="3">return nil</span>
                }
        }

        <span class="cov1" title="1">return ErrAPIKeyNotFound</span>
}

func (a *APIKeyService) HasPermission(apiKey *APIKey, permission string) bool <span class="cov5" title="4">{
        if apiKey == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov4" title="3">for _, perm := range apiKey.Permissions </span><span class="cov4" title="3">{
                if perm == permission || perm == "*" </span><span class="cov3" title="2">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package auth

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

var (
        ErrTokenExpired = errors.New("token has expired")
        ErrTokenInvalid = errors.New("token is invalid")
        ErrTokenMissing = errors.New("token is missing")
)

type Claims struct {
        UserID   string   `json:"user_id"`
        Username string   `json:"username"`
        Roles    []string `json:"roles"`
        Policies []string `json:"policies,omitempty"` // ACL policies attached to this token
        jwt.RegisteredClaims
}

type JWTService struct {
        secretKey     []byte
        tokenExpiry   time.Duration
        refreshExpiry time.Duration
        issuer        string
}

func NewJWTService(secretKey string, tokenExpiry, refreshExpiry time.Duration, issuer string) *JWTService <span class="cov10" title="8">{
        return &amp;JWTService{
                secretKey:     []byte(secretKey),
                tokenExpiry:   tokenExpiry,
                refreshExpiry: refreshExpiry,
                issuer:        issuer,
        }
}</span>

func (j *JWTService) GenerateToken(userID, username string, roles []string) (string, error) <span class="cov8" title="6">{
        return j.GenerateTokenWithPolicies(userID, username, roles, nil)
}</span>

// GenerateTokenWithPolicies generates a JWT token with policies
func (j *JWTService) GenerateTokenWithPolicies(userID, username string, roles, policies []string) (string, error) <span class="cov9" title="7">{
        claims := Claims{
                UserID:   userID,
                Username: username,
                Roles:    roles,
                Policies: policies,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.tokenExpiry)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    j.issuer,
                        Subject:   userID,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(j.secretKey)
}</span>

func (j *JWTService) GenerateRefreshToken(userID string) (string, error) <span class="cov7" title="5">{
        claims := jwt.RegisteredClaims{
                ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.refreshExpiry)),
                IssuedAt:  jwt.NewNumericDate(time.Now()),
                NotBefore: jwt.NewNumericDate(time.Now()),
                Issuer:    j.issuer,
                Subject:   userID,
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(j.secretKey)
}</span>

func (j *JWTService) ValidateToken(tokenString string) (*Claims, error) <span class="cov9" title="7">{
        if tokenString == "" </span><span class="cov1" title="1">{
                return nil, ErrTokenMissing
        }</span>

        <span class="cov8" title="6">token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov7" title="4">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, ErrTokenInvalid
                }</span>
                <span class="cov7" title="4">return j.secretKey, nil</span>
        })

        <span class="cov8" title="6">if err != nil </span><span class="cov7" title="4">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov1" title="1">{
                        return nil, ErrTokenExpired
                }</span>
                <span class="cov5" title="3">return nil, ErrTokenInvalid</span>
        }

        <span class="cov4" title="2">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov4" title="2">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, ErrTokenInvalid</span>
}

func (j *JWTService) ValidateRefreshToken(tokenString string) (string, error) <span class="cov9" title="7">{
        if tokenString == "" </span><span class="cov4" title="2">{
                return "", ErrTokenMissing
        }</span>

        <span class="cov7" title="5">token, err := jwt.ParseWithClaims(tokenString, &amp;jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov5" title="3">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, ErrTokenInvalid
                }</span>
                <span class="cov5" title="3">return j.secretKey, nil</span>
        })

        <span class="cov7" title="5">if err != nil </span><span class="cov4" title="2">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov0" title="0">{
                        return "", ErrTokenExpired
                }</span>
                <span class="cov4" title="2">return "", ErrTokenInvalid</span>
        }

        <span class="cov5" title="3">if claims, ok := token.Claims.(*jwt.RegisteredClaims); ok &amp;&amp; token.Valid </span><span class="cov5" title="3">{
                return claims.Subject, nil
        }</span>

        <span class="cov0" title="0">return "", ErrTokenInvalid</span>
}

func (j *JWTService) RefreshToken(refreshTokenString string, username string, roles []string) (string, string, error) <span class="cov5" title="3">{
        return j.RefreshTokenWithPolicies(refreshTokenString, username, roles, nil)
}</span>

// RefreshTokenWithPolicies refreshes a token with policies
func (j *JWTService) RefreshTokenWithPolicies(refreshTokenString string, username string, roles, policies []string) (string, string, error) <span class="cov5" title="3">{
        userID, err := j.ValidateRefreshToken(refreshTokenString)
        if err != nil </span><span class="cov4" title="2">{
                return "", "", err
        }</span>

        <span class="cov1" title="1">newToken, err := j.GenerateTokenWithPolicies(userID, username, roles, policies)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov1" title="1">newRefreshToken, err := j.GenerateRefreshToken(userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov1" title="1">return newToken, newRefreshToken, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"
)

// Config represents the application configuration
type Config struct {
        Server      ServerConfig
        Service     ServiceConfig
        Log         LogConfig
        Persistence PersistenceConfig
        DNS         DNSConfig
        RateLimit   RateLimitConfig
        Auth        AuthConfig
        Tracing     TracingConfig
        ACL         ACLConfig
        GraphQL     GraphQLConfig
}

// ServerConfig contains HTTP server configuration
type ServerConfig struct {
        Host string
        Port int
        TLS  TLSConfig
}

// TLSConfig contains TLS/SSL configuration
type TLSConfig struct {
        Enabled  bool
        CertFile string
        KeyFile  string
        AutoCert bool // Auto-generate self-signed cert for development
}

// ServiceConfig contains service discovery configuration
type ServiceConfig struct {
        TTL             time.Duration
        CleanupInterval time.Duration
}

// LogConfig contains logging configuration
type LogConfig struct {
        Level  string
        Format string
}

// PersistenceConfig contains persistence configuration
type PersistenceConfig struct {
        Enabled    bool
        Type       string // "memory", "badger"
        DataDir    string
        BackupDir  string
        SyncWrites bool
        WALEnabled bool
}

// DNSConfig contains DNS server configuration
type DNSConfig struct {
        Enabled bool
        Host    string
        Port    int
        Domain  string
}

// RateLimitConfig contains rate limiting configuration
type RateLimitConfig struct {
        Enabled         bool
        RequestsPerSec  float64
        Burst           int
        ByIP            bool
        ByAPIKey        bool
        CleanupInterval time.Duration
}

// AuthConfig contains authentication configuration
type AuthConfig struct {
        Enabled       bool
        JWTSecret     string
        JWTExpiry     time.Duration
        RefreshExpiry time.Duration
        Issuer        string
        APIKeyPrefix  string
        RequireAuth   bool
        PublicPaths   []string
}

// TracingConfig contains OpenTelemetry tracing configuration
type TracingConfig struct {
        Enabled        bool
        Endpoint       string
        ServiceName    string
        ServiceVersion string
        Environment    string
        SamplingRatio  float64
        InsecureConn   bool
}

// ACLConfig contains ACL (Access Control List) configuration
type ACLConfig struct {
        Enabled       bool
        DefaultPolicy string // "allow" or "deny"
        PolicyDir     string // Directory containing policy JSON files
}

// GraphQLConfig contains GraphQL API configuration
type GraphQLConfig struct {
        Enabled           bool
        PlaygroundEnabled bool
}

// Load loads configuration from environment variables with defaults
func Load() (*Config, error) <span class="cov4" title="10">{
        config := &amp;Config{
                Server: ServerConfig{
                        Host: getEnvString("KONSUL_HOST", ""),
                        Port: getEnvInt("KONSUL_PORT", 8888),
                        TLS: TLSConfig{
                                Enabled:  getEnvBool("KONSUL_TLS_ENABLED", false),
                                CertFile: getEnvString("KONSUL_TLS_CERT_FILE", ""),
                                KeyFile:  getEnvString("KONSUL_TLS_KEY_FILE", ""),
                                AutoCert: getEnvBool("KONSUL_TLS_AUTO_CERT", false),
                        },
                },
                Service: ServiceConfig{
                        TTL:             getEnvDuration("KONSUL_SERVICE_TTL", 30*time.Second),
                        CleanupInterval: getEnvDuration("KONSUL_CLEANUP_INTERVAL", 60*time.Second),
                },
                Log: LogConfig{
                        Level:  getEnvString("KONSUL_LOG_LEVEL", "info"),
                        Format: getEnvString("KONSUL_LOG_FORMAT", "text"),
                },
                Persistence: PersistenceConfig{
                        Enabled:    getEnvBool("KONSUL_PERSISTENCE_ENABLED", false),
                        Type:       getEnvString("KONSUL_PERSISTENCE_TYPE", "badger"),
                        DataDir:    getEnvString("KONSUL_DATA_DIR", "./data"),
                        BackupDir:  getEnvString("KONSUL_BACKUP_DIR", "./backups"),
                        SyncWrites: getEnvBool("KONSUL_SYNC_WRITES", true),
                        WALEnabled: getEnvBool("KONSUL_WAL_ENABLED", true),
                },
                DNS: DNSConfig{
                        Enabled: getEnvBool("KONSUL_DNS_ENABLED", true),
                        Host:    getEnvString("KONSUL_DNS_HOST", ""),
                        Port:    getEnvInt("KONSUL_DNS_PORT", 8600),
                        Domain:  getEnvString("KONSUL_DNS_DOMAIN", "consul"),
                },
                RateLimit: RateLimitConfig{
                        Enabled:         getEnvBool("KONSUL_RATE_LIMIT_ENABLED", false),
                        RequestsPerSec:  getEnvFloat("KONSUL_RATE_LIMIT_REQUESTS_PER_SEC", 100.0),
                        Burst:           getEnvInt("KONSUL_RATE_LIMIT_BURST", 20),
                        ByIP:            getEnvBool("KONSUL_RATE_LIMIT_BY_IP", true),
                        ByAPIKey:        getEnvBool("KONSUL_RATE_LIMIT_BY_APIKEY", false),
                        CleanupInterval: getEnvDuration("KONSUL_RATE_LIMIT_CLEANUP", 5*time.Minute),
                },
                Auth: AuthConfig{
                        Enabled:       getEnvBool("KONSUL_AUTH_ENABLED", false),
                        JWTSecret:     getEnvString("KONSUL_JWT_SECRET", ""),
                        JWTExpiry:     getEnvDuration("KONSUL_JWT_EXPIRY", 15*time.Minute),
                        RefreshExpiry: getEnvDuration("KONSUL_REFRESH_EXPIRY", 7*24*time.Hour),
                        Issuer:        getEnvString("KONSUL_JWT_ISSUER", "konsul"),
                        APIKeyPrefix:  getEnvString("KONSUL_APIKEY_PREFIX", "konsul"),
                        RequireAuth:   getEnvBool("KONSUL_REQUIRE_AUTH", false),
                        PublicPaths:   getEnvStringSlice("KONSUL_PUBLIC_PATHS", []string{"/health", "/health/live", "/health/ready", "/metrics"}),
                },
                Tracing: TracingConfig{
                        Enabled:        getEnvBool("KONSUL_TRACING_ENABLED", false),
                        Endpoint:       getEnvString("KONSUL_TRACING_ENDPOINT", "otel-collector:4318"),
                        ServiceName:    getEnvString("KONSUL_TRACING_SERVICE_NAME", "konsul"),
                        ServiceVersion: getEnvString("KONSUL_TRACING_SERVICE_VERSION", "1.0.0"),
                        Environment:    getEnvString("KONSUL_TRACING_ENVIRONMENT", "development"),
                        SamplingRatio:  getEnvFloat("KONSUL_TRACING_SAMPLING_RATIO", 1.0),
                        InsecureConn:   getEnvBool("KONSUL_TRACING_INSECURE", true),
                },
                ACL: ACLConfig{
                        Enabled:       getEnvBool("KONSUL_ACL_ENABLED", false),
                        DefaultPolicy: getEnvString("KONSUL_ACL_DEFAULT_POLICY", "deny"),
                        PolicyDir:     getEnvString("KONSUL_ACL_POLICY_DIR", "./policies"),
                },
                GraphQL: GraphQLConfig{
                        Enabled:           getEnvBool("KONSUL_GRAPHQL_ENABLED", false),
                        PlaygroundEnabled: getEnvBool("KONSUL_GRAPHQL_PLAYGROUND_ENABLED", true),
                },
        }

        if err := config.Validate(); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov4" title="8">return config, nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov6" title="19">{
        if c.Server.Port &lt;= 0 || c.Server.Port &gt; 65535 </span><span class="cov3" title="5">{
                return fmt.Errorf("invalid port: %d (must be 1-65535)", c.Server.Port)
        }</span>

        // Validate TLS configuration if enabled
        <span class="cov5" title="14">if c.Server.TLS.Enabled </span><span class="cov0" title="0">{
                if !c.Server.TLS.AutoCert </span><span class="cov0" title="0">{
                        if c.Server.TLS.CertFile == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("TLS cert file must be specified when TLS is enabled")
                        }</span>
                        <span class="cov0" title="0">if c.Server.TLS.KeyFile == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("TLS key file must be specified when TLS is enabled")
                        }</span>
                }
        }

        <span class="cov5" title="14">if c.Service.TTL &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid service TTL: %v (must be positive)", c.Service.TTL)
        }</span>

        <span class="cov5" title="13">if c.Service.CleanupInterval &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid cleanup interval: %v (must be positive)", c.Service.CleanupInterval)
        }</span>

        <span class="cov5" title="12">validLogLevels := map[string]bool{
                "debug": true,
                "info":  true,
                "warn":  true,
                "error": true,
        }
        if !validLogLevels[c.Log.Level] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log level: %s (must be debug, info, warn, or error)", c.Log.Level)
        }</span>

        <span class="cov5" title="11">validLogFormats := map[string]bool{
                "text": true,
                "json": true,
        }
        if !validLogFormats[c.Log.Format] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log format: %s (must be text or json)", c.Log.Format)
        }</span>

        // Validate persistence configuration if enabled
        <span class="cov4" title="10">if c.Persistence.Enabled </span><span class="cov0" title="0">{
                validPersistenceTypes := map[string]bool{
                        "memory": true,
                        "badger": true,
                }
                if !validPersistenceTypes[c.Persistence.Type] </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid persistence type: %s (must be memory or badger)", c.Persistence.Type)
                }</span>

                <span class="cov0" title="0">if c.Persistence.DataDir == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("data directory must be specified when persistence is enabled")
                }</span>
        }

        // Validate DNS configuration if enabled
        <span class="cov4" title="10">if c.DNS.Enabled </span><span class="cov4" title="8">{
                if c.DNS.Port &lt;= 0 || c.DNS.Port &gt; 65535 </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid DNS port: %d (must be 1-65535)", c.DNS.Port)
                }</span>

                <span class="cov4" title="7">if c.DNS.Domain == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("DNS domain must be specified when DNS is enabled")
                }</span>
        }

        // Validate rate limit configuration if enabled
        <span class="cov4" title="9">if c.RateLimit.Enabled </span><span class="cov0" title="0">{
                if c.RateLimit.RequestsPerSec &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("rate limit requests per second must be positive")
                }</span>

                <span class="cov0" title="0">if c.RateLimit.Burst &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("rate limit burst must be positive")
                }</span>

                <span class="cov0" title="0">if !c.RateLimit.ByIP &amp;&amp; !c.RateLimit.ByAPIKey </span><span class="cov0" title="0">{
                        return fmt.Errorf("rate limiting must be enabled for at least IP or API key")
                }</span>
        }

        // Validate auth configuration if enabled
        <span class="cov4" title="9">if c.Auth.Enabled || c.Auth.RequireAuth </span><span class="cov0" title="0">{
                if c.Auth.JWTSecret == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT secret must be specified when auth is enabled")
                }</span>

                <span class="cov0" title="0">if c.Auth.JWTExpiry &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT expiry must be positive")
                }</span>

                <span class="cov0" title="0">if c.Auth.RefreshExpiry &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("refresh expiry must be positive")
                }</span>

                <span class="cov0" title="0">if c.Auth.Issuer == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("JWT issuer must be specified when auth is enabled")
                }</span>
        }

        // Validate ACL configuration if enabled
        <span class="cov4" title="9">if c.ACL.Enabled </span><span class="cov0" title="0">{
                if c.ACL.DefaultPolicy != "allow" &amp;&amp; c.ACL.DefaultPolicy != "deny" </span><span class="cov0" title="0">{
                        return fmt.Errorf("ACL default policy must be 'allow' or 'deny', got: %s", c.ACL.DefaultPolicy)
                }</span>

                <span class="cov0" title="0">if !c.Auth.Enabled </span><span class="cov0" title="0">{
                        return fmt.Errorf("ACL requires authentication to be enabled")
                }</span>
        }

        <span class="cov4" title="9">return nil</span>
}

// Address returns the server address in host:port format
func (c *Config) Address() string <span class="cov3" title="4">{
        if c.Server.Host == "" </span><span class="cov1" title="1">{
                return fmt.Sprintf(":%d", c.Server.Port)
        }</span>
        <span class="cov2" title="3">return fmt.Sprintf("%s:%d", c.Server.Host, c.Server.Port)</span>
}

// getEnvString gets a string environment variable with a default value
func getEnvString(key, defaultValue string) string <span class="cov10" title="190">{
        if value := os.Getenv(key); value != "" </span><span class="cov4" title="7">{
                return value
        }</span>
        <span class="cov9" title="183">return defaultValue</span>
}

// getEnvInt gets an integer environment variable with a default value
func getEnvInt(key string, defaultValue int) int <span class="cov6" title="30">{
        if value := os.Getenv(key); value != "" </span><span class="cov4" title="7">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov3" title="5">{
                        return intValue
                }</span>
        }
        <span class="cov6" title="25">return defaultValue</span>
}

// getEnvDuration gets a duration environment variable with a default value
func getEnvDuration(key string, defaultValue time.Duration) time.Duration <span class="cov7" title="50">{
        if value := os.Getenv(key); value != "" </span><span class="cov2" title="3">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov2" title="2">{
                        return duration
                }</span>
        }
        <span class="cov7" title="48">return defaultValue</span>
}

// getEnvBool gets a boolean environment variable with a default value
func getEnvBool(key string, defaultValue bool) bool <span class="cov9" title="160">{
        if value := os.Getenv(key); value != "" </span><span class="cov2" title="3">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov2" title="3">{
                        return boolValue
                }</span>
        }
        <span class="cov9" title="157">return defaultValue</span>
}

// getEnvFloat gets a float environment variable with a default value
func getEnvFloat(key string, defaultValue float64) float64 <span class="cov6" title="20">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if floatValue, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                        return floatValue
                }</span>
        }
        <span class="cov6" title="20">return defaultValue</span>
}

// getEnvStringSlice gets a comma-separated string environment variable as a slice with a default value
func getEnvStringSlice(key string, defaultValue []string) []string <span class="cov4" title="10">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                result := []string{}
                for _, v := range splitAndTrim(value, ",") </span><span class="cov0" title="0">{
                        if v != "" </span><span class="cov0" title="0">{
                                result = append(result, v)
                        }</span>
                }
                <span class="cov0" title="0">if len(result) &gt; 0 </span><span class="cov0" title="0">{
                        return result
                }</span>
        }
        <span class="cov4" title="10">return defaultValue</span>
}

// splitAndTrim splits a string by delimiter and trims spaces from each element
func splitAndTrim(s, delimiter string) []string <span class="cov0" title="0">{
        parts := []string{}
        for _, part := range splitString(s, delimiter) </span><span class="cov0" title="0">{
                trimmed := trimSpace(part)
                parts = append(parts, trimmed)
        }</span>
        <span class="cov0" title="0">return parts</span>
}

// splitString splits a string by delimiter
func splitString(s, delimiter string) []string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">result := []string{}
        current := ""
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                if i+len(delimiter) &lt;= len(s) &amp;&amp; s[i:i+len(delimiter)] == delimiter </span><span class="cov0" title="0">{
                        result = append(result, current)
                        current = ""
                        i += len(delimiter) - 1
                }</span> else<span class="cov0" title="0"> {
                        current += string(s[i])
                }</span>
        }
        <span class="cov0" title="0">result = append(result, current)
        return result</span>
}

// trimSpace removes leading and trailing whitespace
func trimSpace(s string) string <span class="cov0" title="0">{
        start := 0
        end := len(s)
        for start &lt; end &amp;&amp; (s[start] == ' ' || s[start] == '\t' || s[start] == '\n' || s[start] == '\r') </span><span class="cov0" title="0">{
                start++
        }</span>
        <span class="cov0" title="0">for end &gt; start &amp;&amp; (s[end-1] == ' ' || s[end-1] == '\t' || s[end-1] == '\n' || s[end-1] == '\r') </span><span class="cov0" title="0">{
                end--
        }</span>
        <span class="cov0" title="0">return s[start:end]</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package dns

import (
        "fmt"
        "net"
        "strings"

        "github.com/miekg/dns"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/store"
)

type Server struct {
        udpServer *dns.Server
        tcpServer *dns.Server
        domain    string
        store     *store.ServiceStore
        log       logger.Logger
}

type Config struct {
        Host   string
        Port   int
        Domain string
}

func NewServer(cfg Config, serviceStore *store.ServiceStore, log logger.Logger) *Server <span class="cov8" title="14">{
        s := &amp;Server{
                domain: cfg.Domain,
                store:  serviceStore,
                log:    log,
        }

        mux := dns.NewServeMux()
        mux.HandleFunc(".", s.handleDNSRequest)

        addr := fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)
        s.udpServer = &amp;dns.Server{
                Addr:    addr,
                Net:     "udp",
                Handler: mux,
        }

        s.tcpServer = &amp;dns.Server{
                Addr:    addr,
                Net:     "tcp",
                Handler: mux,
        }

        return s
}</span>

func (s *Server) Start() error <span class="cov5" title="5">{
        s.log.Info("Starting DNS server",
                logger.String("domain", s.domain),
                logger.String("udp_addr", s.udpServer.Addr),
                logger.String("tcp_addr", s.tcpServer.Addr))

        // Start UDP server
        go func() </span><span class="cov5" title="5">{
                if err := s.udpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        s.log.Error("DNS UDP server failed", logger.Error(err))
                }</span>
        }()

        // Start TCP server
        <span class="cov5" title="5">go func() </span><span class="cov5" title="5">{
                if err := s.tcpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        s.log.Error("DNS TCP server failed", logger.Error(err))
                }</span>
        }()

        <span class="cov5" title="5">return nil</span>
}

func (s *Server) Stop() error <span class="cov5" title="5">{
        var udpErr, tcpErr error

        if s.udpServer != nil </span><span class="cov5" title="5">{
                udpErr = s.udpServer.Shutdown()
        }</span>

        <span class="cov5" title="5">if s.tcpServer != nil </span><span class="cov5" title="5">{
                tcpErr = s.tcpServer.Shutdown()
        }</span>

        <span class="cov5" title="5">if udpErr != nil </span><span class="cov0" title="0">{
                return udpErr
        }</span>
        <span class="cov5" title="5">return tcpErr</span>
}

func (s *Server) handleDNSRequest(w dns.ResponseWriter, r *dns.Msg) <span class="cov9" title="27">{
        msg := new(dns.Msg)
        msg.SetReply(r)
        msg.Authoritative = true

        for _, question := range r.Question </span><span class="cov9" title="27">{
                s.log.Debug("DNS query received",
                        logger.String("name", question.Name),
                        logger.String("type", dns.TypeToString[question.Qtype]))

                switch question.Qtype </span>{
                case dns.TypeSRV:<span class="cov9" title="23">
                        s.handleSRVQuery(msg, question)</span>
                case dns.TypeA:<span class="cov2" title="2">
                        s.handleAQuery(msg, question)</span>
                case dns.TypeANY:<span class="cov1" title="1">
                        s.handleSRVQuery(msg, question)
                        s.handleAQuery(msg, question)</span>
                default:<span class="cov1" title="1">
                        s.log.Debug("Unsupported DNS query type",
                                logger.String("type", dns.TypeToString[question.Qtype]))</span>
                }
        }

        <span class="cov9" title="27">if len(msg.Answer) == 0 </span><span class="cov5" title="6">{
                msg.Rcode = dns.RcodeNameError
        }</span>

        <span class="cov9" title="27">w.WriteMsg(msg)</span>
}

func (s *Server) handleSRVQuery(msg *dns.Msg, question dns.Question) <span class="cov9" title="24">{
        name := strings.TrimSuffix(question.Name, ".")

        // Parse SRV query: _service._protocol.service.consul
        parts := strings.Split(name, ".")
        if len(parts) &lt; 4 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov9" title="23">serviceName := strings.TrimPrefix(parts[0], "_")
        protocol := strings.TrimPrefix(parts[1], "_")

        // For now, we'll ignore protocol and just match service name
        _ = protocol

        // Get all healthy services matching the name
        services := s.store.List()
        var matchingServices []store.Service

        for _, service := range services </span><span class="cov10" title="29">{
                if service.Name == serviceName </span><span class="cov8" title="19">{
                        matchingServices = append(matchingServices, service)
                }</span>
        }

        // Create SRV records
        <span class="cov9" title="23">for i, service := range matchingServices </span><span class="cov8" title="19">{
                target := fmt.Sprintf("%s.node.%s.", service.Name, s.domain)

                srv := &amp;dns.SRV{
                        Hdr: dns.RR_Header{
                                Name:   question.Name,
                                Rrtype: dns.TypeSRV,
                                Class:  dns.ClassINET,
                                Ttl:    30,
                        },
                        Priority: 1,
                        Weight:   uint16(100 / (i + 1)), // Simple weight distribution
                        Port:     uint16(service.Port),
                        Target:   target,
                }
                msg.Answer = append(msg.Answer, srv)

                // Add corresponding A record in Additional section
                a := &amp;dns.A{
                        Hdr: dns.RR_Header{
                                Name:   target,
                                Rrtype: dns.TypeA,
                                Class:  dns.ClassINET,
                                Ttl:    30,
                        },
                        A: net.ParseIP(service.Address),
                }
                msg.Extra = append(msg.Extra, a)
        }</span>

        <span class="cov9" title="23">s.log.Debug("SRV query processed",
                logger.String("service", serviceName),
                logger.Int("matches", len(matchingServices)))</span>
}

func (s *Server) handleAQuery(msg *dns.Msg, question dns.Question) <span class="cov3" title="3">{
        name := strings.TrimSuffix(question.Name, ".")

        // Parse A query: service.node.consul or service-name.service.consul
        parts := strings.Split(name, ".")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">var serviceName string

        // Check if it's a node query (service.node.consul)
        if len(parts) &gt;= 3 &amp;&amp; parts[1] == "node" </span><span class="cov1" title="1">{
                serviceName = parts[0]
        }</span> else<span class="cov2" title="2"> if len(parts) &gt;= 3 &amp;&amp; parts[1] == "service" </span><span class="cov1" title="1">{
                // service-name.service.consul format
                serviceName = parts[0]
        }</span> else<span class="cov1" title="1"> {
                return
        }</span>

        // Get all healthy services matching the name
        <span class="cov2" title="2">services := s.store.List()

        for _, service := range services </span><span class="cov2" title="2">{
                if service.Name == serviceName </span><span class="cov2" title="2">{
                        a := &amp;dns.A{
                                Hdr: dns.RR_Header{
                                        Name:   question.Name,
                                        Rrtype: dns.TypeA,
                                        Class:  dns.ClassINET,
                                        Ttl:    30,
                                },
                                A: net.ParseIP(service.Address),
                        }
                        msg.Answer = append(msg.Answer, a)
                }</span>
        }

        <span class="cov2" title="2">s.log.Debug("A query processed",
                logger.String("service", serviceName),
                logger.Int("records", len(msg.Answer)))</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "strconv"
        "sync"
        "sync/atomic"

        "github.com/99designs/gqlgen/graphql"
        "github.com/99designs/gqlgen/graphql/introspection"
        "github.com/neogan74/konsul/internal/graphql/model"
        "github.com/neogan74/konsul/internal/graphql/scalar"
        gqlparser "github.com/vektah/gqlparser/v2"
        "github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema <span class="cov0" title="0">{
        return &amp;executableSchema{
                schema:     cfg.Schema,
                resolvers:  cfg.Resolvers,
                directives: cfg.Directives,
                complexity: cfg.Complexity,
        }
}</span>

type Config struct {
        Schema     *ast.Schema
        Resolvers  ResolverRoot
        Directives DirectiveRoot
        Complexity ComplexityRoot
}

type ResolverRoot interface {
        Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
        HealthCheck struct {
                ID          func(childComplexity int) int
                Interval    func(childComplexity int) int
                LastChecked func(childComplexity int) int
                Name        func(childComplexity int) int
                Output      func(childComplexity int) int
                ServiceID   func(childComplexity int) int
                Status      func(childComplexity int) int
                Timeout     func(childComplexity int) int
                Type        func(childComplexity int) int
        }

        KVListResponse struct {
                HasMore func(childComplexity int) int
                Items   func(childComplexity int) int
                Total   func(childComplexity int) int
        }

        KVPair struct {
                CreatedAt func(childComplexity int) int
                Key       func(childComplexity int) int
                UpdatedAt func(childComplexity int) int
                Value     func(childComplexity int) int
        }

        KVStats struct {
                TotalKeys func(childComplexity int) int
        }

        Query struct {
                Health        func(childComplexity int) int
                Kv            func(childComplexity int, key string) int
                KvList        func(childComplexity int, prefix *string, limit *int, offset *int) int
                Service       func(childComplexity int, name string) int
                Services      func(childComplexity int, limit *int, offset *int) int
                ServicesCount func(childComplexity int) int
        }

        Service struct {
                Address   func(childComplexity int) int
                Checks    func(childComplexity int) int
                ExpiresAt func(childComplexity int) int
                Name      func(childComplexity int) int
                Port      func(childComplexity int) int
                Status    func(childComplexity int) int
        }

        ServiceStats struct {
                Active  func(childComplexity int) int
                Expired func(childComplexity int) int
                Total   func(childComplexity int) int
        }

        SystemHealth struct {
                KvStore   func(childComplexity int) int
                Services  func(childComplexity int) int
                Status    func(childComplexity int) int
                Timestamp func(childComplexity int) int
                Uptime    func(childComplexity int) int
                Version   func(childComplexity int) int
        }
}

type QueryResolver interface {
        Health(ctx context.Context) (*model.SystemHealth, error)
        Kv(ctx context.Context, key string) (*model.KVPair, error)
        KvList(ctx context.Context, prefix *string, limit *int, offset *int) (*model.KVListResponse, error)
        Service(ctx context.Context, name string) (*model.Service, error)
        Services(ctx context.Context, limit *int, offset *int) ([]*model.Service, error)
        ServicesCount(ctx context.Context) (int, error)
}

type executableSchema struct {
        schema     *ast.Schema
        resolvers  ResolverRoot
        directives DirectiveRoot
        complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema <span class="cov0" title="0">{
        if e.schema != nil </span><span class="cov0" title="0">{
                return e.schema
        }</span>
        <span class="cov0" title="0">return parsedSchema</span>
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) <span class="cov0" title="0">{
        ec := executionContext{nil, e, 0, 0, nil}
        _ = ec
        switch typeName + "." + field </span>{

        case "HealthCheck.id":<span class="cov0" title="0">
                if e.complexity.HealthCheck.ID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.ID(childComplexity), true</span>
        case "HealthCheck.interval":<span class="cov0" title="0">
                if e.complexity.HealthCheck.Interval == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.Interval(childComplexity), true</span>
        case "HealthCheck.lastChecked":<span class="cov0" title="0">
                if e.complexity.HealthCheck.LastChecked == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.LastChecked(childComplexity), true</span>
        case "HealthCheck.name":<span class="cov0" title="0">
                if e.complexity.HealthCheck.Name == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.Name(childComplexity), true</span>
        case "HealthCheck.output":<span class="cov0" title="0">
                if e.complexity.HealthCheck.Output == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.Output(childComplexity), true</span>
        case "HealthCheck.serviceId":<span class="cov0" title="0">
                if e.complexity.HealthCheck.ServiceID == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.ServiceID(childComplexity), true</span>
        case "HealthCheck.status":<span class="cov0" title="0">
                if e.complexity.HealthCheck.Status == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.Status(childComplexity), true</span>
        case "HealthCheck.timeout":<span class="cov0" title="0">
                if e.complexity.HealthCheck.Timeout == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.Timeout(childComplexity), true</span>
        case "HealthCheck.type":<span class="cov0" title="0">
                if e.complexity.HealthCheck.Type == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.HealthCheck.Type(childComplexity), true</span>

        case "KVListResponse.hasMore":<span class="cov0" title="0">
                if e.complexity.KVListResponse.HasMore == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVListResponse.HasMore(childComplexity), true</span>
        case "KVListResponse.items":<span class="cov0" title="0">
                if e.complexity.KVListResponse.Items == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVListResponse.Items(childComplexity), true</span>
        case "KVListResponse.total":<span class="cov0" title="0">
                if e.complexity.KVListResponse.Total == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVListResponse.Total(childComplexity), true</span>

        case "KVPair.createdAt":<span class="cov0" title="0">
                if e.complexity.KVPair.CreatedAt == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVPair.CreatedAt(childComplexity), true</span>
        case "KVPair.key":<span class="cov0" title="0">
                if e.complexity.KVPair.Key == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVPair.Key(childComplexity), true</span>
        case "KVPair.updatedAt":<span class="cov0" title="0">
                if e.complexity.KVPair.UpdatedAt == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVPair.UpdatedAt(childComplexity), true</span>
        case "KVPair.value":<span class="cov0" title="0">
                if e.complexity.KVPair.Value == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVPair.Value(childComplexity), true</span>

        case "KVStats.totalKeys":<span class="cov0" title="0">
                if e.complexity.KVStats.TotalKeys == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.KVStats.TotalKeys(childComplexity), true</span>

        case "Query.health":<span class="cov0" title="0">
                if e.complexity.Query.Health == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Query.Health(childComplexity), true</span>
        case "Query.kv":<span class="cov0" title="0">
                if e.complexity.Query.Kv == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query_kv_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.Kv(childComplexity, args["key"].(string)), true</span>
        case "Query.kvList":<span class="cov0" title="0">
                if e.complexity.Query.KvList == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query_kvList_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.KvList(childComplexity, args["prefix"].(*string), args["limit"].(*int), args["offset"].(*int)), true</span>
        case "Query.service":<span class="cov0" title="0">
                if e.complexity.Query.Service == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query_service_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.Service(childComplexity, args["name"].(string)), true</span>
        case "Query.services":<span class="cov0" title="0">
                if e.complexity.Query.Services == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">args, err := ec.field_Query_services_args(ctx, rawArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov0" title="0">return e.complexity.Query.Services(childComplexity, args["limit"].(*int), args["offset"].(*int)), true</span>
        case "Query.servicesCount":<span class="cov0" title="0">
                if e.complexity.Query.ServicesCount == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Query.ServicesCount(childComplexity), true</span>

        case "Service.address":<span class="cov0" title="0">
                if e.complexity.Service.Address == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Service.Address(childComplexity), true</span>
        case "Service.checks":<span class="cov0" title="0">
                if e.complexity.Service.Checks == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Service.Checks(childComplexity), true</span>
        case "Service.expiresAt":<span class="cov0" title="0">
                if e.complexity.Service.ExpiresAt == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Service.ExpiresAt(childComplexity), true</span>
        case "Service.name":<span class="cov0" title="0">
                if e.complexity.Service.Name == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Service.Name(childComplexity), true</span>
        case "Service.port":<span class="cov0" title="0">
                if e.complexity.Service.Port == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Service.Port(childComplexity), true</span>
        case "Service.status":<span class="cov0" title="0">
                if e.complexity.Service.Status == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.Service.Status(childComplexity), true</span>

        case "ServiceStats.active":<span class="cov0" title="0">
                if e.complexity.ServiceStats.Active == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.ServiceStats.Active(childComplexity), true</span>
        case "ServiceStats.expired":<span class="cov0" title="0">
                if e.complexity.ServiceStats.Expired == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.ServiceStats.Expired(childComplexity), true</span>
        case "ServiceStats.total":<span class="cov0" title="0">
                if e.complexity.ServiceStats.Total == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.ServiceStats.Total(childComplexity), true</span>

        case "SystemHealth.kvStore":<span class="cov0" title="0">
                if e.complexity.SystemHealth.KvStore == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.SystemHealth.KvStore(childComplexity), true</span>
        case "SystemHealth.services":<span class="cov0" title="0">
                if e.complexity.SystemHealth.Services == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.SystemHealth.Services(childComplexity), true</span>
        case "SystemHealth.status":<span class="cov0" title="0">
                if e.complexity.SystemHealth.Status == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.SystemHealth.Status(childComplexity), true</span>
        case "SystemHealth.timestamp":<span class="cov0" title="0">
                if e.complexity.SystemHealth.Timestamp == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.SystemHealth.Timestamp(childComplexity), true</span>
        case "SystemHealth.uptime":<span class="cov0" title="0">
                if e.complexity.SystemHealth.Uptime == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.SystemHealth.Uptime(childComplexity), true</span>
        case "SystemHealth.version":<span class="cov0" title="0">
                if e.complexity.SystemHealth.Version == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">return e.complexity.SystemHealth.Version(childComplexity), true</span>

        }
        <span class="cov0" title="0">return 0, false</span>
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler <span class="cov0" title="0">{
        opCtx := graphql.GetOperationContext(ctx)
        ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
        inputUnmarshalMap := graphql.BuildUnmarshalerMap()
        first := true

        switch opCtx.Operation.Operation </span>{
        case ast.Query:<span class="cov0" title="0">
                return func(ctx context.Context) *graphql.Response </span><span class="cov0" title="0">{
                        var response graphql.Response
                        var data graphql.Marshaler
                        if first </span><span class="cov0" title="0">{
                                first = false
                                ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
                                data = ec._Query(ctx, opCtx.Operation.SelectionSet)
                        }</span> else<span class="cov0" title="0"> {
                                if atomic.LoadInt32(&amp;ec.pendingDeferred) &gt; 0 </span><span class="cov0" title="0">{
                                        result := &lt;-ec.deferredResults
                                        atomic.AddInt32(&amp;ec.pendingDeferred, -1)
                                        data = result.Result
                                        response.Path = result.Path
                                        response.Label = result.Label
                                        response.Errors = result.Errors
                                }</span> else<span class="cov0" title="0"> {
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">var buf bytes.Buffer
                        data.MarshalGQL(&amp;buf)
                        response.Data = buf.Bytes()
                        if atomic.LoadInt32(&amp;ec.deferred) &gt; 0 </span><span class="cov0" title="0">{
                                hasNext := atomic.LoadInt32(&amp;ec.pendingDeferred) &gt; 0
                                response.HasNext = &amp;hasNext
                        }</span>

                        <span class="cov0" title="0">return &amp;response</span>
                }

        default:<span class="cov0" title="0">
                return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))</span>
        }
}

type executionContext struct {
        *graphql.OperationContext
        *executableSchema
        deferred        int32
        pendingDeferred int32
        deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) <span class="cov0" title="0">{
        atomic.AddInt32(&amp;ec.pendingDeferred, 1)
        go func() </span><span class="cov0" title="0">{
                ctx := graphql.WithFreshResponseContext(dg.Context)
                dg.FieldSet.Dispatch(ctx)
                ds := graphql.DeferredResult{
                        Path:   dg.Path,
                        Label:  dg.Label,
                        Result: dg.FieldSet,
                        Errors: graphql.GetErrors(ctx),
                }
                // null fields should bubble up
                if dg.FieldSet.Invalids &gt; 0 </span><span class="cov0" title="0">{
                        ds.Result = graphql.Null
                }</span>
                <span class="cov0" title="0">ec.deferredResults &lt;- ds</span>
        }()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) <span class="cov0" title="0">{
        if ec.DisableIntrospection </span><span class="cov0" title="0">{
                return nil, errors.New("introspection disabled")
        }</span>
        <span class="cov0" title="0">return introspection.WrapSchema(ec.Schema()), nil</span>
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) <span class="cov0" title="0">{
        if ec.DisableIntrospection </span><span class="cov0" title="0">{
                return nil, errors.New("introspection disabled")
        }</span>
        <span class="cov0" title="0">return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil</span>
}

var sources = []*ast.Source{
        {Name: "../schema/common.graphql", Input: `"""
System health information
"""
type SystemHealth {
  """Overall system status"""
  status: String!

  """Konsul version"""
  version: String!

  """System uptime"""
  uptime: String!

  """Current timestamp"""
  timestamp: Time!

  """Service statistics"""
  services: ServiceStats!

  """KV store statistics"""
  kvStore: KVStats!
}

"""
Service statistics
"""
type ServiceStats {
  """Total registered services"""
  total: Int!

  """Active (non-expired) services"""
  active: Int!

  """Expired services"""
  expired: Int!
}

"""
KV store statistics
"""
type KVStats {
  """Total number of keys"""
  totalKeys: Int!
}

"""
Custom scalar for timestamps
"""
scalar Time

"""
Custom scalar for durations (e.g., "30s", "5m", "2h")
"""
scalar Duration
`, BuiltIn: false},
        {Name: "../schema/kv.graphql", Input: `"""
KVPair represents a key-value pair in the KV store
"""
type KVPair {
  """The key"""
  key: String!

  """The value"""
  value: String!

  """Creation timestamp"""
  createdAt: Time

  """Last modification timestamp"""
  updatedAt: Time
}

"""
Response type for listing KV pairs
"""
type KVListResponse {
  """List of key-value pairs"""
  items: [KVPair!]!

  """Total count of items (useful for pagination)"""
  total: Int!

  """Whether there are more items available"""
  hasMore: Boolean!
}
`, BuiltIn: false},
        {Name: "../schema/schema.graphql", Input: `# Root types
schema {
  query: Query
}

type Query {
  # System information
  health: SystemHealth!

  # KV Store queries
  kv(key: String!): KVPair
  kvList(prefix: String, limit: Int, offset: Int): KVListResponse!

  # Service Discovery queries
  service(name: String!): Service
  services(limit: Int, offset: Int): [Service!]!
  servicesCount: Int!
}
`, BuiltIn: false},
        {Name: "../schema/service.graphql", Input: `"""
Service represents a registered service in the service registry
"""
type Service {
  """Service name (unique identifier)"""
  name: String!

  """Service IP address or hostname"""
  address: String!

  """Service port number"""
  port: Int!

  """Service status"""
  status: ServiceStatus!

  """Expiration timestamp"""
  expiresAt: Time!

  """Health checks associated with this service"""
  checks: [HealthCheck!]!
}

"""
Service status enum
"""
enum ServiceStatus {
  """Service is active and not expired"""
  ACTIVE

  """Service has expired"""
  EXPIRED
}

"""
Health check definition
"""
type HealthCheck {
  """Check ID"""
  id: String!

  """Service ID this check belongs to"""
  serviceId: String!

  """Check name"""
  name: String!

  """Check type (http, tcp, grpc, ttl)"""
  type: HealthCheckType!

  """Current status"""
  status: HealthCheckStatus!

  """Status output/message"""
  output: String

  """Check interval"""
  interval: Duration

  """Check timeout"""
  timeout: Duration

  """Last check time"""
  lastChecked: Time
}

"""
Health check type
"""
enum HealthCheckType {
  HTTP
  TCP
  GRPC
  TTL
}

"""
Health check status
"""
enum HealthCheckStatus {
  PASSING
  WARNING
  CRITICAL
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["name"] = arg0
        return args, nil</span>
}

func (ec *executionContext) field_Query_kvList_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "prefix", ec.unmarshalOString2string)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["prefix"] = arg0
        arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["limit"] = arg1
        arg2, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2int)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["offset"] = arg2
        return args, nil</span>
}

func (ec *executionContext) field_Query_kv_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "key", ec.unmarshalNString2string)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["key"] = arg0
        return args, nil</span>
}

func (ec *executionContext) field_Query_service_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["name"] = arg0
        return args, nil</span>
}

func (ec *executionContext) field_Query_services_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["limit"] = arg0
        arg1, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2int)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["offset"] = arg1
        return args, nil</span>
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) <span class="cov0" title="0">{
        var err error
        args := map[string]any{}
        arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">args["includeDeprecated"] = arg0
        return args, nil</span>
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _HealthCheck_id(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_id,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.ID, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_serviceId(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_serviceId,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.ServiceID, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_serviceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_name(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_name,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Name, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_type(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_type,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Type, nil
                }</span>,
                nil,
                ec.marshalNHealthCheckType2githubcomneogan74konsulinternalgraphqlmodelHealthCheckType,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type HealthCheckType does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_status(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_status,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Status, nil
                }</span>,
                nil,
                ec.marshalNHealthCheckStatus2githubcomneogan74konsulinternalgraphqlmodelHealthCheckStatus,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type HealthCheckStatus does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_output(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_output,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Output, nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_output(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_interval(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_interval,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Interval, nil
                }</span>,
                nil,
                ec.marshalODuration2githubcomneogan74konsulinternalgraphqlscalarDuration,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_interval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Duration does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_timeout(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_timeout,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Timeout, nil
                }</span>,
                nil,
                ec.marshalODuration2githubcomneogan74konsulinternalgraphqlscalarDuration,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_timeout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Duration does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _HealthCheck_lastChecked(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_HealthCheck_lastChecked,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.LastChecked, nil
                }</span>,
                nil,
                ec.marshalOTime2githubcomneogan74konsulinternalgraphqlscalarTime,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_HealthCheck_lastChecked(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "HealthCheck",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Time does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVListResponse_items(ctx context.Context, field graphql.CollectedField, obj *model.KVListResponse) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVListResponse_items,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Items, nil
                }</span>,
                nil,
                ec.marshalNKVPair2githubcomneogan74konsulinternalgraphqlmodelKVPair,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_KVListResponse_items(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVListResponse",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "key":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_key(ctx, field)</span>
                        case "value":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_value(ctx, field)</span>
                        case "createdAt":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_createdAt(ctx, field)</span>
                        case "updatedAt":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_updatedAt(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type KVPair", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVListResponse_total(ctx context.Context, field graphql.CollectedField, obj *model.KVListResponse) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVListResponse_total,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Total, nil
                }</span>,
                nil,
                ec.marshalNInt2int,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_KVListResponse_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVListResponse",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Int does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVListResponse_hasMore(ctx context.Context, field graphql.CollectedField, obj *model.KVListResponse) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVListResponse_hasMore,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.HasMore, nil
                }</span>,
                nil,
                ec.marshalNBoolean2bool,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_KVListResponse_hasMore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVListResponse",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVPair_key(ctx context.Context, field graphql.CollectedField, obj *model.KVPair) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVPair_key,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Key, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_KVPair_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVPair",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVPair_value(ctx context.Context, field graphql.CollectedField, obj *model.KVPair) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVPair_value,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Value, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_KVPair_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVPair",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVPair_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.KVPair) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVPair_createdAt,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.CreatedAt, nil
                }</span>,
                nil,
                ec.marshalOTime2githubcomneogan74konsulinternalgraphqlscalarTime,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_KVPair_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVPair",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Time does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVPair_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.KVPair) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVPair_updatedAt,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.UpdatedAt, nil
                }</span>,
                nil,
                ec.marshalOTime2githubcomneogan74konsulinternalgraphqlscalarTime,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_KVPair_updatedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVPair",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Time does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _KVStats_totalKeys(ctx context.Context, field graphql.CollectedField, obj *model.KVStats) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_KVStats_totalKeys,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.TotalKeys, nil
                }</span>,
                nil,
                ec.marshalNInt2int,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_KVStats_totalKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "KVStats",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Int does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_health(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query_health,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return ec.resolvers.Query().Health(ctx)
                }</span>,
                nil,
                ec.marshalNSystemHealth2githubcomneogan74konsulinternalgraphqlmodelSystemHealth,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Query_health(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "status":<span class="cov0" title="0">
                                return ec.fieldContext_SystemHealth_status(ctx, field)</span>
                        case "version":<span class="cov0" title="0">
                                return ec.fieldContext_SystemHealth_version(ctx, field)</span>
                        case "uptime":<span class="cov0" title="0">
                                return ec.fieldContext_SystemHealth_uptime(ctx, field)</span>
                        case "timestamp":<span class="cov0" title="0">
                                return ec.fieldContext_SystemHealth_timestamp(ctx, field)</span>
                        case "services":<span class="cov0" title="0">
                                return ec.fieldContext_SystemHealth_services(ctx, field)</span>
                        case "kvStore":<span class="cov0" title="0">
                                return ec.fieldContext_SystemHealth_kvStore(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type SystemHealth", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_kv(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query_kv,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        fc := graphql.GetFieldContext(ctx)
                        return ec.resolvers.Query().Kv(ctx, fc.Args["key"].(string))
                }</span>,
                nil,
                ec.marshalOKVPair2githubcomneogan74konsulinternalgraphqlmodelKVPair,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_Query_kv(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "key":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_key(ctx, field)</span>
                        case "value":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_value(ctx, field)</span>
                        case "createdAt":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_createdAt(ctx, field)</span>
                        case "updatedAt":<span class="cov0" title="0">
                                return ec.fieldContext_KVPair_updatedAt(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type KVPair", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query_kv_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_kvList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query_kvList,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        fc := graphql.GetFieldContext(ctx)
                        return ec.resolvers.Query().KvList(ctx, fc.Args["prefix"].(*string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
                }</span>,
                nil,
                ec.marshalNKVListResponse2githubcomneogan74konsulinternalgraphqlmodelKVListResponse,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Query_kvList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "items":<span class="cov0" title="0">
                                return ec.fieldContext_KVListResponse_items(ctx, field)</span>
                        case "total":<span class="cov0" title="0">
                                return ec.fieldContext_KVListResponse_total(ctx, field)</span>
                        case "hasMore":<span class="cov0" title="0">
                                return ec.fieldContext_KVListResponse_hasMore(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type KVListResponse", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query_kvList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_service(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query_service,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        fc := graphql.GetFieldContext(ctx)
                        return ec.resolvers.Query().Service(ctx, fc.Args["name"].(string))
                }</span>,
                nil,
                ec.marshalOService2githubcomneogan74konsulinternalgraphqlmodelService,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_Query_service(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Service_name(ctx, field)</span>
                        case "address":<span class="cov0" title="0">
                                return ec.fieldContext_Service_address(ctx, field)</span>
                        case "port":<span class="cov0" title="0">
                                return ec.fieldContext_Service_port(ctx, field)</span>
                        case "status":<span class="cov0" title="0">
                                return ec.fieldContext_Service_status(ctx, field)</span>
                        case "expiresAt":<span class="cov0" title="0">
                                return ec.fieldContext_Service_expiresAt(ctx, field)</span>
                        case "checks":<span class="cov0" title="0">
                                return ec.fieldContext_Service_checks(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Service", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query_service_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_services(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query_services,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        fc := graphql.GetFieldContext(ctx)
                        return ec.resolvers.Query().Services(ctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int))
                }</span>,
                nil,
                ec.marshalNService2githubcomneogan74konsulinternalgraphqlmodelService,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Query_services(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_Service_name(ctx, field)</span>
                        case "address":<span class="cov0" title="0">
                                return ec.fieldContext_Service_address(ctx, field)</span>
                        case "port":<span class="cov0" title="0">
                                return ec.fieldContext_Service_port(ctx, field)</span>
                        case "status":<span class="cov0" title="0">
                                return ec.fieldContext_Service_status(ctx, field)</span>
                        case "expiresAt":<span class="cov0" title="0">
                                return ec.fieldContext_Service_expiresAt(ctx, field)</span>
                        case "checks":<span class="cov0" title="0">
                                return ec.fieldContext_Service_checks(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type Service", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query_services_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query_servicesCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query_servicesCount,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return ec.resolvers.Query().ServicesCount(ctx)
                }</span>,
                nil,
                ec.marshalNInt2int,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Query_servicesCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: true,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Int does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query___type,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        fc := graphql.GetFieldContext(ctx)
                        return ec.introspectType(fc.Args["name"].(string))
                }</span>,
                nil,
                ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Query___schema,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return ec.introspectSchema()
                }</span>,
                nil,
                ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Query",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_description(ctx, field)</span>
                        case "types":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_types(ctx, field)</span>
                        case "queryType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_queryType(ctx, field)</span>
                        case "mutationType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_mutationType(ctx, field)</span>
                        case "subscriptionType":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_subscriptionType(ctx, field)</span>
                        case "directives":<span class="cov0" title="0">
                                return ec.fieldContext___Schema_directives(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Service_name(ctx context.Context, field graphql.CollectedField, obj *model.Service) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Service_name,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Name, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Service_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Service",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Service_address(ctx context.Context, field graphql.CollectedField, obj *model.Service) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Service_address,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Address, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Service_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Service",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Service_port(ctx context.Context, field graphql.CollectedField, obj *model.Service) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Service_port,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Port, nil
                }</span>,
                nil,
                ec.marshalNInt2int,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Service_port(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Service",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Int does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Service_status(ctx context.Context, field graphql.CollectedField, obj *model.Service) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Service_status,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Status, nil
                }</span>,
                nil,
                ec.marshalNServiceStatus2githubcomneogan74konsulinternalgraphqlmodelServiceStatus,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Service_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Service",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type ServiceStatus does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Service_expiresAt(ctx context.Context, field graphql.CollectedField, obj *model.Service) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Service_expiresAt,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.ExpiresAt, nil
                }</span>,
                nil,
                ec.marshalNTime2githubcomneogan74konsulinternalgraphqlscalarTime,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Service_expiresAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Service",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Time does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _Service_checks(ctx context.Context, field graphql.CollectedField, obj *model.Service) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_Service_checks,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Checks, nil
                }</span>,
                nil,
                ec.marshalNHealthCheck2githubcomneogan74konsulinternalgraphqlmodelHealthCheck,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_Service_checks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "Service",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "id":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_id(ctx, field)</span>
                        case "serviceId":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_serviceId(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_name(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_type(ctx, field)</span>
                        case "status":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_status(ctx, field)</span>
                        case "output":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_output(ctx, field)</span>
                        case "interval":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_interval(ctx, field)</span>
                        case "timeout":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_timeout(ctx, field)</span>
                        case "lastChecked":<span class="cov0" title="0">
                                return ec.fieldContext_HealthCheck_lastChecked(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type HealthCheck", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _ServiceStats_total(ctx context.Context, field graphql.CollectedField, obj *model.ServiceStats) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_ServiceStats_total,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Total, nil
                }</span>,
                nil,
                ec.marshalNInt2int,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_ServiceStats_total(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "ServiceStats",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Int does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _ServiceStats_active(ctx context.Context, field graphql.CollectedField, obj *model.ServiceStats) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_ServiceStats_active,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Active, nil
                }</span>,
                nil,
                ec.marshalNInt2int,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_ServiceStats_active(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "ServiceStats",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Int does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _ServiceStats_expired(ctx context.Context, field graphql.CollectedField, obj *model.ServiceStats) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_ServiceStats_expired,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Expired, nil
                }</span>,
                nil,
                ec.marshalNInt2int,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_ServiceStats_expired(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "ServiceStats",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Int does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _SystemHealth_status(ctx context.Context, field graphql.CollectedField, obj *model.SystemHealth) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_SystemHealth_status,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Status, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_SystemHealth_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "SystemHealth",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _SystemHealth_version(ctx context.Context, field graphql.CollectedField, obj *model.SystemHealth) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_SystemHealth_version,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Version, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_SystemHealth_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "SystemHealth",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _SystemHealth_uptime(ctx context.Context, field graphql.CollectedField, obj *model.SystemHealth) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_SystemHealth_uptime,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Uptime, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_SystemHealth_uptime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "SystemHealth",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _SystemHealth_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.SystemHealth) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_SystemHealth_timestamp,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Timestamp, nil
                }</span>,
                nil,
                ec.marshalNTime2githubcomneogan74konsulinternalgraphqlscalarTime,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_SystemHealth_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "SystemHealth",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Time does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _SystemHealth_services(ctx context.Context, field graphql.CollectedField, obj *model.SystemHealth) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_SystemHealth_services,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Services, nil
                }</span>,
                nil,
                ec.marshalNServiceStats2githubcomneogan74konsulinternalgraphqlmodelServiceStats,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_SystemHealth_services(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "SystemHealth",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "total":<span class="cov0" title="0">
                                return ec.fieldContext_ServiceStats_total(ctx, field)</span>
                        case "active":<span class="cov0" title="0">
                                return ec.fieldContext_ServiceStats_active(ctx, field)</span>
                        case "expired":<span class="cov0" title="0">
                                return ec.fieldContext_ServiceStats_expired(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type ServiceStats", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) _SystemHealth_kvStore(ctx context.Context, field graphql.CollectedField, obj *model.SystemHealth) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext_SystemHealth_kvStore,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.KvStore, nil
                }</span>,
                nil,
                ec.marshalNKVStats2githubcomneogan74konsulinternalgraphqlmodelKVStats,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext_SystemHealth_kvStore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "SystemHealth",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "totalKeys":<span class="cov0" title="0">
                                return ec.fieldContext_KVStats_totalKeys(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type KVStats", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Directive_name,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Name, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Directive_description,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Description(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Directive_isRepeatable,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.IsRepeatable, nil
                }</span>,
                nil,
                ec.marshalNBoolean2bool,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Directive_locations,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Locations, nil
                }</span>,
                nil,
                ec.marshalN__DirectiveLocation2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type __DirectiveLocation does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Directive_args,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Args, nil
                }</span>,
                nil,
                ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Directive",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___EnumValue_name,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Name, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___EnumValue_description,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Description(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___EnumValue_isDeprecated,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.IsDeprecated(), nil
                }</span>,
                nil,
                ec.marshalNBoolean2bool,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___EnumValue_deprecationReason,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.DeprecationReason(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__EnumValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Field_name,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Name, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Field_description,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Description(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Field_args,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Args, nil
                }</span>,
                nil,
                ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Field_type,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Type, nil
                }</span>,
                nil,
                ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Field_isDeprecated,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.IsDeprecated(), nil
                }</span>,
                nil,
                ec.marshalNBoolean2bool,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Field_deprecationReason,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.DeprecationReason(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Field",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___InputValue_name,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Name, nil
                }</span>,
                nil,
                ec.marshalNString2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___InputValue_description,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Description(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___InputValue_type,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Type, nil
                }</span>,
                nil,
                ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___InputValue_defaultValue,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.DefaultValue, nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   false,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___InputValue_isDeprecated,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.IsDeprecated(), nil
                }</span>,
                nil,
                ec.marshalNBoolean2bool,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___InputValue_deprecationReason,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.DeprecationReason(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__InputValue",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Schema_description,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Description(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Schema_types,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Types(), nil
                }</span>,
                nil,
                ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Schema_queryType,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.QueryType(), nil
                }</span>,
                nil,
                ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Schema_mutationType,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.MutationType(), nil
                }</span>,
                nil,
                ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Schema_subscriptionType,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.SubscriptionType(), nil
                }</span>,
                nil,
                ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Schema_directives,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Directives(), nil
                }</span>,
                nil,
                ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Schema",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_description(ctx, field)</span>
                        case "isRepeatable":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_isRepeatable(ctx, field)</span>
                        case "locations":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_locations(ctx, field)</span>
                        case "args":<span class="cov0" title="0">
                                return ec.fieldContext___Directive_args(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_kind,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Kind(), nil
                }</span>,
                nil,
                ec.marshalN__TypeKind2string,
                true,
                true,
        )
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type __TypeKind does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_name,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Name(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_description,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Description(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_specifiedByURL,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.SpecifiedByURL(), nil
                }</span>,
                nil,
                ec.marshalOString2string,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type String does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_fields,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        fc := graphql.GetFieldContext(ctx)
                        return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
                }</span>,
                nil,
                ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Field_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Field_description(ctx, field)</span>
                        case "args":<span class="cov0" title="0">
                                return ec.fieldContext___Field_args(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___Field_type(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___Field_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___Field_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_interfaces,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.Interfaces(), nil
                }</span>,
                nil,
                ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_possibleTypes,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.PossibleTypes(), nil
                }</span>,
                nil,
                ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_enumValues,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        fc := graphql.GetFieldContext(ctx)
                        return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
                }</span>,
                nil,
                ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_description(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___EnumValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = ec.Recover(ctx, r)
                        ec.Error(ctx, err)
                }</span>
        }()
        <span class="cov0" title="0">ctx = graphql.WithFieldContext(ctx, fc)
        if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil </span><span class="cov0" title="0">{
                ec.Error(ctx, err)
                return fc, err
        }</span>
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_inputFields,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.InputFields(), nil
                }</span>,
                nil,
                ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_description(ctx, field)</span>
                        case "type":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_type(ctx, field)</span>
                        case "defaultValue":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_defaultValue(ctx, field)</span>
                        case "isDeprecated":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_isDeprecated(ctx, field)</span>
                        case "deprecationReason":<span class="cov0" title="0">
                                return ec.fieldContext___InputValue_deprecationReason(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_ofType,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.OfType(), nil
                }</span>,
                nil,
                ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        switch field.Name </span>{
                        case "kind":<span class="cov0" title="0">
                                return ec.fieldContext___Type_kind(ctx, field)</span>
                        case "name":<span class="cov0" title="0">
                                return ec.fieldContext___Type_name(ctx, field)</span>
                        case "description":<span class="cov0" title="0">
                                return ec.fieldContext___Type_description(ctx, field)</span>
                        case "specifiedByURL":<span class="cov0" title="0">
                                return ec.fieldContext___Type_specifiedByURL(ctx, field)</span>
                        case "fields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_fields(ctx, field)</span>
                        case "interfaces":<span class="cov0" title="0">
                                return ec.fieldContext___Type_interfaces(ctx, field)</span>
                        case "possibleTypes":<span class="cov0" title="0">
                                return ec.fieldContext___Type_possibleTypes(ctx, field)</span>
                        case "enumValues":<span class="cov0" title="0">
                                return ec.fieldContext___Type_enumValues(ctx, field)</span>
                        case "inputFields":<span class="cov0" title="0">
                                return ec.fieldContext___Type_inputFields(ctx, field)</span>
                        case "ofType":<span class="cov0" title="0">
                                return ec.fieldContext___Type_ofType(ctx, field)</span>
                        case "isOneOf":<span class="cov0" title="0">
                                return ec.fieldContext___Type_isOneOf(ctx, field)</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)</span>
                },
        }
        <span class="cov0" title="0">return fc, nil</span>
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) <span class="cov0" title="0">{
        return graphql.ResolveField(
                ctx,
                ec.OperationContext,
                field,
                ec.fieldContext___Type_isOneOf,
                func(ctx context.Context) (any, error) </span><span class="cov0" title="0">{
                        return obj.IsOneOf(), nil
                }</span>,
                nil,
                ec.marshalOBoolean2bool,
                true,
                false,
        )
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) <span class="cov0" title="0">{
        fc = &amp;graphql.FieldContext{
                Object:     "__Type",
                Field:      field,
                IsMethod:   true,
                IsResolver: false,
                Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("field of type Boolean does not have child fields")
                }</span>,
        }
        <span class="cov0" title="0">return fc, nil</span>
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var healthCheckImplementors = []string{"HealthCheck"}

func (ec *executionContext) _HealthCheck(ctx context.Context, sel ast.SelectionSet, obj *model.HealthCheck) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("HealthCheck")</span>
                case "id":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_id(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "serviceId":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_serviceId(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "type":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_type(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "status":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_status(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "output":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_output(ctx, field, obj)</span>
                case "interval":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_interval(ctx, field, obj)</span>
                case "timeout":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_timeout(ctx, field, obj)</span>
                case "lastChecked":<span class="cov0" title="0">
                        out.Values[i] = ec._HealthCheck_lastChecked(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var kVListResponseImplementors = []string{"KVListResponse"}

func (ec *executionContext) _KVListResponse(ctx context.Context, sel ast.SelectionSet, obj *model.KVListResponse) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, kVListResponseImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("KVListResponse")</span>
                case "items":<span class="cov0" title="0">
                        out.Values[i] = ec._KVListResponse_items(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "total":<span class="cov0" title="0">
                        out.Values[i] = ec._KVListResponse_total(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "hasMore":<span class="cov0" title="0">
                        out.Values[i] = ec._KVListResponse_hasMore(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var kVPairImplementors = []string{"KVPair"}

func (ec *executionContext) _KVPair(ctx context.Context, sel ast.SelectionSet, obj *model.KVPair) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, kVPairImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("KVPair")</span>
                case "key":<span class="cov0" title="0">
                        out.Values[i] = ec._KVPair_key(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "value":<span class="cov0" title="0">
                        out.Values[i] = ec._KVPair_value(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "createdAt":<span class="cov0" title="0">
                        out.Values[i] = ec._KVPair_createdAt(ctx, field, obj)</span>
                case "updatedAt":<span class="cov0" title="0">
                        out.Values[i] = ec._KVPair_updatedAt(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var kVStatsImplementors = []string{"KVStats"}

func (ec *executionContext) _KVStats(ctx context.Context, sel ast.SelectionSet, obj *model.KVStats) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, kVStatsImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("KVStats")</span>
                case "totalKeys":<span class="cov0" title="0">
                        out.Values[i] = ec._KVStats_totalKeys(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
        ctx = graphql.WithFieldContext(ctx, &amp;graphql.FieldContext{
                Object: "Query",
        })

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                innerCtx := graphql.WithRootFieldContext(ctx, &amp;graphql.RootFieldContext{
                        Object: field.Name,
                        Field:  field,
                })

                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Query")</span>
                case "health":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_health(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "kv":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_kv(ctx, field)
                                return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "kvList":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_kvList(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "service":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_service(ctx, field)
                                return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "services":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_services(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "servicesCount":<span class="cov0" title="0">
                        field := field

                        innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                ec.Error(ctx, ec.Recover(ctx, r))
                                        }</span>
                                }()
                                <span class="cov0" title="0">res = ec._Query_servicesCount(ctx, field)
                                if res == graphql.Null </span><span class="cov0" title="0">{
                                        atomic.AddUint32(&amp;fs.Invalids, 1)
                                }</span>
                                <span class="cov0" title="0">return res</span>
                        }

                        <span class="cov0" title="0">rrm := func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{
                                return ec.OperationContext.RootResolverMiddleware(ctx,
                                        func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return innerFunc(ctx, out) }</span>)
                        }

                        <span class="cov0" title="0">out.Concurrently(i, func(ctx context.Context) graphql.Marshaler </span><span class="cov0" title="0">{ return rrm(innerCtx) }</span>)
                case "__type":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Query___type(ctx, field)
                        }</span>)
                case "__schema":<span class="cov0" title="0">
                        out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) </span><span class="cov0" title="0">{
                                return ec._Query___schema(ctx, field)
                        }</span>)
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var serviceImplementors = []string{"Service"}

func (ec *executionContext) _Service(ctx context.Context, sel ast.SelectionSet, obj *model.Service) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, serviceImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("Service")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec._Service_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "address":<span class="cov0" title="0">
                        out.Values[i] = ec._Service_address(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "port":<span class="cov0" title="0">
                        out.Values[i] = ec._Service_port(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "status":<span class="cov0" title="0">
                        out.Values[i] = ec._Service_status(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "expiresAt":<span class="cov0" title="0">
                        out.Values[i] = ec._Service_expiresAt(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "checks":<span class="cov0" title="0">
                        out.Values[i] = ec._Service_checks(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var serviceStatsImplementors = []string{"ServiceStats"}

func (ec *executionContext) _ServiceStats(ctx context.Context, sel ast.SelectionSet, obj *model.ServiceStats) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, serviceStatsImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("ServiceStats")</span>
                case "total":<span class="cov0" title="0">
                        out.Values[i] = ec._ServiceStats_total(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "active":<span class="cov0" title="0">
                        out.Values[i] = ec._ServiceStats_active(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "expired":<span class="cov0" title="0">
                        out.Values[i] = ec._ServiceStats_expired(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var systemHealthImplementors = []string{"SystemHealth"}

func (ec *executionContext) _SystemHealth(ctx context.Context, sel ast.SelectionSet, obj *model.SystemHealth) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, systemHealthImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("SystemHealth")</span>
                case "status":<span class="cov0" title="0">
                        out.Values[i] = ec._SystemHealth_status(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "version":<span class="cov0" title="0">
                        out.Values[i] = ec._SystemHealth_version(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "uptime":<span class="cov0" title="0">
                        out.Values[i] = ec._SystemHealth_uptime(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "timestamp":<span class="cov0" title="0">
                        out.Values[i] = ec._SystemHealth_timestamp(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "services":<span class="cov0" title="0">
                        out.Values[i] = ec._SystemHealth_services(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "kvStore":<span class="cov0" title="0">
                        out.Values[i] = ec._SystemHealth_kvStore(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Directive")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_description(ctx, field, obj)</span>
                case "isRepeatable":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "locations":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_locations(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "args":<span class="cov0" title="0">
                        out.Values[i] = ec.___Directive_args(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__EnumValue")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_description(ctx, field, obj)</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Field")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_description(ctx, field, obj)</span>
                case "args":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_args(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "type":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_type(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__InputValue")</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_name(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_description(ctx, field, obj)</span>
                case "type":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_type(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "defaultValue":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)</span>
                case "isDeprecated":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "deprecationReason":<span class="cov0" title="0">
                        out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Schema")</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_description(ctx, field, obj)</span>
                case "types":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_types(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "queryType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "mutationType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)</span>
                case "subscriptionType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)</span>
                case "directives":<span class="cov0" title="0">
                        out.Values[i] = ec.___Schema_directives(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

        out := graphql.NewFieldSet(fields)
        deferred := make(map[string]*graphql.FieldSet)
        for i, field := range fields </span><span class="cov0" title="0">{
                switch field.Name </span>{
                case "__typename":<span class="cov0" title="0">
                        out.Values[i] = graphql.MarshalString("__Type")</span>
                case "kind":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_kind(ctx, field, obj)
                        if out.Values[i] == graphql.Null </span><span class="cov0" title="0">{
                                out.Invalids++
                        }</span>
                case "name":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_name(ctx, field, obj)</span>
                case "description":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_description(ctx, field, obj)</span>
                case "specifiedByURL":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)</span>
                case "fields":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_fields(ctx, field, obj)</span>
                case "interfaces":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_interfaces(ctx, field, obj)</span>
                case "possibleTypes":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)</span>
                case "enumValues":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_enumValues(ctx, field, obj)</span>
                case "inputFields":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_inputFields(ctx, field, obj)</span>
                case "ofType":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_ofType(ctx, field, obj)</span>
                case "isOneOf":<span class="cov0" title="0">
                        out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)</span>
                default:<span class="cov0" title="0">
                        panic("unknown field " + strconv.Quote(field.Name))</span>
                }
        }
        <span class="cov0" title="0">out.Dispatch(ctx)
        if out.Invalids &gt; 0 </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>

        <span class="cov0" title="0">atomic.AddInt32(&amp;ec.deferred, int32(len(deferred)))

        for label, dfs := range deferred </span><span class="cov0" title="0">{
                ec.processDeferredGroup(graphql.DeferredGroup{
                        Label:    label,
                        Path:     graphql.GetPath(ctx),
                        FieldSet: dfs,
                        Context:  ctx,
                })
        }</span>

        <span class="cov0" title="0">return out</span>
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalBoolean(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalBoolean(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) marshalNHealthCheck2githubcomneogan74konsulinternalgraphqlmodelHealthCheck(ctx context.Context, sel ast.SelectionSet, v []*model.HealthCheck) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalNHealthCheck2githubcomneogan74konsulinternalgraphqlmodelHealthCheck(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalNHealthCheck2githubcomneogan74konsulinternalgraphqlmodelHealthCheck(ctx context.Context, sel ast.SelectionSet, v *model.HealthCheck) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._HealthCheck(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalNHealthCheckStatus2githubcomneogan74konsulinternalgraphqlmodelHealthCheckStatus(ctx context.Context, v any) (model.HealthCheckStatus, error) <span class="cov0" title="0">{
        var res model.HealthCheckStatus
        err := res.UnmarshalGQL(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNHealthCheckStatus2githubcomneogan74konsulinternalgraphqlmodelHealthCheckStatus(ctx context.Context, sel ast.SelectionSet, v model.HealthCheckStatus) graphql.Marshaler <span class="cov0" title="0">{
        return v
}</span>

func (ec *executionContext) unmarshalNHealthCheckType2githubcomneogan74konsulinternalgraphqlmodelHealthCheckType(ctx context.Context, v any) (model.HealthCheckType, error) <span class="cov0" title="0">{
        var res model.HealthCheckType
        err := res.UnmarshalGQL(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNHealthCheckType2githubcomneogan74konsulinternalgraphqlmodelHealthCheckType(ctx context.Context, sel ast.SelectionSet, v model.HealthCheckType) graphql.Marshaler <span class="cov0" title="0">{
        return v
}</span>

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalInt(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalInt(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) marshalNKVListResponse2githubcomneogan74konsulinternalgraphqlmodelKVListResponse(ctx context.Context, sel ast.SelectionSet, v model.KVListResponse) graphql.Marshaler <span class="cov0" title="0">{
        return ec._KVListResponse(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalNKVListResponse2githubcomneogan74konsulinternalgraphqlmodelKVListResponse(ctx context.Context, sel ast.SelectionSet, v *model.KVListResponse) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._KVListResponse(ctx, sel, v)</span>
}

func (ec *executionContext) marshalNKVPair2githubcomneogan74konsulinternalgraphqlmodelKVPair(ctx context.Context, sel ast.SelectionSet, v []*model.KVPair) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalNKVPair2githubcomneogan74konsulinternalgraphqlmodelKVPair(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalNKVPair2githubcomneogan74konsulinternalgraphqlmodelKVPair(ctx context.Context, sel ast.SelectionSet, v *model.KVPair) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._KVPair(ctx, sel, v)</span>
}

func (ec *executionContext) marshalNKVStats2githubcomneogan74konsulinternalgraphqlmodelKVStats(ctx context.Context, sel ast.SelectionSet, v *model.KVStats) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._KVStats(ctx, sel, v)</span>
}

func (ec *executionContext) marshalNService2githubcomneogan74konsulinternalgraphqlmodelService(ctx context.Context, sel ast.SelectionSet, v []*model.Service) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalNService2githubcomneogan74konsulinternalgraphqlmodelService(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalNService2githubcomneogan74konsulinternalgraphqlmodelService(ctx context.Context, sel ast.SelectionSet, v *model.Service) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._Service(ctx, sel, v)</span>
}

func (ec *executionContext) marshalNServiceStats2githubcomneogan74konsulinternalgraphqlmodelServiceStats(ctx context.Context, sel ast.SelectionSet, v *model.ServiceStats) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._ServiceStats(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalNServiceStatus2githubcomneogan74konsulinternalgraphqlmodelServiceStatus(ctx context.Context, v any) (model.ServiceStatus, error) <span class="cov0" title="0">{
        var res model.ServiceStatus
        err := res.UnmarshalGQL(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNServiceStatus2githubcomneogan74konsulinternalgraphqlmodelServiceStatus(ctx context.Context, sel ast.SelectionSet, v model.ServiceStatus) graphql.Marshaler <span class="cov0" title="0">{
        return v
}</span>

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) marshalNSystemHealth2githubcomneogan74konsulinternalgraphqlmodelSystemHealth(ctx context.Context, sel ast.SelectionSet, v model.SystemHealth) graphql.Marshaler <span class="cov0" title="0">{
        return ec._SystemHealth(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalNSystemHealth2githubcomneogan74konsulinternalgraphqlmodelSystemHealth(ctx context.Context, sel ast.SelectionSet, v *model.SystemHealth) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec._SystemHealth(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalNTime2githubcomneogan74konsulinternalgraphqlscalarTime(ctx context.Context, v any) (scalar.Time, error) <span class="cov0" title="0">{
        var res scalar.Time
        err := res.UnmarshalGQL(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalNTime2githubcomneogan74konsulinternalgraphqlscalarTime(ctx context.Context, sel ast.SelectionSet, v scalar.Time) graphql.Marshaler <span class="cov0" title="0">{
        return v
}</span>

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Directive(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) <span class="cov0" title="0">{
        var vSlice []any
        vSlice = graphql.CoerceList(v)
        var err error
        res := make([]string, len(vSlice))
        for i := range vSlice </span><span class="cov0" title="0">{
                ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
                res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return res, nil</span>
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___EnumValue(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Field(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___InputValue(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        return ec.___Type(ctx, sel, &amp;v)
}</span>

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
                <span class="cov0" title="0">return graphql.Null</span>
        }
        <span class="cov0" title="0">return ec.___Type(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalString(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        res := graphql.MarshalString(v)
        if res == graphql.Null </span><span class="cov0" title="0">{
                if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) </span><span class="cov0" title="0">{
                        ec.Errorf(ctx, "the requested element is null which the schema does not allow")
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) <span class="cov0" title="0">{
        res, err := graphql.UnmarshalBoolean(v)
        return res, graphql.ErrorOnPath(ctx, err)
}</span>

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler <span class="cov0" title="0">{
        _ = sel
        _ = ctx
        res := graphql.MarshalBoolean(v)
        return res
}</span>

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res, err := graphql.UnmarshalBoolean(v)
        return &amp;res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">_ = sel
        _ = ctx
        res := graphql.MarshalBoolean(*v)
        return res</span>
}

func (ec *executionContext) unmarshalODuration2githubcomneogan74konsulinternalgraphqlscalarDuration(ctx context.Context, v any) (*scalar.Duration, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var res = new(scalar.Duration)
        err := res.UnmarshalGQL(v)
        return res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalODuration2githubcomneogan74konsulinternalgraphqlscalarDuration(ctx context.Context, sel ast.SelectionSet, v *scalar.Duration) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return v</span>
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res, err := graphql.UnmarshalInt(v)
        return &amp;res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">_ = sel
        _ = ctx
        res := graphql.MarshalInt(*v)
        return res</span>
}

func (ec *executionContext) marshalOKVPair2githubcomneogan74konsulinternalgraphqlmodelKVPair(ctx context.Context, sel ast.SelectionSet, v *model.KVPair) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec._KVPair(ctx, sel, v)</span>
}

func (ec *executionContext) marshalOService2githubcomneogan74konsulinternalgraphqlmodelService(ctx context.Context, sel ast.SelectionSet, v *model.Service) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec._Service(ctx, sel, v)</span>
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">res, err := graphql.UnmarshalString(v)
        return &amp;res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">_ = sel
        _ = ctx
        res := graphql.MarshalString(*v)
        return res</span>
}

func (ec *executionContext) unmarshalOTime2githubcomneogan74konsulinternalgraphqlscalarTime(ctx context.Context, v any) (*scalar.Time, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var res = new(scalar.Time)
        err := res.UnmarshalGQL(v)
        return res, graphql.ErrorOnPath(ctx, err)</span>
}

func (ec *executionContext) marshalOTime2githubcomneogan74konsulinternalgraphqlscalarTime(ctx context.Context, sel ast.SelectionSet, v *scalar.Time) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return v</span>
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec.___Schema(ctx, sel, v)</span>
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">ret := make(graphql.Array, len(v))
        var wg sync.WaitGroup
        isLen1 := len(v) == 1
        if !isLen1 </span><span class="cov0" title="0">{
                wg.Add(len(v))
        }</span>
        <span class="cov0" title="0">for i := range v </span><span class="cov0" title="0">{
                i := i
                fc := &amp;graphql.FieldContext{
                        Index:  &amp;i,
                        Result: &amp;v[i],
                }
                ctx := graphql.WithFieldContext(ctx, fc)
                f := func(i int) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        ec.Error(ctx, ec.Recover(ctx, r))
                                        ret = nil
                                }</span>
                        }()
                        <span class="cov0" title="0">if !isLen1 </span><span class="cov0" title="0">{
                                defer wg.Done()
                        }</span>
                        <span class="cov0" title="0">ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])</span>
                }
                <span class="cov0" title="0">if isLen1 </span><span class="cov0" title="0">{
                        f(i)
                }</span> else<span class="cov0" title="0"> {
                        go f(i)
                }</span>

        }
        <span class="cov0" title="0">wg.Wait()

        for _, e := range ret </span><span class="cov0" title="0">{
                if e == graphql.Null </span><span class="cov0" title="0">{
                        return graphql.Null
                }</span>
        }

        <span class="cov0" title="0">return ret</span>
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return graphql.Null
        }</span>
        <span class="cov0" title="0">return ec.___Type(ctx, sel, v)</span>
}

// endregion ***************************** type.gotpl *****************************
</pre>
		
		<pre class="file" id="file18" style="display: none">package model

import (
        "time"

        "github.com/neogan74/konsul/internal/graphql/scalar"
        "github.com/neogan74/konsul/internal/healthcheck"
        "github.com/neogan74/konsul/internal/store"
)

// MapKVPairFromStore converts store data to GraphQL KVPair model
func MapKVPairFromStore(key, value string) *KVPair <span class="cov0" title="0">{
        now := scalar.FromTime(time.Now())
        return &amp;KVPair{
                Key:       key,
                Value:     value,
                CreatedAt: &amp;now,
                UpdatedAt: &amp;now,
        }
}</span>

// MapServiceFromStore converts store.Service to GraphQL Service model
func MapServiceFromStore(svc store.Service, entry store.ServiceEntry) *Service <span class="cov0" title="0">{
        status := ServiceStatusActive
        if entry.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                status = ServiceStatusExpired
        }</span>

        <span class="cov0" title="0">expiresAt := scalar.FromTime(entry.ExpiresAt)

        return &amp;Service{
                Name:      svc.Name,
                Address:   svc.Address,
                Port:      svc.Port,
                Status:    status,
                ExpiresAt: expiresAt,
                Checks:    []*HealthCheck{}, // Will be populated by resolver
        }</span>
}

// MapHealthCheckFromStore converts healthcheck.Check to GraphQL HealthCheck model
func MapHealthCheckFromStore(check *healthcheck.Check) *HealthCheck <span class="cov0" title="0">{
        checkType := mapCheckType(check.Type)
        checkStatus := mapCheckStatus(check.Status)

        var lastChecked *scalar.Time
        if !check.LastCheck.IsZero() </span><span class="cov0" title="0">{
                t := scalar.FromTime(check.LastCheck)
                lastChecked = &amp;t
        }</span>

        <span class="cov0" title="0">var interval, timeout *scalar.Duration
        if check.Interval &gt; 0 </span><span class="cov0" title="0">{
                i := scalar.FromDuration(check.Interval)
                interval = &amp;i
        }</span>
        <span class="cov0" title="0">if check.Timeout &gt; 0 </span><span class="cov0" title="0">{
                t := scalar.FromDuration(check.Timeout)
                timeout = &amp;t
        }</span>

        <span class="cov0" title="0">return &amp;HealthCheck{
                ID:          check.ID,
                ServiceID:   check.ServiceID,
                Name:        check.Name,
                Type:        checkType,
                Status:      checkStatus,
                Output:      &amp;check.Output,
                Interval:    interval,
                Timeout:     timeout,
                LastChecked: lastChecked,
        }</span>
}

// mapCheckType converts healthcheck.CheckType to GraphQL HealthCheckType
func mapCheckType(checkType healthcheck.CheckType) HealthCheckType <span class="cov0" title="0">{
        switch checkType </span>{
        case healthcheck.CheckTypeHTTP:<span class="cov0" title="0">
                return HealthCheckTypeHTTP</span>
        case healthcheck.CheckTypeTCP:<span class="cov0" title="0">
                return HealthCheckTypeTCP</span>
        case healthcheck.CheckTypeGRPC:<span class="cov0" title="0">
                return HealthCheckTypeGrpc</span>
        case healthcheck.CheckTypeTTL:<span class="cov0" title="0">
                return HealthCheckTypeTTL</span>
        default:<span class="cov0" title="0">
                return HealthCheckTypeHTTP</span> // default
        }
}

// mapCheckStatus converts healthcheck.Status to GraphQL HealthCheckStatus
func mapCheckStatus(status healthcheck.Status) HealthCheckStatus <span class="cov0" title="0">{
        switch status </span>{
        case healthcheck.StatusPassing:<span class="cov0" title="0">
                return HealthCheckStatusPassing</span>
        case healthcheck.StatusWarning:<span class="cov0" title="0">
                return HealthCheckStatusWarning</span>
        case healthcheck.StatusCritical:<span class="cov0" title="0">
                return HealthCheckStatusCritical</span>
        default:<span class="cov0" title="0">
                return HealthCheckStatusCritical</span> // default to critical for safety
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
        "bytes"
        "fmt"
        "io"
        "strconv"

        "github.com/neogan74/konsul/internal/graphql/scalar"
)

// Health check definition
type HealthCheck struct {
        // Check ID
        ID string `json:"id"`
        // Service ID this check belongs to
        ServiceID string `json:"serviceId"`
        // Check name
        Name string `json:"name"`
        // Check type (http, tcp, grpc, ttl)
        Type HealthCheckType `json:"type"`
        // Current status
        Status HealthCheckStatus `json:"status"`
        // Status output/message
        Output *string `json:"output,omitempty"`
        // Check interval
        Interval *scalar.Duration `json:"interval,omitempty"`
        // Check timeout
        Timeout *scalar.Duration `json:"timeout,omitempty"`
        // Last check time
        LastChecked *scalar.Time `json:"lastChecked,omitempty"`
}

// Response type for listing KV pairs
type KVListResponse struct {
        // List of key-value pairs
        Items []*KVPair `json:"items"`
        // Total count of items (useful for pagination)
        Total int `json:"total"`
        // Whether there are more items available
        HasMore bool `json:"hasMore"`
}

// KVPair represents a key-value pair in the KV store
type KVPair struct {
        // The key
        Key string `json:"key"`
        // The value
        Value string `json:"value"`
        // Creation timestamp
        CreatedAt *scalar.Time `json:"createdAt,omitempty"`
        // Last modification timestamp
        UpdatedAt *scalar.Time `json:"updatedAt,omitempty"`
}

// KV store statistics
type KVStats struct {
        // Total number of keys
        TotalKeys int `json:"totalKeys"`
}

type Query struct {
}

// Service represents a registered service in the service registry
type Service struct {
        // Service name (unique identifier)
        Name string `json:"name"`
        // Service IP address or hostname
        Address string `json:"address"`
        // Service port number
        Port int `json:"port"`
        // Service status
        Status ServiceStatus `json:"status"`
        // Expiration timestamp
        ExpiresAt scalar.Time `json:"expiresAt"`
        // Health checks associated with this service
        Checks []*HealthCheck `json:"checks"`
}

// Service statistics
type ServiceStats struct {
        // Total registered services
        Total int `json:"total"`
        // Active (non-expired) services
        Active int `json:"active"`
        // Expired services
        Expired int `json:"expired"`
}

// System health information
type SystemHealth struct {
        // Overall system status
        Status string `json:"status"`
        // Konsul version
        Version string `json:"version"`
        // System uptime
        Uptime string `json:"uptime"`
        // Current timestamp
        Timestamp scalar.Time `json:"timestamp"`
        // Service statistics
        Services *ServiceStats `json:"services"`
        // KV store statistics
        KvStore *KVStats `json:"kvStore"`
}

// Health check status
type HealthCheckStatus string

const (
        HealthCheckStatusPassing  HealthCheckStatus = "PASSING"
        HealthCheckStatusWarning  HealthCheckStatus = "WARNING"
        HealthCheckStatusCritical HealthCheckStatus = "CRITICAL"
)

var AllHealthCheckStatus = []HealthCheckStatus{
        HealthCheckStatusPassing,
        HealthCheckStatusWarning,
        HealthCheckStatusCritical,
}

func (e HealthCheckStatus) IsValid() bool <span class="cov0" title="0">{
        switch e </span>{
        case HealthCheckStatusPassing, HealthCheckStatusWarning, HealthCheckStatusCritical:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (e HealthCheckStatus) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

func (e *HealthCheckStatus) UnmarshalGQL(v any) error <span class="cov0" title="0">{
        str, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("enums must be strings")
        }</span>

        <span class="cov0" title="0">*e = HealthCheckStatus(str)
        if !e.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not a valid HealthCheckStatus", str)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (e HealthCheckStatus) MarshalGQL(w io.Writer) <span class="cov0" title="0">{
        fmt.Fprint(w, strconv.Quote(e.String()))
}</span>

func (e *HealthCheckStatus) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        s, err := strconv.Unquote(string(b))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return e.UnmarshalGQL(s)</span>
}

func (e HealthCheckStatus) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        e.MarshalGQL(&amp;buf)
        return buf.Bytes(), nil
}</span>

// Health check type
type HealthCheckType string

const (
        HealthCheckTypeHTTP HealthCheckType = "HTTP"
        HealthCheckTypeTCP  HealthCheckType = "TCP"
        HealthCheckTypeGrpc HealthCheckType = "GRPC"
        HealthCheckTypeTTL  HealthCheckType = "TTL"
)

var AllHealthCheckType = []HealthCheckType{
        HealthCheckTypeHTTP,
        HealthCheckTypeTCP,
        HealthCheckTypeGrpc,
        HealthCheckTypeTTL,
}

func (e HealthCheckType) IsValid() bool <span class="cov0" title="0">{
        switch e </span>{
        case HealthCheckTypeHTTP, HealthCheckTypeTCP, HealthCheckTypeGrpc, HealthCheckTypeTTL:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (e HealthCheckType) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

func (e *HealthCheckType) UnmarshalGQL(v any) error <span class="cov0" title="0">{
        str, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("enums must be strings")
        }</span>

        <span class="cov0" title="0">*e = HealthCheckType(str)
        if !e.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not a valid HealthCheckType", str)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (e HealthCheckType) MarshalGQL(w io.Writer) <span class="cov0" title="0">{
        fmt.Fprint(w, strconv.Quote(e.String()))
}</span>

func (e *HealthCheckType) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        s, err := strconv.Unquote(string(b))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return e.UnmarshalGQL(s)</span>
}

func (e HealthCheckType) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        e.MarshalGQL(&amp;buf)
        return buf.Bytes(), nil
}</span>

// Service status enum
type ServiceStatus string

const (
        // Service is active and not expired
        ServiceStatusActive ServiceStatus = "ACTIVE"
        // Service has expired
        ServiceStatusExpired ServiceStatus = "EXPIRED"
)

var AllServiceStatus = []ServiceStatus{
        ServiceStatusActive,
        ServiceStatusExpired,
}

func (e ServiceStatus) IsValid() bool <span class="cov0" title="0">{
        switch e </span>{
        case ServiceStatusActive, ServiceStatusExpired:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (e ServiceStatus) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

func (e *ServiceStatus) UnmarshalGQL(v any) error <span class="cov0" title="0">{
        str, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("enums must be strings")
        }</span>

        <span class="cov0" title="0">*e = ServiceStatus(str)
        if !e.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not a valid ServiceStatus", str)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (e ServiceStatus) MarshalGQL(w io.Writer) <span class="cov0" title="0">{
        fmt.Fprint(w, strconv.Quote(e.String()))
}</span>

func (e *ServiceStatus) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        s, err := strconv.Unquote(string(b))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return e.UnmarshalGQL(s)</span>
}

func (e ServiceStatus) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        e.MarshalGQL(&amp;buf)
        return buf.Bytes(), nil
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package resolver

import (
        "time"

        "github.com/neogan74/konsul/internal/acl"
        "github.com/neogan74/konsul/internal/auth"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/store"
)

// This file will not be regenerated automatically.
//
// It serves as dependency injection for your app, add any dependencies you require here.

// Resolver is the root resolver
type Resolver struct {
        kvStore      *store.KVStore
        serviceStore *store.ServiceStore
        aclEvaluator *acl.Evaluator
        jwtService   *auth.JWTService
        logger       logger.Logger
        version      string
        startTime    time.Time
}

// NewResolver creates a new resolver
func NewResolver(deps ResolverDependencies) *Resolver <span class="cov0" title="0">{
        return &amp;Resolver{
                kvStore:      deps.KVStore,
                serviceStore: deps.ServiceStore,
                aclEvaluator: deps.ACLEvaluator,
                jwtService:   deps.JWTService,
                logger:       deps.Logger,
                version:      deps.Version,
                startTime:    time.Now(),
        }
}</span>

// ResolverDependencies holds all dependencies for resolvers
type ResolverDependencies struct {
        KVStore      *store.KVStore
        ServiceStore *store.ServiceStore
        ACLEvaluator *acl.Evaluator
        JWTService   *auth.JWTService
        Logger       logger.Logger
        Version      string
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/neogan74/konsul/internal/graphql/generated"
        "github.com/neogan74/konsul/internal/graphql/model"
        "github.com/neogan74/konsul/internal/graphql/scalar"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/store"
)

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.SystemHealth, error) <span class="cov0" title="0">{
        // No auth required for health endpoint (public)

        // Get service stats
        allEntries := r.serviceStore.ListAll()
        activeServices := r.serviceStore.List()
        expiredCount := len(allEntries) - len(activeServices)

        // Get KV stats
        allKeys := r.kvStore.List()

        // Calculate uptime
        uptime := fmt.Sprintf("%v", time.Since(r.startTime).Round(time.Second))

        timestamp := scalar.FromTime(time.Now())

        return &amp;model.SystemHealth{
                Status:    "healthy",
                Version:   r.version,
                Uptime:    uptime,
                Timestamp: timestamp,
                Services: &amp;model.ServiceStats{
                        Total:   len(allEntries),
                        Active:  len(activeServices),
                        Expired: expiredCount,
                },
                KvStore: &amp;model.KVStats{
                        TotalKeys: len(allKeys),
                },
        }, nil
}</span>

// Kv is the resolver for the kv field.
func (r *queryResolver) Kv(ctx context.Context, key string) (*model.KVPair, error) <span class="cov0" title="0">{
        // Check authentication if required
        // TODO: Add authentication check when auth middleware is implemented

        // Check ACL permissions if enabled
        // TODO: Add ACL check when ACL middleware is implemented

        // Fetch from store
        value, exists := r.kvStore.Get(key)
        if !exists </span><span class="cov0" title="0">{
                return nil, nil // Return nil for not found (nullable field)
        }</span>

        <span class="cov0" title="0">r.logger.Debug("GraphQL: fetched KV pair",
                logger.String("key", key))

        return model.MapKVPairFromStore(key, value), nil</span>
}

// KvList is the resolver for the kvList field.
func (r *queryResolver) KvList(ctx context.Context, prefix *string, limit *int, offset *int) (*model.KVListResponse, error) <span class="cov0" title="0">{
        // Check authentication
        // TODO: Add authentication check when auth middleware is implemented

        // Get all keys
        allKeys := r.kvStore.List()

        // Filter by prefix if provided
        var filteredKeys []string
        if prefix != nil &amp;&amp; *prefix != "" </span><span class="cov0" title="0">{
                for _, key := range allKeys </span><span class="cov0" title="0">{
                        if strings.HasPrefix(key, *prefix) </span><span class="cov0" title="0">{
                                filteredKeys = append(filteredKeys, key)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                filteredKeys = allKeys
        }</span>

        <span class="cov0" title="0">total := len(filteredKeys)

        // Apply pagination
        start := 0
        if offset != nil </span><span class="cov0" title="0">{
                start = *offset
                if start &gt; total </span><span class="cov0" title="0">{
                        start = total
                }</span>
        }

        <span class="cov0" title="0">end := total
        if limit != nil </span><span class="cov0" title="0">{
                end = start + *limit
                if end &gt; total </span><span class="cov0" title="0">{
                        end = total
                }</span>
        }

        <span class="cov0" title="0">paginatedKeys := filteredKeys[start:end]

        // Build response
        items := make([]*model.KVPair, 0, len(paginatedKeys))
        for _, key := range paginatedKeys </span><span class="cov0" title="0">{
                if value, exists := r.kvStore.Get(key); exists </span><span class="cov0" title="0">{
                        // TODO: Check ACL for each key if enabled
                        items = append(items, model.MapKVPairFromStore(key, value))
                }</span>
        }

        <span class="cov0" title="0">r.logger.Debug("GraphQL: listed KV pairs",
                logger.String("prefix", stringOrEmpty(prefix)),
                logger.Int("total", total),
                logger.Int("returned", len(items)))

        return &amp;model.KVListResponse{
                Items:   items,
                Total:   total,
                HasMore: end &lt; total,
        }, nil</span>
}

// Service is the resolver for the service field.
func (r *queryResolver) Service(ctx context.Context, name string) (*model.Service, error) <span class="cov0" title="0">{
        // Check authentication
        // TODO: Add authentication check when auth middleware is implemented

        // Check ACL
        // TODO: Add ACL check when ACL middleware is implemented

        // Get all entries to find the one with expiration info
        entries := r.serviceStore.ListAll()
        var entry *store.ServiceEntry
        for _, e := range entries </span><span class="cov0" title="0">{
                if e.Service.Name == name </span><span class="cov0" title="0">{
                        entry = &amp;e
                        break</span>
                }
        }

        <span class="cov0" title="0">if entry == nil </span><span class="cov0" title="0">{
                return nil, nil // Return nil for not found
        }</span>

        <span class="cov0" title="0">r.logger.Debug("GraphQL: fetched service",
                logger.String("name", name))

        return model.MapServiceFromStore(entry.Service, *entry), nil</span>
}

// Services is the resolver for the services field.
func (r *queryResolver) Services(ctx context.Context, limit *int, offset *int) ([]*model.Service, error) <span class="cov0" title="0">{
        // Check authentication
        // TODO: Add authentication check when auth middleware is implemented

        // Get all services
        entries := r.serviceStore.ListAll()

        // Apply pagination
        start := 0
        if offset != nil </span><span class="cov0" title="0">{
                start = *offset
                if start &gt; len(entries) </span><span class="cov0" title="0">{
                        start = len(entries)
                }</span>
        }

        <span class="cov0" title="0">end := len(entries)
        if limit != nil </span><span class="cov0" title="0">{
                end = start + *limit
                if end &gt; len(entries) </span><span class="cov0" title="0">{
                        end = len(entries)
                }</span>
        }

        <span class="cov0" title="0">paginatedEntries := entries[start:end]

        // Map to GraphQL models
        services := make([]*model.Service, 0, len(paginatedEntries))
        for _, entry := range paginatedEntries </span><span class="cov0" title="0">{
                // TODO: Check ACL for each service
                services = append(services, model.MapServiceFromStore(entry.Service, entry))
        }</span>

        <span class="cov0" title="0">r.logger.Debug("GraphQL: listed services",
                logger.Int("total", len(entries)),
                logger.Int("returned", len(services)))

        return services, nil</span>
}

// ServicesCount is the resolver for the servicesCount field.
func (r *queryResolver) ServicesCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        // Check authentication
        // TODO: Add authentication check when auth middleware is implemented

        services := r.serviceStore.List()
        return len(services), nil
}</span>

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver <span class="cov0" title="0">{ return &amp;queryResolver{r} }</span>

type queryResolver struct{ *Resolver }

// Helper functions

func stringOrEmpty(s *string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *s</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package scalar

import (
        "fmt"
        "io"
        "time"
)

// Duration is a custom scalar type for durations
type Duration time.Duration

// MarshalGQL implements the graphql.Marshaler interface
func (d Duration) MarshalGQL(w io.Writer) <span class="cov0" title="0">{
        duration := time.Duration(d).String()
        io.WriteString(w, fmt.Sprintf(`"%s"`, duration))
}</span>

// UnmarshalGQL implements the graphql.Unmarshaler interface
func (d *Duration) UnmarshalGQL(v interface{}) error <span class="cov0" title="0">{
        str, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("duration must be a string")
        }</span>

        <span class="cov0" title="0">parsed, err := time.ParseDuration(str)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse duration: %w", err)
        }</span>

        <span class="cov0" title="0">*d = Duration(parsed)
        return nil</span>
}

// ToDuration converts scalar.Duration to time.Duration
func (d Duration) ToDuration() time.Duration <span class="cov0" title="0">{
        return time.Duration(d)
}</span>

// FromDuration converts time.Duration to scalar.Duration
func FromDuration(d time.Duration) Duration <span class="cov0" title="0">{
        return Duration(d)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package scalar

import (
        "fmt"
        "io"
        "time"
)

// Time is a custom scalar type for timestamps
type Time time.Time

// MarshalGQL implements the graphql.Marshaler interface
func (t Time) MarshalGQL(w io.Writer) <span class="cov0" title="0">{
        timestamp := time.Time(t).Format(time.RFC3339)
        io.WriteString(w, fmt.Sprintf(`"%s"`, timestamp))
}</span>

// UnmarshalGQL implements the graphql.Unmarshaler interface
func (t *Time) UnmarshalGQL(v interface{}) error <span class="cov0" title="0">{
        str, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("time must be a string")
        }</span>

        <span class="cov0" title="0">parsed, err := time.Parse(time.RFC3339, str)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse time: %w", err)
        }</span>

        <span class="cov0" title="0">*t = Time(parsed)
        return nil</span>
}

// ToTime converts scalar.Time to time.Time
func (t Time) ToTime() time.Time <span class="cov0" title="0">{
        return time.Time(t)
}</span>

// FromTime converts time.Time to scalar.Time
func FromTime(t time.Time) Time <span class="cov0" title="0">{
        return Time(t)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package graphql

import (
        "net/http"

        "github.com/99designs/gqlgen/graphql/handler"
        "github.com/99designs/gqlgen/graphql/playground"
        "github.com/neogan74/konsul/internal/graphql/generated"
        "github.com/neogan74/konsul/internal/graphql/resolver"
)

// Server wraps the GraphQL handler
type Server struct {
        handler    http.Handler
        playground http.Handler
}

// NewServer creates a new GraphQL server
func NewServer(deps resolver.ResolverDependencies) *Server <span class="cov0" title="0">{
        // Create resolver
        r := resolver.NewResolver(deps)

        // Create GraphQL handler
        srv := handler.NewDefaultServer(
                generated.NewExecutableSchema(
                        generated.Config{
                                Resolvers: r,
                        },
                ),
        )

        // Add middleware (will expand in Phase 3)
        // srv.Use(extension.FixedComplexityLimit(1000))

        return &amp;Server{
                handler:    srv,
                playground: playground.Handler("GraphQL Playground", "/graphql"),
        }
}</span>

// Handler returns the GraphQL HTTP handler
func (s *Server) Handler() http.Handler <span class="cov0" title="0">{
        return s.handler
}</span>

// PlaygroundHandler returns the GraphiQL playground handler
func (s *Server) PlaygroundHandler() http.Handler <span class="cov0" title="0">{
        return s.playground
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package handlers

import (
        "encoding/json"
        "os"
        "path/filepath"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/acl"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/middleware"
)

// ACLHandler handles ACL policy management
type ACLHandler struct {
        evaluator *acl.Evaluator
        policyDir string
        log       logger.Logger
}

// NewACLHandler creates a new ACL handler
func NewACLHandler(evaluator *acl.Evaluator, policyDir string, log logger.Logger) *ACLHandler <span class="cov0" title="0">{
        return &amp;ACLHandler{
                evaluator: evaluator,
                policyDir: policyDir,
                log:       log,
        }
}</span>

// CreatePolicy creates a new ACL policy
func (h *ACLHandler) CreatePolicy(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        var policy acl.Policy
        if err := c.BodyParser(&amp;policy); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to parse policy", logger.Error(err))
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        // Validate policy
        <span class="cov0" title="0">if err := policy.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Error("Invalid policy", logger.String("policy", policy.Name), logger.Error(err))
                return middleware.BadRequest(c, "Invalid policy: "+err.Error())
        }</span>

        // Add policy to evaluator
        <span class="cov0" title="0">if err := h.evaluator.AddPolicy(&amp;policy); err != nil </span><span class="cov0" title="0">{
                if err == acl.ErrPolicyExists </span><span class="cov0" title="0">{
                        return middleware.Conflict(c, "Policy already exists")
                }</span>
                <span class="cov0" title="0">log.Error("Failed to add policy", logger.String("policy", policy.Name), logger.Error(err))
                return middleware.InternalError(c, "Failed to add policy")</span>
        }

        // Save policy to disk if policy directory is configured
        <span class="cov0" title="0">if h.policyDir != "" </span><span class="cov0" title="0">{
                if err := h.savePolicyToFile(&amp;policy); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to save policy to file", logger.String("policy", policy.Name), logger.Error(err))
                        // Continue - policy is in memory
                }</span>
        }

        <span class="cov0" title="0">log.Info("ACL policy created", logger.String("policy", policy.Name))
        return c.Status(fiber.StatusCreated).JSON(fiber.Map{
                "message": "policy created",
                "policy":  policy,
        })</span>
}

// GetPolicy retrieves a policy by name
func (h *ACLHandler) GetPolicy(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("name")
        log := middleware.GetLogger(c)

        policy, err := h.evaluator.GetPolicy(name)
        if err != nil </span><span class="cov0" title="0">{
                if err == acl.ErrPolicyNotFound </span><span class="cov0" title="0">{
                        return middleware.NotFound(c, "Policy not found")
                }</span>
                <span class="cov0" title="0">log.Error("Failed to get policy", logger.String("policy", name), logger.Error(err))
                return middleware.InternalError(c, "Failed to get policy")</span>
        }

        <span class="cov0" title="0">return c.JSON(policy)</span>
}

// ListPolicies lists all policies
func (h *ACLHandler) ListPolicies(c *fiber.Ctx) error <span class="cov0" title="0">{
        names := h.evaluator.ListPolicies()
        return c.JSON(fiber.Map{
                "policies": names,
                "count":    len(names),
        })
}</span>

// UpdatePolicy updates an existing policy
func (h *ACLHandler) UpdatePolicy(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("name")
        log := middleware.GetLogger(c)

        var policy acl.Policy
        if err := c.BodyParser(&amp;policy); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to parse policy", logger.Error(err))
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        // Ensure name matches URL parameter
        <span class="cov0" title="0">if policy.Name != name </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Policy name in body must match URL parameter")
        }</span>

        // Validate policy
        <span class="cov0" title="0">if err := policy.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Error("Invalid policy", logger.String("policy", policy.Name), logger.Error(err))
                return middleware.BadRequest(c, "Invalid policy: "+err.Error())
        }</span>

        // Update policy in evaluator
        <span class="cov0" title="0">if err := h.evaluator.UpdatePolicy(&amp;policy); err != nil </span><span class="cov0" title="0">{
                if err == acl.ErrPolicyNotFound </span><span class="cov0" title="0">{
                        return middleware.NotFound(c, "Policy not found")
                }</span>
                <span class="cov0" title="0">log.Error("Failed to update policy", logger.String("policy", policy.Name), logger.Error(err))
                return middleware.InternalError(c, "Failed to update policy")</span>
        }

        // Save policy to disk if policy directory is configured
        <span class="cov0" title="0">if h.policyDir != "" </span><span class="cov0" title="0">{
                if err := h.savePolicyToFile(&amp;policy); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to save policy to file", logger.String("policy", policy.Name), logger.Error(err))
                }</span>
        }

        <span class="cov0" title="0">log.Info("ACL policy updated", logger.String("policy", policy.Name))
        return c.JSON(fiber.Map{
                "message": "policy updated",
                "policy":  policy,
        })</span>
}

// DeletePolicy deletes a policy
func (h *ACLHandler) DeletePolicy(c *fiber.Ctx) error <span class="cov0" title="0">{
        name := c.Params("name")
        log := middleware.GetLogger(c)

        if err := h.evaluator.DeletePolicy(name); err != nil </span><span class="cov0" title="0">{
                if err == acl.ErrPolicyNotFound </span><span class="cov0" title="0">{
                        return middleware.NotFound(c, "Policy not found")
                }</span>
                <span class="cov0" title="0">log.Error("Failed to delete policy", logger.String("policy", name), logger.Error(err))
                return middleware.InternalError(c, "Failed to delete policy")</span>
        }

        // Remove policy file if it exists
        <span class="cov0" title="0">if h.policyDir != "" </span><span class="cov0" title="0">{
                policyFile := filepath.Join(h.policyDir, name+".json")
                if err := os.Remove(policyFile); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        log.Error("Failed to delete policy file", logger.String("file", policyFile), logger.Error(err))
                }</span>
        }

        <span class="cov0" title="0">log.Info("ACL policy deleted", logger.String("policy", name))
        return c.JSON(fiber.Map{
                "message": "policy deleted",
                "policy":  name,
        })</span>
}

// TestPolicy tests if a policy would allow a specific operation
func (h *ACLHandler) TestPolicy(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        var req struct {
                Policies   []string `json:"policies"`
                Resource   string   `json:"resource"`
                Path       string   `json:"path"`
                Capability string   `json:"capability"`
        }

        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to parse test request", logger.Error(err))
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        // Build resource
        <span class="cov0" title="0">var resource acl.Resource
        switch req.Resource </span>{
        case "kv":<span class="cov0" title="0">
                resource = acl.NewKVResource(req.Path)</span>
        case "service":<span class="cov0" title="0">
                resource = acl.NewServiceResource(req.Path)</span>
        case "health":<span class="cov0" title="0">
                resource = acl.NewHealthResource()</span>
        case "backup":<span class="cov0" title="0">
                resource = acl.NewBackupResource()</span>
        case "admin":<span class="cov0" title="0">
                resource = acl.NewAdminResource()</span>
        default:<span class="cov0" title="0">
                return middleware.BadRequest(c, "Invalid resource type")</span>
        }

        // Evaluate
        <span class="cov0" title="0">allowed := h.evaluator.Evaluate(req.Policies, resource, acl.Capability(req.Capability))

        return c.JSON(fiber.Map{
                "allowed":    allowed,
                "policies":   req.Policies,
                "resource":   req.Resource,
                "path":       req.Path,
                "capability": req.Capability,
        })</span>
}

// LoadPolicies loads all policies from the policy directory
func (h *ACLHandler) LoadPolicies() error <span class="cov0" title="0">{
        if h.policyDir == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create policy directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(h.policyDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Read all JSON files in the policy directory
        <span class="cov0" title="0">files, err := filepath.Glob(filepath.Join(h.policyDir, "*.json"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                data, err := os.ReadFile(file)
                if err != nil </span><span class="cov0" title="0">{
                        h.log.Error("Failed to read policy file", logger.String("file", file), logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">policy, err := acl.FromJSON(data)
                if err != nil </span><span class="cov0" title="0">{
                        h.log.Error("Failed to parse policy file", logger.String("file", file), logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if err := h.evaluator.AddPolicy(policy); err != nil &amp;&amp; err != acl.ErrPolicyExists </span><span class="cov0" title="0">{
                        h.log.Error("Failed to add policy", logger.String("policy", policy.Name), logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">h.log.Info("Loaded ACL policy from file", logger.String("policy", policy.Name), logger.String("file", file))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// savePolicyToFile saves a policy to a JSON file
func (h *ACLHandler) savePolicyToFile(policy *acl.Policy) error <span class="cov0" title="0">{
        // Create policy directory if it doesn't exist
        if err := os.MkdirAll(h.policyDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">policyFile := filepath.Join(h.policyDir, policy.Name+".json")
        data, err := json.MarshalIndent(policy, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(policyFile, data, 0644)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/auth"
        "github.com/neogan74/konsul/internal/middleware"
)

type AuthHandler struct {
        jwtService    *auth.JWTService
        apiKeyService *auth.APIKeyService
}

func NewAuthHandler(jwtService *auth.JWTService, apiKeyService *auth.APIKeyService) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                jwtService:    jwtService,
                apiKeyService: apiKeyService,
        }
}</span>

// LoginRequest represents the login request body
type LoginRequest struct {
        UserID   string   `json:"user_id"`
        Username string   `json:"username"`
        Password string   `json:"password"`
        Roles    []string `json:"roles"`
}

// LoginResponse represents the login response body
type LoginResponse struct {
        Token        string `json:"token"`
        RefreshToken string `json:"refresh_token"`
        ExpiresIn    int64  `json:"expires_in"`
}

// RefreshRequest represents the refresh token request body
type RefreshRequest struct {
        RefreshToken string   `json:"refresh_token"`
        Username     string   `json:"username"`
        Roles        []string `json:"roles"`
}

// Login handles user login and returns JWT tokens
func (h *AuthHandler) Login(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req LoginRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "invalid request body",
                })
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.UserID == "" || req.Username == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "user_id and username are required",
                })
        }</span>

        // TODO: Add actual password validation against a user store
        // For now, this is a simple implementation that generates tokens

        // Generate access token
        <span class="cov0" title="0">token, err := h.jwtService.GenerateToken(req.UserID, req.Username, req.Roles)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "failed to generate token",
                })
        }</span>

        // Generate refresh token
        <span class="cov0" title="0">refreshToken, err := h.jwtService.GenerateRefreshToken(req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "failed to generate refresh token",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(LoginResponse{
                Token:        token,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(15 * 60), // 15 minutes in seconds
        })</span>
}

// Refresh handles token refresh
func (h *AuthHandler) Refresh(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req RefreshRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "invalid request body",
                })
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.RefreshToken == "" || req.Username == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "refresh_token and username are required",
                })
        }</span>

        // Refresh tokens
        <span class="cov0" title="0">newToken, newRefreshToken, err := h.jwtService.RefreshToken(req.RefreshToken, req.Username, req.Roles)
        if err != nil </span><span class="cov0" title="0">{
                switch err </span>{
                case auth.ErrTokenExpired:<span class="cov0" title="0">
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "refresh token expired",
                        })</span>
                case auth.ErrTokenInvalid:<span class="cov0" title="0">
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "invalid refresh token",
                        })</span>
                default:<span class="cov0" title="0">
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error": "failed to refresh token",
                        })</span>
                }
        }

        <span class="cov0" title="0">return c.JSON(LoginResponse{
                Token:        newToken,
                RefreshToken: newRefreshToken,
                ExpiresIn:    int64(15 * 60), // 15 minutes in seconds
        })</span>
}

// Verify verifies the current JWT token
func (h *AuthHandler) Verify(c *fiber.Ctx) error <span class="cov0" title="0">{
        claims := middleware.GetClaims(c)
        if claims == nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                        "error": "no valid token found",
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "user_id":  claims.UserID,
                "username": claims.Username,
                "roles":    claims.Roles,
                "issuer":   claims.Issuer,
                "expires":  claims.ExpiresAt.Time.Unix(),
        })</span>
}

// CreateAPIKeyRequest represents the API key creation request
type CreateAPIKeyRequest struct {
        Name        string            `json:"name"`
        Permissions []string          `json:"permissions"`
        Metadata    map[string]string `json:"metadata"`
        ExpiresIn   *int64            `json:"expires_in"` // seconds
}

// CreateAPIKeyResponse represents the API key creation response
type CreateAPIKeyResponse struct {
        Key    string       `json:"key"`
        APIKey *auth.APIKey `json:"api_key"`
}

// CreateAPIKey creates a new API key
func (h *AuthHandler) CreateAPIKey(c *fiber.Ctx) error <span class="cov0" title="0">{
        var req CreateAPIKeyRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "invalid request body",
                })
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if req.Name == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "name is required",
                })
        }</span>

        // Calculate expiration
        <span class="cov0" title="0">var expiresAt *time.Time
        if req.ExpiresIn != nil </span><span class="cov0" title="0">{
                exp := time.Now().Add(time.Duration(*req.ExpiresIn) * time.Second)
                expiresAt = &amp;exp
        }</span>

        // Generate API key
        <span class="cov0" title="0">keyString, apiKey, err := h.apiKeyService.GenerateAPIKey(req.Name, req.Permissions, req.Metadata, expiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "failed to generate API key",
                })
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusCreated).JSON(CreateAPIKeyResponse{
                Key:    keyString,
                APIKey: apiKey,
        })</span>
}

// ListAPIKeys lists all API keys
func (h *AuthHandler) ListAPIKeys(c *fiber.Ctx) error <span class="cov0" title="0">{
        keys := h.apiKeyService.ListAPIKeys()
        return c.JSON(fiber.Map{
                "keys":  keys,
                "count": len(keys),
        })
}</span>

// GetAPIKey gets a specific API key by ID
func (h *AuthHandler) GetAPIKey(c *fiber.Ctx) error <span class="cov0" title="0">{
        keyID := c.Params("id")
        if keyID == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "key ID is required",
                })
        }</span>

        <span class="cov0" title="0">apiKey, err := h.apiKeyService.GetAPIKey(keyID)
        if err != nil </span><span class="cov0" title="0">{
                if err == auth.ErrAPIKeyNotFound </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                                "error": "API key not found",
                        })
                }</span>
                <span class="cov0" title="0">return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "failed to get API key",
                })</span>
        }

        <span class="cov0" title="0">return c.JSON(apiKey)</span>
}

// RevokeAPIKey revokes an API key
func (h *AuthHandler) RevokeAPIKey(c *fiber.Ctx) error <span class="cov0" title="0">{
        keyID := c.Params("id")
        if keyID == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "key ID is required",
                })
        }</span>

        <span class="cov0" title="0">if err := h.apiKeyService.RevokeAPIKey(keyID); err != nil </span><span class="cov0" title="0">{
                if err == auth.ErrAPIKeyNotFound </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                                "error": "API key not found",
                        })
                }</span>
                <span class="cov0" title="0">return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "failed to revoke API key",
                })</span>
        }

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "message": "API key revoked successfully",
        })</span>
}

// DeleteAPIKey deletes an API key
func (h *AuthHandler) DeleteAPIKey(c *fiber.Ctx) error <span class="cov0" title="0">{
        keyID := c.Params("id")
        if keyID == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "key ID is required",
                })
        }</span>

        <span class="cov0" title="0">if err := h.apiKeyService.DeleteAPIKey(keyID); err != nil </span><span class="cov0" title="0">{
                if err == auth.ErrAPIKeyNotFound </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                                "error": "API key not found",
                        })
                }</span>
                <span class="cov0" title="0">return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "failed to delete API key",
                })</span>
        }

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "message": "API key deleted successfully",
        })</span>
}

// UpdateAPIKeyRequest represents the API key update request
type UpdateAPIKeyRequest struct {
        Name        string            `json:"name"`
        Permissions []string          `json:"permissions"`
        Metadata    map[string]string `json:"metadata"`
        Enabled     *bool             `json:"enabled"`
}

// UpdateAPIKey updates an API key
func (h *AuthHandler) UpdateAPIKey(c *fiber.Ctx) error <span class="cov0" title="0">{
        keyID := c.Params("id")
        if keyID == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "key ID is required",
                })
        }</span>

        <span class="cov0" title="0">var req UpdateAPIKeyRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "error": "invalid request body",
                })
        }</span>

        <span class="cov0" title="0">if err := h.apiKeyService.UpdateAPIKey(keyID, req.Name, req.Permissions, req.Metadata, req.Enabled); err != nil </span><span class="cov0" title="0">{
                if err == auth.ErrAPIKeyNotFound </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                                "error": "API key not found",
                        })
                }</span>
                <span class="cov0" title="0">return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "error": "failed to update API key",
                })</span>
        }

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "message": "API key updated successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "fmt"
        "path/filepath"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/middleware"
        "github.com/neogan74/konsul/internal/persistence"
)

// BackupHandler handles backup and restore operations
type BackupHandler struct {
        engine persistence.Engine
        log    logger.Logger
}

// NewBackupHandler creates a new backup handler
func NewBackupHandler(engine persistence.Engine, log logger.Logger) *BackupHandler <span class="cov0" title="0">{
        return &amp;BackupHandler{
                engine: engine,
                log:    log,
        }
}</span>

// CreateBackup creates a backup of the current data
func (h *BackupHandler) CreateBackup(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        if h.engine == nil </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Backup not available - persistence is disabled")
        }</span>

        // Generate backup filename with timestamp
        <span class="cov0" title="0">timestamp := time.Now().Format("20060102-150405")
        backupPath := filepath.Join("./backups", fmt.Sprintf("konsul-backup-%s.db", timestamp))

        if err := h.engine.Backup(backupPath); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to create backup", logger.Error(err))
                return middleware.InternalServerError(c, "Failed to create backup")
        }</span>

        <span class="cov0" title="0">log.Info("Backup created successfully", logger.String("path", backupPath))

        return c.JSON(fiber.Map{
                "message":     "Backup created successfully",
                "backup_path": backupPath,
                "timestamp":   timestamp,
        })</span>
}

// RestoreBackup restores data from a backup file
func (h *BackupHandler) RestoreBackup(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        if h.engine == nil </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Restore not available - persistence is disabled")
        }</span>

        <span class="cov0" title="0">var body struct {
                BackupPath string `json:"backup_path"`
        }

        if err := c.BodyParser(&amp;body); err != nil </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        <span class="cov0" title="0">if body.BackupPath == "" </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "backup_path is required")
        }</span>

        <span class="cov0" title="0">if err := h.engine.Restore(body.BackupPath); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to restore backup",
                        logger.String("backup_path", body.BackupPath),
                        logger.Error(err))
                return middleware.InternalServerError(c, "Failed to restore backup")
        }</span>

        <span class="cov0" title="0">log.Info("Backup restored successfully", logger.String("path", body.BackupPath))

        return c.JSON(fiber.Map{
                "message": "Backup restored successfully",
                "path":    body.BackupPath,
        })</span>
}

// ExportData exports all data as JSON
func (h *BackupHandler) ExportData(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        if h.engine == nil </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Export not available - persistence is disabled")
        }</span>

        // Check if engine has export capability
        <span class="cov0" title="0">if badgerEngine, ok := h.engine.(*persistence.BadgerEngine); ok </span><span class="cov0" title="0">{
                data, err := badgerEngine.ExportData()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to export data", logger.Error(err))
                        return middleware.InternalServerError(c, "Failed to export data")
                }</span>

                <span class="cov0" title="0">log.Info("Data exported successfully")
                return c.JSON(data)</span>
        }

        <span class="cov0" title="0">return middleware.BadRequest(c, "Export not supported for this persistence type")</span>
}

// ImportData imports data from JSON
func (h *BackupHandler) ImportData(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        if h.engine == nil </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Import not available - persistence is disabled")
        }</span>

        <span class="cov0" title="0">var data map[string]interface{}
        if err := c.BodyParser(&amp;data); err != nil </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        // Check if engine has import capability
        <span class="cov0" title="0">if badgerEngine, ok := h.engine.(*persistence.BadgerEngine); ok </span><span class="cov0" title="0">{
                if err := badgerEngine.ImportData(data); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to import data", logger.Error(err))
                        return middleware.InternalServerError(c, "Failed to import data")
                }</span>

                <span class="cov0" title="0">log.Info("Data imported successfully")
                return c.JSON(fiber.Map{"message": "Data imported successfully"})</span>
        }

        <span class="cov0" title="0">return middleware.BadRequest(c, "Import not supported for this persistence type")</span>
}

// ListBackups lists available backup files
func (h *BackupHandler) ListBackups(c *fiber.Ctx) error <span class="cov0" title="0">{
        if h.engine == nil </span><span class="cov0" title="0">{
                return middleware.BadRequest(c, "Backup listing not available - persistence is disabled")
        }</span>

        // This is a simplified implementation
        // In a real implementation, you'd scan the backup directory
        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "message": "Backup listing not implemented yet",
                "note":    "Check the ./backups directory for available backup files",
        })</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "runtime"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/store"
)

// HealthStatus represents the health status of the service
type HealthStatus struct {
        Status      string            `json:"status"`
        Version     string            `json:"version"`
        Uptime      string            `json:"uptime"`
        Timestamp   time.Time         `json:"timestamp"`
        Services    ServiceHealth     `json:"services"`
        KVStore     KVHealth          `json:"kv_store"`
        System      SystemHealth      `json:"system"`
}

type ServiceHealth struct {
        Total   int `json:"total"`
        Active  int `json:"active"`
        Expired int `json:"expired"`
}

type KVHealth struct {
        Total int `json:"total_keys"`
}

type SystemHealth struct {
        Goroutines   int    `json:"goroutines"`
        MemoryAlloc  uint64 `json:"memory_alloc_bytes"`
        MemorySys    uint64 `json:"memory_sys_bytes"`
        NumGC        uint32 `json:"num_gc"`
}

// HealthHandler handles health check operations
type HealthHandler struct {
        kvStore      *store.KVStore
        serviceStore *store.ServiceStore
        startTime    time.Time
        version      string
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(kvStore *store.KVStore, serviceStore *store.ServiceStore, version string) *HealthHandler <span class="cov10" title="3">{
        return &amp;HealthHandler{
                kvStore:      kvStore,
                serviceStore: serviceStore,
                startTime:    time.Now(),
                version:      version,
        }
}</span>

// Check returns the health status of the service
func (h *HealthHandler) Check(c *fiber.Ctx) error <span class="cov1" title="1">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        // Get service stats
        serviceEntries := h.serviceStore.ListAll()
        activeCount := 0
        expiredCount := 0
        now := time.Now()

        for _, entry := range serviceEntries </span><span class="cov1" title="1">{
                if entry.ExpiresAt.After(now) </span><span class="cov1" title="1">{
                        activeCount++
                }</span> else<span class="cov0" title="0"> {
                        expiredCount++
                }</span>
        }

        // Get KV store stats
        <span class="cov1" title="1">kvKeys := h.kvStore.List()

        status := HealthStatus{
                Status:    "healthy",
                Version:   h.version,
                Uptime:    time.Since(h.startTime).String(),
                Timestamp: time.Now(),
                Services: ServiceHealth{
                        Total:   len(serviceEntries),
                        Active:  activeCount,
                        Expired: expiredCount,
                },
                KVStore: KVHealth{
                        Total: len(kvKeys),
                },
                System: SystemHealth{
                        Goroutines:  runtime.NumGoroutine(),
                        MemoryAlloc: m.Alloc,
                        MemorySys:   m.Sys,
                        NumGC:       m.NumGC,
                },
        }

        return c.JSON(status)</span>
}

// Liveness is a simple liveness probe
func (h *HealthHandler) Liveness(c *fiber.Ctx) error <span class="cov1" title="1">{
        return c.JSON(fiber.Map{
                "status": "alive",
                "timestamp": time.Now(),
        })
}</span>

// Readiness checks if the service is ready to accept traffic
func (h *HealthHandler) Readiness(c *fiber.Ctx) error <span class="cov1" title="1">{
        // Here you could add checks for external dependencies
        // For now, we'll just check if the stores are accessible

        // Try to access KV store
        _ = h.kvStore.List()

        // Try to access service store
        _ = h.serviceStore.List()

        return c.JSON(fiber.Map{
                "status": "ready",
                "timestamp": time.Now(),
        })
}</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/healthcheck"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/middleware"
        "github.com/neogan74/konsul/internal/store"
)

type HealthCheckHandler struct {
        serviceStore *store.ServiceStore
}

func NewHealthCheckHandler(serviceStore *store.ServiceStore) *HealthCheckHandler <span class="cov0" title="0">{
        return &amp;HealthCheckHandler{
                serviceStore: serviceStore,
        }
}</span>

func (h *HealthCheckHandler) ListChecks(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)
        log.Debug("Listing all health checks")

        checks := h.serviceStore.GetAllHealthChecks()

        log.Info("Health checks listed successfully", logger.Int("count", len(checks)))
        return c.JSON(checks)
}</span>

func (h *HealthCheckHandler) GetServiceChecks(c *fiber.Ctx) error <span class="cov0" title="0">{
        serviceName := c.Params("name")
        log := middleware.GetLogger(c)

        log.Debug("Getting health checks for service", logger.String("service", serviceName))

        checks := h.serviceStore.GetHealthChecks(serviceName)

        log.Info("Service health checks retrieved",
                logger.String("service", serviceName),
                logger.Int("count", len(checks)))

        return c.JSON(checks)
}</span>

func (h *HealthCheckHandler) UpdateTTLCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        checkID := c.Params("id")
        log := middleware.GetLogger(c)

        log.Debug("Updating TTL check", logger.String("check_id", checkID))

        err := h.serviceStore.UpdateTTLCheck(checkID)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to update TTL check",
                        logger.String("check_id", checkID),
                        logger.Error(err))
                return middleware.BadRequest(c, err.Error())
        }</span>

        <span class="cov0" title="0">log.Info("TTL check updated successfully", logger.String("check_id", checkID))
        return c.JSON(fiber.Map{"message": "TTL check updated", "check_id": checkID})</span>
}

func (h *HealthCheckHandler) AddCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        var checkDef healthcheck.CheckDefinition
        if err := c.BodyParser(&amp;checkDef); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to parse health check definition", logger.Error(err))
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        <span class="cov0" title="0">log.Debug("Adding health check",
                logger.String("name", checkDef.Name),
                logger.String("service", checkDef.ServiceID))

        // We need access to the health manager through the service store
        // For now, we'll return an error since we don't have direct access
        return middleware.BadRequest(c, "Direct health check addition not yet implemented")</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "fmt"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/metrics"
        "github.com/neogan74/konsul/internal/middleware"
        "github.com/neogan74/konsul/internal/store"
)

type KVHandler struct {
        store *store.KVStore
}

func NewKVHandler(kvStore *store.KVStore) *KVHandler <span class="cov10" title="4">{
        return &amp;KVHandler{store: kvStore}
}</span>

func (h *KVHandler) Get(c *fiber.Ctx) error <span class="cov5" title="2">{
        key := c.Params("key")
        log := middleware.GetLogger(c)

        log.Debug("Getting key", logger.String("key", key))

        value, ok := h.store.Get(key)
        if !ok </span><span class="cov1" title="1">{
                log.Warn("Key not found", logger.String("key", key))
                metrics.KVOperationsTotal.WithLabelValues("get", "not_found").Inc()
                return middleware.NotFound(c, "Key not found")
        }</span>

        <span class="cov1" title="1">log.Info("Key retrieved successfully", logger.String("key", key))
        metrics.KVOperationsTotal.WithLabelValues("get", "success").Inc()
        return c.JSON(fiber.Map{"key": key, "value": value})</span>
}

func (h *KVHandler) Set(c *fiber.Ctx) error <span class="cov5" title="2">{
        key := c.Params("key")
        log := middleware.GetLogger(c)

        body := struct {
                Value string `json:"value"`
        }{}

        if err := c.BodyParser(&amp;body); err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to parse request body",
                        logger.String("key", key),
                        logger.Error(err))
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        <span class="cov1" title="1">log.Debug("Setting key",
                logger.String("key", key),
                logger.String("value_length", fmt.Sprintf("%d", len(body.Value))))

        h.store.Set(key, body.Value)

        log.Info("Key set successfully", logger.String("key", key))
        metrics.KVOperationsTotal.WithLabelValues("set", "success").Inc()
        metrics.KVStoreSize.Set(float64(len(h.store.List())))
        return c.JSON(fiber.Map{"message": "key set", "key": key})</span>
}

func (h *KVHandler) Delete(c *fiber.Ctx) error <span class="cov1" title="1">{
        key := c.Params("key")
        log := middleware.GetLogger(c)

        log.Debug("Deleting key", logger.String("key", key))

        h.store.Delete(key)

        log.Info("Key deleted successfully", logger.String("key", key))
        metrics.KVOperationsTotal.WithLabelValues("delete", "success").Inc()
        metrics.KVStoreSize.Set(float64(len(h.store.List())))
        return c.JSON(fiber.Map{"message": "key deleted", "key": key})
}</span>

func (h *KVHandler) List(c *fiber.Ctx) error <span class="cov0" title="0">{
        log := middleware.GetLogger(c)

        log.Debug("Listing all keys")

        keys := h.store.List()

        log.Info("Keys listed successfully", logger.Int("count", len(keys)))
        metrics.KVOperationsTotal.WithLabelValues("list", "success").Inc()
        return c.JSON(keys)
}</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/ratelimit"
)

// RateLimitHandler handles rate limit administration endpoints
type RateLimitHandler struct {
        service *ratelimit.Service
        log     logger.Logger
}

// NewRateLimitHandler creates a new rate limit admin handler
func NewRateLimitHandler(service *ratelimit.Service, log logger.Logger) *RateLimitHandler <span class="cov10" title="14">{
        return &amp;RateLimitHandler{
                service: service,
                log:     log,
        }
}</span>

// GetStats returns current rate limiting statistics
// GET /admin/ratelimit/stats
func (h *RateLimitHandler) GetStats(c *fiber.Ctx) error <span class="cov1" title="1">{
        stats := h.service.Stats()

        h.log.Debug("Rate limit stats retrieved",
                logger.Int("ip_limiters", getIntStat(stats, "ip_limiters")),
                logger.Int("apikey_limiters", getIntStat(stats, "apikey_limiters")))

        return c.JSON(fiber.Map{
                "success": true,
                "data":    stats,
        })
}</span>

// GetConfig returns current rate limit configuration
// GET /admin/ratelimit/config
func (h *RateLimitHandler) GetConfig(c *fiber.Ctx) error <span class="cov1" title="1">{
        config := h.service.GetConfig()

        return c.JSON(fiber.Map{
                "success": true,
                "config": fiber.Map{
                        "enabled":          config.Enabled,
                        "requests_per_sec": config.RequestsPerSec,
                        "burst":            config.Burst,
                        "by_ip":            config.ByIP,
                        "by_apikey":        config.ByAPIKey,
                        "cleanup_interval": config.CleanupInterval.String(),
                },
        })
}</span>

// ResetIP resets rate limit for a specific IP address
// POST /admin/ratelimit/reset/ip/:ip
func (h *RateLimitHandler) ResetIP(c *fiber.Ctx) error <span class="cov1" title="1">{
        ip := c.Params("ip")
        if ip == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "IP address is required",
                })
        }</span>

        <span class="cov1" title="1">h.service.ResetIP(ip)

        h.log.Info("Rate limit reset for IP",
                logger.String("ip", ip),
                logger.String("admin_user", getAdminUser(c)))

        return c.JSON(fiber.Map{
                "success": true,
                "message": "Rate limit reset successfully",
                "ip":      ip,
        })</span>
}

// ResetAPIKey resets rate limit for a specific API key
// POST /admin/ratelimit/reset/apikey/:key_id
func (h *RateLimitHandler) ResetAPIKey(c *fiber.Ctx) error <span class="cov1" title="1">{
        keyID := c.Params("key_id")
        if keyID == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "API key ID is required",
                })
        }</span>

        <span class="cov1" title="1">h.service.ResetAPIKey(keyID)

        h.log.Info("Rate limit reset for API key",
                logger.String("key_id", keyID),
                logger.String("admin_user", getAdminUser(c)))

        return c.JSON(fiber.Map{
                "success": true,
                "message": "Rate limit reset successfully",
                "key_id":  keyID,
        })</span>
}

// ResetAll resets all rate limiters
// POST /admin/ratelimit/reset/all
func (h *RateLimitHandler) ResetAll(c *fiber.Ctx) error <span class="cov5" title="4">{
        limiterType := c.Query("type", "all") // all, ip, apikey

        var message string
        switch limiterType </span>{
        case "ip":<span class="cov1" title="1">
                h.service.ResetAllIP()
                message = "All IP rate limiters reset"</span>
        case "apikey":<span class="cov1" title="1">
                h.service.ResetAllAPIKey()
                message = "All API key rate limiters reset"</span>
        case "all":<span class="cov1" title="1">
                h.service.ResetAllIP()
                h.service.ResetAllAPIKey()
                message = "All rate limiters reset"</span>
        default:<span class="cov1" title="1">
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "Invalid type parameter. Must be: all, ip, or apikey",
                })</span>
        }

        <span class="cov4" title="3">h.log.Warn("All rate limiters reset",
                logger.String("type", limiterType),
                logger.String("admin_user", getAdminUser(c)))

        return c.JSON(fiber.Map{
                "success": true,
                "message": message,
                "type":    limiterType,
        })</span>
}

// GetActiveClients returns list of currently rate-limited clients
// GET /admin/ratelimit/clients
func (h *RateLimitHandler) GetActiveClients(c *fiber.Ctx) error <span class="cov4" title="3">{
        limiterType := c.Query("type", "all") // all, ip, apikey

        clients := h.service.GetActiveClients(limiterType)

        return c.JSON(fiber.Map{
                "success": true,
                "count":   len(clients),
                "clients": clients,
        })
}</span>

// GetClientStatus returns rate limit status for a specific client
// GET /admin/ratelimit/client/:identifier
func (h *RateLimitHandler) GetClientStatus(c *fiber.Ctx) error <span class="cov3" title="2">{
        identifier := c.Params("identifier")
        if identifier == "" </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "Client identifier is required",
                })
        }</span>

        <span class="cov3" title="2">status := h.service.GetClientStatus(identifier)
        if status == nil </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                        "success": false,
                        "error":   "Client not found",
                })
        }</span>

        <span class="cov1" title="1">return c.JSON(fiber.Map{
                "success": true,
                "client":  status,
        })</span>
}

// UpdateConfig updates rate limit configuration (dynamic reconfiguration)
// PUT /admin/ratelimit/config
func (h *RateLimitHandler) UpdateConfig(c *fiber.Ctx) error <span class="cov7" title="6">{
        type ConfigUpdate struct {
                RequestsPerSec *float64 `json:"requests_per_sec"`
                Burst          *int     `json:"burst"`
        }

        var update ConfigUpdate
        if err := c.BodyParser(&amp;update); err != nil </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "Invalid request body",
                        "details": err.Error(),
                })
        }</span>

        // Validate inputs
        <span class="cov6" title="5">if update.RequestsPerSec != nil &amp;&amp; *update.RequestsPerSec &lt;= 0 </span><span class="cov1" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "requests_per_sec must be greater than 0",
                })
        }</span>

        <span class="cov5" title="4">if update.Burst != nil &amp;&amp; *update.Burst &lt;= 0 </span><span class="cov3" title="2">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "burst must be greater than 0",
                })
        }</span>

        // Apply updates
        <span class="cov3" title="2">changed := h.service.UpdateConfig(update.RequestsPerSec, update.Burst)
        if !changed </span><span class="cov1" title="1">{
                return c.JSON(fiber.Map{
                        "success": true,
                        "message": "No changes applied",
                })
        }</span>

        <span class="cov1" title="1">h.log.Info("Rate limit configuration updated",
                logger.String("admin_user", getAdminUser(c)))

        // Get updated config
        config := h.service.GetConfig()

        return c.JSON(fiber.Map{
                "success": true,
                "message": "Configuration updated successfully",
                "config": fiber.Map{
                        "requests_per_sec": config.RequestsPerSec,
                        "burst":            config.Burst,
                },
        })</span>
}

// Helper functions

func getIntStat(stats map[string]interface{}, key string) int <span class="cov3" title="2">{
        if val, ok := stats[key].(int); ok </span><span class="cov3" title="2">{
                return val
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func getAdminUser(c *fiber.Ctx) string <span class="cov7" title="6">{
        if username, ok := c.Locals("username").(string); ok </span><span class="cov0" title="0">{
                return username
        }</span>
        <span class="cov7" title="6">if userID, ok := c.Locals("user_id").(string); ok </span><span class="cov0" title="0">{
                return userID
        }</span>
        <span class="cov7" title="6">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/metrics"
        "github.com/neogan74/konsul/internal/middleware"
        "github.com/neogan74/konsul/internal/store"
)

type ServiceHandler struct {
        store *store.ServiceStore
}

func NewServiceHandler(serviceStore *store.ServiceStore) *ServiceHandler <span class="cov10" title="6">{
        return &amp;ServiceHandler{store: serviceStore}
}</span>

func (h *ServiceHandler) Register(c *fiber.Ctx) error <span class="cov6" title="3">{
        log := middleware.GetLogger(c)
        var svc store.Service

        if err := c.BodyParser(&amp;svc); err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to parse service registration body", logger.Error(err))
                return middleware.BadRequest(c, "Invalid JSON body")
        }</span>

        <span class="cov4" title="2">if svc.Name == "" || svc.Address == "" || svc.Port == 0 </span><span class="cov1" title="1">{
                log.Warn("Service registration missing required fields",
                        logger.String("name", svc.Name),
                        logger.String("address", svc.Address),
                        logger.Int("port", svc.Port))
                return middleware.BadRequest(c, "Missing required fields: name, address, and port")
        }</span>

        <span class="cov1" title="1">log.Info("Registering service",
                logger.String("service_name", svc.Name),
                logger.String("address", svc.Address),
                logger.Int("port", svc.Port))

        h.store.Register(svc)

        log.Info("Service registered successfully",
                logger.String("service_name", svc.Name))

        metrics.ServiceOperationsTotal.WithLabelValues("register", "success").Inc()
        metrics.RegisteredServicesTotal.Set(float64(len(h.store.List())))

        return c.JSON(fiber.Map{"message": "service registered", "service": svc})</span>
}

func (h *ServiceHandler) List(c *fiber.Ctx) error <span class="cov1" title="1">{
        log := middleware.GetLogger(c)
        services := h.store.List()

        log.Debug("Listing services", logger.Int("count", len(services)))
        return c.JSON(services)
}</span>

func (h *ServiceHandler) Get(c *fiber.Ctx) error <span class="cov4" title="2">{
        name := c.Params("name")
        log := middleware.GetLogger(c)

        log.Debug("Getting service", logger.String("service_name", name))

        svc, ok := h.store.Get(name)
        if !ok </span><span class="cov1" title="1">{
                log.Warn("Service not found", logger.String("service_name", name))
                metrics.ServiceOperationsTotal.WithLabelValues("get", "not_found").Inc()
                return middleware.NotFound(c, "Service not found")
        }</span>

        <span class="cov1" title="1">log.Info("Service retrieved successfully", logger.String("service_name", name))
        metrics.ServiceOperationsTotal.WithLabelValues("get", "success").Inc()
        return c.JSON(svc)</span>
}

func (h *ServiceHandler) Deregister(c *fiber.Ctx) error <span class="cov1" title="1">{
        name := c.Params("name")
        log := middleware.GetLogger(c)

        log.Info("Deregistering service", logger.String("service_name", name))

        h.store.Deregister(name)

        log.Info("Service deregistered successfully", logger.String("service_name", name))
        metrics.ServiceOperationsTotal.WithLabelValues("deregister", "success").Inc()
        metrics.RegisteredServicesTotal.Set(float64(len(h.store.List())))
        return c.JSON(fiber.Map{"message": "service deregistered", "name": name})
}</span>

func (h *ServiceHandler) Heartbeat(c *fiber.Ctx) error <span class="cov4" title="2">{
        name := c.Params("name")
        log := middleware.GetLogger(c)

        log.Debug("Processing heartbeat", logger.String("service_name", name))

        if h.store.Heartbeat(name) </span><span class="cov1" title="1">{
                log.Info("Heartbeat updated successfully", logger.String("service_name", name))
                metrics.ServiceHeartbeatsTotal.WithLabelValues(name, "success").Inc()
                return c.JSON(fiber.Map{"message": "heartbeat updated", "service": name})
        }</span>

        <span class="cov1" title="1">log.Warn("Heartbeat failed - service not found", logger.String("service_name", name))
        metrics.ServiceHeartbeatsTotal.WithLabelValues(name, "not_found").Inc()
        return middleware.NotFound(c, "Service not found")</span>
}</pre>
		
		<pre class="file" id="file33" style="display: none">package healthcheck

import (
        "context"
        "crypto/tls"
        "fmt"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/health/grpc_health_v1"
)

type GRPCChecker struct{}

func NewGRPCChecker() *GRPCChecker <span class="cov0" title="0">{
        return &amp;GRPCChecker{}
}</span>

func (g *GRPCChecker) Check(ctx context.Context, check *Check) (Status, string, error) <span class="cov0" title="0">{
        if check.GRPC == "" </span><span class="cov0" title="0">{
                return StatusCritical, "gRPC address not specified", fmt.Errorf("gRPC address required")
        }</span>

        <span class="cov0" title="0">timeout := check.Timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 10 * time.Second
        }</span>

        // Create context with timeout
        <span class="cov0" title="0">ctxWithTimeout, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Configure credentials
        var creds credentials.TransportCredentials
        if check.GRPCUseTLS </span><span class="cov0" title="0">{
                creds = credentials.NewTLS(&amp;tls.Config{})
        }</span> else<span class="cov0" title="0"> {
                creds = insecure.NewCredentials()
        }</span>

        // Dial options
        <span class="cov0" title="0">opts := []grpc.DialOption{
                grpc.WithTransportCredentials(creds),
                grpc.WithBlock(), // Wait for connection to be established
        }

        start := time.Now()
        conn, err := grpc.DialContext(ctxWithTimeout, check.GRPC, opts...)
        if err != nil </span><span class="cov0" title="0">{
                duration := time.Since(start)
                output := fmt.Sprintf("gRPC connection to %s failed after %v: %v", check.GRPC, duration, err)
                return StatusCritical, output, err
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create health client
        client := grpc_health_v1.NewHealthClient(conn)

        // Check health
        resp, err := client.Check(ctxWithTimeout, &amp;grpc_health_v1.HealthCheckRequest{
                Service: "", // Empty service name checks overall server health
        })

        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                output := fmt.Sprintf("gRPC health check to %s failed after %v: %v", check.GRPC, duration, err)
                return StatusCritical, output, err
        }</span>

        // Evaluate response
        <span class="cov0" title="0">switch resp.Status </span>{
        case grpc_health_v1.HealthCheckResponse_SERVING:<span class="cov0" title="0">
                output := fmt.Sprintf("gRPC health check to %s successful (%.3fs)", check.GRPC, duration.Seconds())
                return StatusPassing, output, nil</span>
        case grpc_health_v1.HealthCheckResponse_NOT_SERVING:<span class="cov0" title="0">
                output := fmt.Sprintf("gRPC service at %s is not serving (%.3fs)", check.GRPC, duration.Seconds())
                return StatusCritical, output, fmt.Errorf("service not serving")</span>
        case grpc_health_v1.HealthCheckResponse_UNKNOWN:<span class="cov0" title="0">
                output := fmt.Sprintf("gRPC service at %s status unknown (%.3fs)", check.GRPC, duration.Seconds())
                return StatusWarning, output, fmt.Errorf("service status unknown")</span>
        default:<span class="cov0" title="0">
                output := fmt.Sprintf("gRPC service at %s returned unknown status %v (%.3fs)", check.GRPC, resp.Status, duration.Seconds())
                return StatusCritical, output, fmt.Errorf("unknown health status: %v", resp.Status)</span>
        }
}</pre>
		
		<pre class="file" id="file34" style="display: none">package healthcheck

import (
        "context"
        "crypto/tls"
        "fmt"
        "net/http"
        "time"
)

type HTTPChecker struct {
        client *http.Client
}

func NewHTTPChecker() *HTTPChecker <span class="cov0" title="0">{
        return &amp;HTTPChecker{
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                        Transport: &amp;http.Transport{
                                TLSClientConfig: &amp;tls.Config{
                                        InsecureSkipVerify: false,
                                },
                                DisableKeepAlives:   true,
                                MaxIdleConnsPerHost: 1,
                        },
                },
        }
}</span>

func (h *HTTPChecker) Check(ctx context.Context, check *Check) (Status, string, error) <span class="cov0" title="0">{
        if check.HTTP == "" </span><span class="cov0" title="0">{
                return StatusCritical, "HTTP URL not specified", fmt.Errorf("HTTP URL required")
        }</span>

        // Create request with context for timeout
        <span class="cov0" title="0">method := check.Method
        if method == "" </span><span class="cov0" title="0">{
                method = "GET"
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, check.HTTP, nil)
        if err != nil </span><span class="cov0" title="0">{
                return StatusCritical, fmt.Sprintf("Failed to create request: %v", err), err
        }</span>

        // Add custom headers
        <span class="cov0" title="0">for key, value := range check.Headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Set User-Agent
        <span class="cov0" title="0">if req.Header.Get("User-Agent") == "" </span><span class="cov0" title="0">{
                req.Header.Set("User-Agent", "Konsul-Health-Check/1.0")
        }</span>

        // Configure TLS
        <span class="cov0" title="0">if check.TLSSkipVerify </span><span class="cov0" title="0">{
                transport := h.client.Transport.(*http.Transport)
                transport.TLSClientConfig.InsecureSkipVerify = true
        }</span>

        // Set timeout from check
        <span class="cov0" title="0">if check.Timeout &gt; 0 </span><span class="cov0" title="0">{
                h.client.Timeout = check.Timeout
        }</span>

        <span class="cov0" title="0">start := time.Now()
        resp, err := h.client.Do(req)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                return StatusCritical, fmt.Sprintf("Request failed after %v: %v", duration, err), err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check status code
        output := fmt.Sprintf("HTTP %d %s (%.3fs)", resp.StatusCode, resp.Status, duration.Seconds())

        if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov0" title="0">{
                return StatusPassing, output, nil
        }</span> else<span class="cov0" title="0"> if resp.StatusCode &gt;= 300 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                return StatusWarning, output, nil
        }</span> else<span class="cov0" title="0"> {
                return StatusCritical, output, fmt.Errorf("HTTP check failed with status %d", resp.StatusCode)
        }</span>
}</pre>
		
		<pre class="file" id="file35" style="display: none">package healthcheck

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/neogan74/konsul/internal/logger"
)

type Manager struct {
        checks   map[string]*Check
        mutex    sync.RWMutex
        log      logger.Logger
        ctx      context.Context
        cancel   context.CancelFunc
        stopCh   chan struct{}

        httpChecker *HTTPChecker
        tcpChecker  *TCPChecker
        grpcChecker *GRPCChecker
}

func NewManager(log logger.Logger) *Manager <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;Manager{
                checks:      make(map[string]*Check),
                log:         log,
                ctx:         ctx,
                cancel:      cancel,
                stopCh:      make(chan struct{}),
                httpChecker: NewHTTPChecker(),
                tcpChecker:  NewTCPChecker(),
                grpcChecker: NewGRPCChecker(),
        }
}</span>

func (m *Manager) AddCheck(def *CheckDefinition) (*Check, error) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        // Generate ID if not provided
        if def.ID == "" </span><span class="cov0" title="0">{
                def.ID = uuid.New().String()
        }</span>

        // Determine check type
        <span class="cov0" title="0">checkType := CheckTypeTTL
        if def.HTTP != "" </span><span class="cov0" title="0">{
                checkType = CheckTypeHTTP
        }</span> else<span class="cov0" title="0"> if def.TCP != "" </span><span class="cov0" title="0">{
                checkType = CheckTypeTCP
        }</span> else<span class="cov0" title="0"> if def.GRPC != "" </span><span class="cov0" title="0">{
                checkType = CheckTypeGRPC
        }</span> else<span class="cov0" title="0"> if def.TTL != "" </span><span class="cov0" title="0">{
                checkType = CheckTypeTTL
        }</span>

        // Parse durations
        <span class="cov0" title="0">interval := 30 * time.Second
        if def.Interval != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(def.Interval); err == nil </span><span class="cov0" title="0">{
                        interval = parsed
                }</span>
        }

        <span class="cov0" title="0">timeout := 10 * time.Second
        if def.Timeout != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(def.Timeout); err == nil </span><span class="cov0" title="0">{
                        timeout = parsed
                }</span>
        }

        <span class="cov0" title="0">ttl := 0 * time.Second
        if def.TTL != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(def.TTL); err == nil </span><span class="cov0" title="0">{
                        ttl = parsed
                }</span>
        }

        <span class="cov0" title="0">check := &amp;Check{
                ID:            def.ID,
                Name:          def.Name,
                ServiceID:     def.ServiceID,
                Type:          checkType,
                Status:        StatusCritical,
                Interval:      interval,
                Timeout:       timeout,
                HTTP:          def.HTTP,
                Method:        def.Method,
                Headers:       def.Headers,
                TLSSkipVerify: def.TLSSkipVerify,
                TCP:           def.TCP,
                GRPC:          def.GRPC,
                GRPCUseTLS:    def.GRPCUseTLS,
                TTL:           ttl,
                LastCheck:     time.Now(),
        }

        if checkType == CheckTypeTTL &amp;&amp; ttl &gt; 0 </span><span class="cov0" title="0">{
                check.ExpiresAt = time.Now().Add(ttl)
        }</span>

        <span class="cov0" title="0">m.checks[check.ID] = check

        // Start monitoring for non-TTL checks
        if checkType != CheckTypeTTL </span><span class="cov0" title="0">{
                go m.runCheck(check)
        }</span>

        <span class="cov0" title="0">m.log.Info("Health check added",
                logger.String("id", check.ID),
                logger.String("name", check.Name),
                logger.String("type", string(checkType)),
                logger.String("service", check.ServiceID))

        return check, nil</span>
}

func (m *Manager) GetCheck(id string) (*Check, bool) <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        check, exists := m.checks[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // For TTL checks, verify if they're still valid
        <span class="cov0" title="0">if check.Type == CheckTypeTTL &amp;&amp; !check.ExpiresAt.IsZero() &amp;&amp; check.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                check.Status = StatusCritical
                check.Output = "TTL expired"
        }</span>

        <span class="cov0" title="0">return check, true</span>
}

func (m *Manager) ListChecks() []*Check <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        checks := make([]*Check, 0, len(m.checks))
        now := time.Now()

        for _, check := range m.checks </span><span class="cov0" title="0">{
                // Update TTL check status
                if check.Type == CheckTypeTTL &amp;&amp; !check.ExpiresAt.IsZero() &amp;&amp; check.ExpiresAt.Before(now) </span><span class="cov0" title="0">{
                        check.Status = StatusCritical
                        check.Output = "TTL expired"
                }</span>
                <span class="cov0" title="0">checks = append(checks, check)</span>
        }

        <span class="cov0" title="0">return checks</span>
}

func (m *Manager) UpdateTTLCheck(id string) error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        check, exists := m.checks[id]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("check not found")
        }</span>

        <span class="cov0" title="0">if check.Type != CheckTypeTTL </span><span class="cov0" title="0">{
                return fmt.Errorf("check is not a TTL check")
        }</span>

        <span class="cov0" title="0">check.Status = StatusPassing
        check.Output = "TTL check passed"
        check.LastCheck = time.Now()
        if check.TTL &gt; 0 </span><span class="cov0" title="0">{
                check.ExpiresAt = time.Now().Add(check.TTL)
        }</span>

        <span class="cov0" title="0">m.log.Info("TTL check updated",
                logger.String("id", check.ID),
                logger.String("service", check.ServiceID))

        return nil</span>
}

func (m *Manager) RemoveCheck(id string) error <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if _, exists := m.checks[id]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("check not found")
        }</span>

        <span class="cov0" title="0">delete(m.checks, id)

        m.log.Info("Health check removed", logger.String("id", id))
        return nil</span>
}

func (m *Manager) runCheck(check *Check) <span class="cov0" title="0">{
        ticker := time.NewTicker(check.Interval)
        defer ticker.Stop()

        // Run initial check
        m.performCheck(check)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.performCheck(check)</span>
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (m *Manager) performCheck(check *Check) <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        // Check if the check still exists (might have been removed)
        if _, exists := m.checks[check.ID]; !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(m.ctx, check.Timeout)
        defer cancel()

        var status Status
        var output string
        var err error

        switch check.Type </span>{
        case CheckTypeHTTP:<span class="cov0" title="0">
                status, output, err = m.httpChecker.Check(ctx, check)</span>
        case CheckTypeTCP:<span class="cov0" title="0">
                status, output, err = m.tcpChecker.Check(ctx, check)</span>
        case CheckTypeGRPC:<span class="cov0" title="0">
                status, output, err = m.grpcChecker.Check(ctx, check)</span>
        default:<span class="cov0" title="0">
                status = StatusCritical
                output = fmt.Sprintf("Unknown check type: %s", check.Type)
                err = fmt.Errorf("unknown check type")</span>
        }

        <span class="cov0" title="0">check.Status = status
        check.Output = output
        check.LastCheck = time.Now()

        if err != nil </span><span class="cov0" title="0">{
                m.log.Warn("Health check failed",
                        logger.String("id", check.ID),
                        logger.String("name", check.Name),
                        logger.String("type", string(check.Type)),
                        logger.String("status", string(status)),
                        logger.Error(err))
        }</span> else<span class="cov0" title="0"> {
                m.log.Debug("Health check completed",
                        logger.String("id", check.ID),
                        logger.String("name", check.Name),
                        logger.String("type", string(check.Type)),
                        logger.String("status", string(status)))
        }</span>
}

func (m *Manager) Stop() <span class="cov0" title="0">{
        m.cancel()
        close(m.stopCh)
}</pre>
		
		<pre class="file" id="file36" style="display: none">package healthcheck

import (
        "context"
        "fmt"
        "net"
        "time"
)

type TCPChecker struct{}

func NewTCPChecker() *TCPChecker <span class="cov0" title="0">{
        return &amp;TCPChecker{}
}</span>

func (t *TCPChecker) Check(ctx context.Context, check *Check) (Status, string, error) <span class="cov0" title="0">{
        if check.TCP == "" </span><span class="cov0" title="0">{
                return StatusCritical, "TCP address not specified", fmt.Errorf("TCP address required")
        }</span>

        <span class="cov0" title="0">timeout := check.Timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 10 * time.Second
        }</span>

        // Use context with timeout
        <span class="cov0" title="0">dialer := &amp;net.Dialer{
                Timeout: timeout,
        }

        start := time.Now()
        conn, err := dialer.DialContext(ctx, "tcp", check.TCP)
        duration := time.Since(start)

        if err != nil </span><span class="cov0" title="0">{
                output := fmt.Sprintf("TCP connection to %s failed after %v: %v", check.TCP, duration, err)
                return StatusCritical, output, err
        }</span>

        // Immediately close the connection since we only need to test connectivity
        <span class="cov0" title="0">conn.Close()

        output := fmt.Sprintf("TCP connection to %s successful (%.3fs)", check.TCP, duration.Seconds())
        return StatusPassing, output, nil</span>
}</pre>
		
		<pre class="file" id="file37" style="display: none">package logger

import (
        "strings"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// ParseLevel parses string to zapcore.Level
func ParseLevel(s string) zapcore.Level <span class="cov10" title="19">{
        switch strings.ToLower(s) </span>{
        case "debug":<span class="cov5" title="4">
                return zapcore.DebugLevel</span>
        case "info":<span class="cov7" title="8">
                return zapcore.InfoLevel</span>
        case "warn":<span class="cov4" title="3">
                return zapcore.WarnLevel</span>
        case "error":<span class="cov3" title="2">
                return zapcore.ErrorLevel</span>
        default:<span class="cov3" title="2">
                return zapcore.InfoLevel</span>
        }
}

// Field is an alias for zap.Field for interface compatibility
type Field = zap.Field

// Logger interface for structured logging
type Logger interface {
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        WithRequest(requestID string) Logger
        WithFields(fields ...Field) Logger
}

// zapLogger wraps zap.Logger to implement our Logger interface
type zapLogger struct {
        logger *zap.Logger
}

// New creates a new logger with zap
func New(level zapcore.Level, format string) Logger <span class="cov7" title="9">{
        var config zap.Config

        if format == "json" </span><span class="cov6" title="7">{
                config = zap.NewProductionConfig()
        }</span> else<span class="cov3" title="2"> {
                config = zap.NewDevelopmentConfig()
                config.EncoderConfig.EncodeTime = zapcore.RFC3339TimeEncoder
        }</span>

        <span class="cov7" title="9">config.Level = zap.NewAtomicLevelAt(level)

        logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to default logger if build fails
                logger = zap.NewNop()
        }</span>

        <span class="cov7" title="9">return &amp;zapLogger{logger: logger}</span>
}

// NewFromConfig creates a logger from string configuration
func NewFromConfig(level, format string) Logger <span class="cov7" title="9">{
        return New(ParseLevel(level), format)
}</span>

// Debug logs a debug message
func (l *zapLogger) Debug(msg string, fields ...Field) <span class="cov4" title="3">{
        l.logger.Debug(msg, fields...)
}</span>

// Info logs an info message
func (l *zapLogger) Info(msg string, fields ...Field) <span class="cov6" title="7">{
        l.logger.Info(msg, fields...)
}</span>

// Warn logs a warning message
func (l *zapLogger) Warn(msg string, fields ...Field) <span class="cov1" title="1">{
        l.logger.Warn(msg, fields...)
}</span>

// Error logs an error message
func (l *zapLogger) Error(msg string, fields ...Field) <span class="cov1" title="1">{
        l.logger.Error(msg, fields...)
}</span>

// WithRequest returns a new logger with request ID field
func (l *zapLogger) WithRequest(requestID string) Logger <span class="cov1" title="1">{
        return l.WithFields(zap.String("request_id", requestID))
}</span>

// WithFields returns a new logger with additional fields
func (l *zapLogger) WithFields(fields ...Field) Logger <span class="cov3" title="2">{
        return &amp;zapLogger{logger: l.logger.With(fields...)}
}</span>

// Helper functions for creating fields - now using Zap functions
func String(key, value string) Field <span class="cov5" title="5">{
        return zap.String(key, value)
}</span>

func Int(key string, value int) Field <span class="cov4" title="3">{
        return zap.Int(key, value)
}</span>

func Duration(key string, value time.Duration) Field <span class="cov1" title="1">{
        return zap.Duration(key, value)
}</span>

func Error(err error) Field <span class="cov1" title="1">{
        return zap.Error(err)
}</span>

// Default logger instance
var defaultLogger Logger = NewFromConfig("info", "text")

// SetDefault sets the default logger
func SetDefault(l Logger) <span class="cov3" title="2">{
        defaultLogger = l
}</span>

// GetDefault returns the default logger instance
func GetDefault() Logger <span class="cov0" title="0">{
        return defaultLogger
}</span>

// Global logging functions using default logger
func Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Debug(msg, fields...)
}</span>

func Info(msg string, fields ...Field) <span class="cov1" title="1">{
        defaultLogger.Info(msg, fields...)
}</span>

func Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Warn(msg, fields...)
}</span>

func ErrorLog(msg string, fields ...Field) <span class="cov0" title="0">{
        defaultLogger.Error(msg, fields...)
}</pre>
		
		<pre class="file" id="file38" style="display: none">package middleware

import (
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/acl"
)

// ACLMiddleware creates a middleware that enforces ACL policies
func ACLMiddleware(evaluator *acl.Evaluator, resourceType acl.ResourceType, capability acl.Capability) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Get policies from JWT claims
                claims := GetClaims(c)
                if claims == nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "unauthorized",
                        })
                }</span>

                // If no policies are attached, deny access
                <span class="cov0" title="0">if len(claims.Policies) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                                "error":   "forbidden",
                                "message": "no policies attached to token",
                        })
                }</span>

                // Determine the resource being accessed
                <span class="cov0" title="0">var resource acl.Resource
                switch resourceType </span>{
                case acl.ResourceTypeKV:<span class="cov0" title="0">
                        key := c.Params("key")
                        if key == "" </span><span class="cov0" title="0">{
                                key = "*" // List all keys
                        }</span>
                        <span class="cov0" title="0">resource = acl.NewKVResource(key)</span>
                case acl.ResourceTypeService:<span class="cov0" title="0">
                        name := c.Params("name")
                        if name == "" </span><span class="cov0" title="0">{
                                name = "*" // List all services
                        }</span>
                        <span class="cov0" title="0">resource = acl.NewServiceResource(name)</span>
                case acl.ResourceTypeHealth:<span class="cov0" title="0">
                        resource = acl.NewHealthResource()</span>
                case acl.ResourceTypeBackup:<span class="cov0" title="0">
                        resource = acl.NewBackupResource()</span>
                case acl.ResourceTypeAdmin:<span class="cov0" title="0">
                        resource = acl.NewAdminResource()</span>
                }

                // Evaluate ACL policies
                <span class="cov0" title="0">allowed := evaluator.Evaluate(claims.Policies, resource, capability)
                if !allowed </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                                "error":      "forbidden",
                                "message":    "insufficient permissions",
                                "resource":   string(resourceType),
                                "capability": string(capability),
                        })
                }</span>

                // Store resource in context for logging
                <span class="cov0" title="0">c.Locals("acl_resource", resource)
                c.Locals("acl_capability", capability)

                return c.Next()</span>
        }
}

// DynamicACLMiddleware creates a middleware that dynamically determines resource and capability
func DynamicACLMiddleware(evaluator *acl.Evaluator) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Get policies from JWT claims
                claims := GetClaims(c)
                if claims == nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "unauthorized",
                        })
                }</span>

                // If no policies are attached, deny access
                <span class="cov0" title="0">if len(claims.Policies) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                                "error":   "forbidden",
                                "message": "no policies attached to token",
                        })
                }</span>

                // Determine resource and capability from the request
                <span class="cov0" title="0">resource, capability := inferResourceAndCapability(c)

                // Evaluate ACL policies
                allowed := evaluator.Evaluate(claims.Policies, resource, capability)
                if !allowed </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                                "error":      "forbidden",
                                "message":    "insufficient permissions",
                                "resource":   string(resource.Type),
                                "capability": string(capability),
                                "path":       resource.Path,
                        })
                }</span>

                // Store resource in context for logging
                <span class="cov0" title="0">c.Locals("acl_resource", resource)
                c.Locals("acl_capability", capability)

                return c.Next()</span>
        }
}

// inferResourceAndCapability determines the resource and capability from the request
func inferResourceAndCapability(c *fiber.Ctx) (acl.Resource, acl.Capability) <span class="cov0" title="0">{
        path := c.Path()
        method := c.Method()

        // KV store endpoints
        if strings.HasPrefix(path, "/kv/") || path == "/kv" </span><span class="cov0" title="0">{
                key := c.Params("key")
                if key == "" </span><span class="cov0" title="0">{
                        key = "*"
                }</span>
                <span class="cov0" title="0">resource := acl.NewKVResource(key)

                switch method </span>{
                case "GET":<span class="cov0" title="0">
                        if key == "*" || path == "/kv/" || path == "/kv" </span><span class="cov0" title="0">{
                                return resource, acl.CapabilityList
                        }</span>
                        <span class="cov0" title="0">return resource, acl.CapabilityRead</span>
                case "PUT", "POST":<span class="cov0" title="0">
                        return resource, acl.CapabilityWrite</span>
                case "DELETE":<span class="cov0" title="0">
                        return resource, acl.CapabilityDelete</span>
                }
        }

        // Service endpoints
        <span class="cov0" title="0">if strings.HasPrefix(path, "/services/") || strings.HasPrefix(path, "/register") ||
                strings.HasPrefix(path, "/deregister/") || strings.HasPrefix(path, "/heartbeat/") </span><span class="cov0" title="0">{

                serviceName := c.Params("name")
                if serviceName == "" </span><span class="cov0" title="0">{
                        serviceName = "*"
                }</span>
                <span class="cov0" title="0">resource := acl.NewServiceResource(serviceName)

                switch </span>{
                case strings.HasPrefix(path, "/register"):<span class="cov0" title="0">
                        return resource, acl.CapabilityRegister</span>
                case strings.HasPrefix(path, "/deregister/"):<span class="cov0" title="0">
                        return resource, acl.CapabilityDeregister</span>
                case strings.HasPrefix(path, "/heartbeat/"):<span class="cov0" title="0">
                        return resource, acl.CapabilityWrite</span>
                case method == "GET":<span class="cov0" title="0">
                        if serviceName == "*" || path == "/services/" </span><span class="cov0" title="0">{
                                return resource, acl.CapabilityList
                        }</span>
                        <span class="cov0" title="0">return resource, acl.CapabilityRead</span>
                }
        }

        // Health endpoints
        <span class="cov0" title="0">if strings.HasPrefix(path, "/health") </span><span class="cov0" title="0">{
                resource := acl.NewHealthResource()
                switch method </span>{
                case "GET":<span class="cov0" title="0">
                        return resource, acl.CapabilityRead</span>
                case "PUT", "POST":<span class="cov0" title="0">
                        return resource, acl.CapabilityWrite</span>
                }
        }

        // Backup endpoints
        <span class="cov0" title="0">if strings.HasPrefix(path, "/backup") || strings.HasPrefix(path, "/restore") ||
                strings.HasPrefix(path, "/export") || strings.HasPrefix(path, "/import") </span><span class="cov0" title="0">{

                resource := acl.NewBackupResource()
                switch </span>{
                case strings.HasPrefix(path, "/backup"):<span class="cov0" title="0">
                        return resource, acl.CapabilityCreate</span>
                case strings.HasPrefix(path, "/restore"):<span class="cov0" title="0">
                        return resource, acl.CapabilityRestore</span>
                case strings.HasPrefix(path, "/export"):<span class="cov0" title="0">
                        return resource, acl.CapabilityExport</span>
                case strings.HasPrefix(path, "/import"):<span class="cov0" title="0">
                        return resource, acl.CapabilityImport</span>
                }
        }

        // Admin endpoints (ACL management, metrics, etc.)
        <span class="cov0" title="0">if strings.HasPrefix(path, "/acl/") || strings.HasPrefix(path, "/metrics") </span><span class="cov0" title="0">{
                resource := acl.NewAdminResource()
                switch method </span>{
                case "GET":<span class="cov0" title="0">
                        return resource, acl.CapabilityRead</span>
                case "PUT", "POST", "DELETE":<span class="cov0" title="0">
                        return resource, acl.CapabilityWrite</span>
                }
        }

        // Default: deny
        <span class="cov0" title="0">return acl.Resource{Type: acl.ResourceTypeAdmin}, acl.CapabilityDeny</span>
}

// GetACLResource returns the ACL resource from context
func GetACLResource(c *fiber.Ctx) *acl.Resource <span class="cov0" title="0">{
        if resource, ok := c.Locals("acl_resource").(acl.Resource); ok </span><span class="cov0" title="0">{
                return &amp;resource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetACLCapability returns the ACL capability from context
func GetACLCapability(c *fiber.Ctx) acl.Capability <span class="cov0" title="0">{
        if cap, ok := c.Locals("acl_capability").(acl.Capability); ok </span><span class="cov0" title="0">{
                return cap
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package middleware

import (
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/auth"
)

// APIKeyAuth creates a middleware for API key authentication
func APIKeyAuth(apiKeyService *auth.APIKeyService, publicPaths []string) fiber.Handler <span class="cov0" title="0">{
        // Create a map for faster path lookup
        publicPathMap := make(map[string]bool)
        for _, path := range publicPaths </span><span class="cov0" title="0">{
                publicPathMap[path] = true
        }</span>

        <span class="cov0" title="0">return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Check if path is public
                if publicPathMap[c.Path()] </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                // Try to get API key from X-API-Key header first
                <span class="cov0" title="0">apiKey := c.Get("X-API-Key")

                // If not found, try Authorization header with "ApiKey" scheme
                if apiKey == "" </span><span class="cov0" title="0">{
                        authHeader := c.Get("Authorization")
                        if authHeader != "" </span><span class="cov0" title="0">{
                                parts := strings.Split(authHeader, " ")
                                if len(parts) == 2 &amp;&amp; parts[0] == "ApiKey" </span><span class="cov0" title="0">{
                                        apiKey = parts[1]
                                }</span>
                        }
                }

                // If still no API key found, return unauthorized
                <span class="cov0" title="0">if apiKey == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "missing API key",
                        })
                }</span>

                // Validate API key
                <span class="cov0" title="0">key, err := apiKeyService.ValidateAPIKey(apiKey)
                if err != nil </span><span class="cov0" title="0">{
                        switch err </span>{
                        case auth.ErrAPIKeyExpired:<span class="cov0" title="0">
                                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                        "error": "API key expired",
                                })</span>
                        case auth.ErrAPIKeyDisabled:<span class="cov0" title="0">
                                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                        "error": "API key disabled",
                                })</span>
                        case auth.ErrAPIKeyNotFound:<span class="cov0" title="0">
                                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                        "error": "invalid API key",
                                })</span>
                        default:<span class="cov0" title="0">
                                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                        "error": "API key validation failed",
                                })</span>
                        }
                }

                // Store API key info in context
                <span class="cov0" title="0">c.Locals("api_key_id", key.ID)
                c.Locals("api_key_name", key.Name)
                c.Locals("api_key_permissions", key.Permissions)
                c.Locals("api_key_metadata", key.Metadata)
                c.Locals("api_key", key)

                return c.Next()</span>
        }
}

// GetAPIKeyID returns the API key ID from the context
func GetAPIKeyID(c *fiber.Ctx) string <span class="cov0" title="0">{
        if id, ok := c.Locals("api_key_id").(string); ok </span><span class="cov0" title="0">{
                return id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetAPIKeyName returns the API key name from the context
func GetAPIKeyName(c *fiber.Ctx) string <span class="cov0" title="0">{
        if name, ok := c.Locals("api_key_name").(string); ok </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetAPIKeyPermissions returns the API key permissions from the context
func GetAPIKeyPermissions(c *fiber.Ctx) []string <span class="cov0" title="0">{
        if perms, ok := c.Locals("api_key_permissions").([]string); ok </span><span class="cov0" title="0">{
                return perms
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

// GetAPIKey returns the full API key from the context
func GetAPIKey(c *fiber.Ctx) *auth.APIKey <span class="cov0" title="0">{
        if key, ok := c.Locals("api_key").(*auth.APIKey); ok </span><span class="cov0" title="0">{
                return key
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// HasPermission checks if the API key has a specific permission
func HasPermission(c *fiber.Ctx, permission string) bool <span class="cov0" title="0">{
        perms := GetAPIKeyPermissions(c)
        for _, p := range perms </span><span class="cov0" title="0">{
                if p == permission || p == "*" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RequirePermission creates a middleware that requires a specific permission
func RequirePermission(permission string) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                if !HasPermission(c, permission) </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                                "error": "insufficient permissions",
                        })
                }</span>
                <span class="cov0" title="0">return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package middleware

import (
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/logger"
)

// ErrorResponse represents a structured error response
type ErrorResponse struct {
        Error     string    `json:"error"`
        Message   string    `json:"message,omitempty"`
        RequestID string    `json:"request_id,omitempty"`
        Timestamp time.Time `json:"timestamp"`
        Path      string    `json:"path,omitempty"`
}

// BadRequest returns a 400 Bad Request error response
func BadRequest(c *fiber.Ctx, message string) error <span class="cov0" title="0">{
        return errorResponse(c, fiber.StatusBadRequest, "Bad Request", message)
}</span>

// NotFound returns a 404 Not Found error response
func NotFound(c *fiber.Ctx, message string) error <span class="cov0" title="0">{
        return errorResponse(c, fiber.StatusNotFound, "Not Found", message)
}</span>

// InternalServerError returns a 500 Internal Server Error response
func InternalServerError(c *fiber.Ctx, message string) error <span class="cov0" title="0">{
        return errorResponse(c, fiber.StatusInternalServerError, "Internal Server Error", message)
}</span>

// UnprocessableEntity returns a 422 Unprocessable Entity error response
func UnprocessableEntity(c *fiber.Ctx, message string) error <span class="cov0" title="0">{
        return errorResponse(c, fiber.StatusUnprocessableEntity, "Unprocessable Entity", message)
}</span>

// Conflict returns a 409 Conflict error response
func Conflict(c *fiber.Ctx, message string) error <span class="cov0" title="0">{
        return errorResponse(c, fiber.StatusConflict, "Conflict", message)
}</span>

// InternalError returns a 500 Internal Server Error response (alias for InternalServerError)
func InternalError(c *fiber.Ctx, message string) error <span class="cov0" title="0">{
        return InternalServerError(c, message)
}</span>

// errorResponse creates a structured error response
func errorResponse(c *fiber.Ctx, status int, error string, message string) error <span class="cov0" title="0">{
        response := ErrorResponse{
                Error:     error,
                Message:   message,
                RequestID: GetRequestID(c),
                Timestamp: time.Now(),
                Path:      c.Path(),
        }

        // Log the error with context
        log := GetLogger(c)
        log.Error("HTTP error response",
                logger.String("error", error),
                logger.String("message", message),
                logger.String("method", c.Method()),
                logger.String("path", c.Path()),
                logger.Int("status", status),
                logger.String("user_ip", c.IP()),
        )

        return c.Status(status).JSON(response)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package middleware

import (
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/auth"
)

// JWTAuth creates a middleware for JWT authentication
func JWTAuth(jwtService *auth.JWTService, publicPaths []string) fiber.Handler <span class="cov0" title="0">{
        // Create a map for faster path lookup
        publicPathMap := make(map[string]bool)
        for _, path := range publicPaths </span><span class="cov0" title="0">{
                publicPathMap[path] = true
        }</span>

        <span class="cov0" title="0">return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Check if path is public
                if publicPathMap[c.Path()] </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                // Get token from Authorization header
                <span class="cov0" title="0">authHeader := c.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "missing authorization header",
                        })
                }</span>

                // Extract token from "Bearer &lt;token&gt;"
                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                "error": "invalid authorization header format",
                        })
                }</span>

                <span class="cov0" title="0">token := parts[1]

                // Validate token
                claims, err := jwtService.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        switch err </span>{
                        case auth.ErrTokenExpired:<span class="cov0" title="0">
                                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                        "error": "token expired",
                                })</span>
                        case auth.ErrTokenMissing:<span class="cov0" title="0">
                                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                        "error": "token missing",
                                })</span>
                        default:<span class="cov0" title="0">
                                return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
                                        "error": "invalid token",
                                })</span>
                        }
                }

                // Store claims in context
                <span class="cov0" title="0">c.Locals("user_id", claims.UserID)
                c.Locals("username", claims.Username)
                c.Locals("roles", claims.Roles)
                c.Locals("claims", claims)

                return c.Next()</span>
        }
}

// GetUserID returns the user ID from the context
func GetUserID(c *fiber.Ctx) string <span class="cov0" title="0">{
        if userID, ok := c.Locals("user_id").(string); ok </span><span class="cov0" title="0">{
                return userID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetUsername returns the username from the context
func GetUsername(c *fiber.Ctx) string <span class="cov0" title="0">{
        if username, ok := c.Locals("username").(string); ok </span><span class="cov0" title="0">{
                return username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetRoles returns the roles from the context
func GetRoles(c *fiber.Ctx) []string <span class="cov0" title="0">{
        if roles, ok := c.Locals("roles").([]string); ok </span><span class="cov0" title="0">{
                return roles
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

// GetClaims returns the JWT claims from the context
func GetClaims(c *fiber.Ctx) *auth.Claims <span class="cov0" title="0">{
        if claims, ok := c.Locals("claims").(*auth.Claims); ok </span><span class="cov0" title="0">{
                return claims
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// HasRole checks if the user has a specific role
func HasRole(c *fiber.Ctx, role string) bool <span class="cov0" title="0">{
        roles := GetRoles(c)
        for _, r := range roles </span><span class="cov0" title="0">{
                if r == role </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RequireRole creates a middleware that requires a specific role
func RequireRole(role string) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                if !HasRole(c, role) </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                                "error": "insufficient permissions",
                        })
                }</span>
                <span class="cov0" title="0">return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package middleware

import (
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "github.com/neogan74/konsul/internal/logger"
)

// RequestIDKey is the context key for request ID
const RequestIDKey = "request_id"

// LoggerKey is the context key for logger instance
const LoggerKey = "logger"

// RequestLogging creates a middleware for request/response logging with correlation IDs
func RequestLogging(log logger.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Generate request ID
                requestID := uuid.New().String()

                // Store request ID in context
                c.Locals(RequestIDKey, requestID)

                // Create request-scoped logger
                requestLogger := log.WithRequest(requestID)
                c.Locals(LoggerKey, requestLogger)

                // Log request
                start := time.Now()
                requestLogger.Info("Request started",
                        logger.String("method", c.Method()),
                        logger.String("path", c.Path()),
                        logger.String("ip", c.IP()),
                        logger.String("user_agent", c.Get("User-Agent")),
                )

                // Process request
                err := c.Next()

                // Calculate duration
                duration := time.Since(start)

                // Log response
                status := c.Response().StatusCode()
                logFields := []logger.Field{
                        logger.String("method", c.Method()),
                        logger.String("path", c.Path()),
                        logger.Int("status", status),
                        logger.Duration("duration", duration),
                        logger.Int("response_size", len(c.Response().Body())),
                }

                // Log level based on status code
                switch </span>{
                case status &gt;= 500:<span class="cov0" title="0">
                        requestLogger.Error("Request completed", logFields...)</span>
                case status &gt;= 400:<span class="cov0" title="0">
                        requestLogger.Warn("Request completed", logFields...)</span>
                default:<span class="cov0" title="0">
                        requestLogger.Info("Request completed", logFields...)</span>
                }

                // Log error if present
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        requestLogger.Error("Request error",
                                logger.Error(err),
                                logger.String("method", c.Method()),
                                logger.String("path", c.Path()),
                        )
                }</span>

                <span class="cov0" title="0">return err</span>
        }
}

// GetRequestID returns the request ID from the context
func GetRequestID(c *fiber.Ctx) string <span class="cov0" title="0">{
        if requestID, ok := c.Locals(RequestIDKey).(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetLogger returns the request-scoped logger from the context
func GetLogger(c *fiber.Ctx) logger.Logger <span class="cov0" title="0">{
        if log, ok := c.Locals(LoggerKey).(logger.Logger); ok </span><span class="cov0" title="0">{
                return log
        }</span>
        // Return default logger as fallback
        <span class="cov0" title="0">return logger.NewFromConfig("info", "text")</span>
}</pre>
		
		<pre class="file" id="file43" style="display: none">package middleware

import (
        "strconv"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/metrics"
)

// MetricsMiddleware tracks HTTP request metrics
func MetricsMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Skip metrics endpoint to avoid infinite loop
                if c.Path() == "/metrics" </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                // Increment in-flight requests
                <span class="cov0" title="0">metrics.HTTPRequestsInFlight.Inc()
                defer metrics.HTTPRequestsInFlight.Dec()

                // Start timer
                start := time.Now()

                // Process request
                err := c.Next()

                // Calculate duration
                duration := time.Since(start).Seconds()

                // Get status code
                status := strconv.Itoa(c.Response().StatusCode())

                // Record metrics
                metrics.HTTPRequestsTotal.WithLabelValues(
                        c.Method(),
                        c.Path(),
                        status,
                ).Inc()

                metrics.HTTPRequestDuration.WithLabelValues(
                        c.Method(),
                        c.Path(),
                        status,
                ).Observe(duration)

                return err</span>
        }
}</pre>
		
		<pre class="file" id="file44" style="display: none">package middleware

import (
        "fmt"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/neogan74/konsul/internal/metrics"
        "github.com/neogan74/konsul/internal/ratelimit"
)

// RateLimitMiddleware creates a middleware for rate limiting
func RateLimitMiddleware(service *ratelimit.Service) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Get client identifier (IP or API key from context)
                clientIP := c.IP()
                apiKeyID := ""

                // Try to get API key ID from context (set by API key auth middleware)
                if id, ok := c.Locals("api_key_id").(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                        apiKeyID = id
                }</span>

                <span class="cov0" title="0">var allowed bool
                var identifier string

                // Check API key rate limit first if available
                var limiterType string
                if apiKeyID != "" </span><span class="cov0" title="0">{
                        allowed = service.AllowAPIKey(apiKeyID)
                        identifier = fmt.Sprintf("apikey:%s", apiKeyID)
                        limiterType = "apikey"
                }</span> else<span class="cov0" title="0"> {
                        // Fall back to IP-based rate limiting
                        allowed = service.AllowIP(clientIP)
                        identifier = fmt.Sprintf("ip:%s", clientIP)
                        limiterType = "ip"
                }</span>

                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        // Record rate limit exceeded
                        metrics.RateLimitExceeded.WithLabelValues(limiterType).Inc()
                        metrics.RateLimitRequestsTotal.WithLabelValues(limiterType, "exceeded").Inc()

                        // Rate limit exceeded
                        c.Set("X-RateLimit-Limit", "exceeded")
                        c.Set("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(time.Second).Unix()))

                        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
                                "error":      "rate limit exceeded",
                                "message":    "Too many requests. Please try again later.",
                                "identifier": identifier,
                        })
                }</span>

                // Record successful rate limit check
                <span class="cov0" title="0">metrics.RateLimitRequestsTotal.WithLabelValues(limiterType, "allowed").Inc()

                // Set rate limit headers (informational)
                c.Set("X-RateLimit-Limit", "ok")

                return c.Next()</span>
        }
}

// RateLimitWithConfig creates a middleware with custom configuration for specific endpoints
func RateLimitWithConfig(requestsPerSec float64, burst int) fiber.Handler <span class="cov0" title="0">{
        limiter := ratelimit.NewStore(requestsPerSec, burst, 5*time.Minute)

        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                clientIP := c.IP()
                apiKeyID := ""

                // Try to get API key ID from context (set by API key auth middleware)
                if id, ok := c.Locals("api_key_id").(string); ok &amp;&amp; id != "" </span><span class="cov0" title="0">{
                        apiKeyID = id
                }</span>

                <span class="cov0" title="0">identifier := clientIP
                if apiKeyID != "" </span><span class="cov0" title="0">{
                        identifier = apiKeyID
                }</span>

                <span class="cov0" title="0">if !limiter.Allow(identifier) </span><span class="cov0" title="0">{
                        c.Set("X-RateLimit-Limit", "exceeded")
                        c.Set("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(time.Second).Unix()))

                        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
                                "error":   "rate limit exceeded",
                                "message": "Too many requests. Please try again later.",
                        })
                }</span>

                <span class="cov0" title="0">c.Set("X-RateLimit-Limit", "ok")
                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package middleware

import (
        "github.com/gofiber/fiber/v2"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
        "go.opentelemetry.io/otel/trace"
)

// TracingMiddleware creates a middleware for OpenTelemetry tracing
func TracingMiddleware(serviceName string) fiber.Handler <span class="cov0" title="0">{
        tracer := otel.Tracer(serviceName)

        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Extract context from incoming request (W3C Trace Context)
                ctx := otel.GetTextMapPropagator().Extract(c.UserContext(), &amp;fiberCarrier{c: c})

                // Start a new span
                spanName := c.Method() + " " + c.Route().Path
                if spanName == " " </span><span class="cov0" title="0">{
                        spanName = c.Method() + " " + c.Path()
                }</span>

                <span class="cov0" title="0">ctx, span := tracer.Start(ctx, spanName,
                        trace.WithSpanKind(trace.SpanKindServer),
                        trace.WithAttributes(
                                semconv.HTTPMethod(c.Method()),
                                semconv.HTTPURL(c.OriginalURL()),
                                semconv.HTTPRoute(c.Route().Path),
                                semconv.HTTPScheme(c.Protocol()),
                                semconv.HTTPTarget(c.Path()),
                                semconv.NetHostName(c.Hostname()),
                                attribute.String("http.user_agent", c.Get("User-Agent")),
                                attribute.String("http.client_ip", c.IP()),
                        ),
                )
                defer span.End()

                // Store context in fiber context
                c.SetUserContext(ctx)

                // Store trace ID in locals for logging correlation
                if span.SpanContext().HasTraceID() </span><span class="cov0" title="0">{
                        c.Locals("trace_id", span.SpanContext().TraceID().String())
                        c.Set("X-Trace-Id", span.SpanContext().TraceID().String())
                }</span>

                // Continue processing
                <span class="cov0" title="0">err := c.Next()

                // Set span status based on response
                statusCode := c.Response().StatusCode()
                span.SetAttributes(semconv.HTTPStatusCode(statusCode))

                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)
                        span.SetStatus(codes.Error, err.Error())
                        return err
                }</span>

                // Set span status based on HTTP status code
                <span class="cov0" title="0">if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "Internal server error")
                }</span> else<span class="cov0" title="0"> if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        span.SetStatus(codes.Error, "Client error")
                }</span> else<span class="cov0" title="0"> {
                        span.SetStatus(codes.Ok, "")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

// fiberCarrier adapts fiber.Ctx to propagation.TextMapCarrier
type fiberCarrier struct {
        c *fiber.Ctx
}

func (fc *fiberCarrier) Get(key string) string <span class="cov0" title="0">{
        return fc.c.Get(key)
}</span>

func (fc *fiberCarrier) Set(key, value string) <span class="cov0" title="0">{
        fc.c.Set(key, value)
}</span>

func (fc *fiberCarrier) Keys() []string <span class="cov0" title="0">{
        keys := make([]string, 0)
        fc.c.Request().Header.VisitAll(func(key, _ []byte) </span><span class="cov0" title="0">{
                keys = append(keys, string(key))
        }</span>)
        <span class="cov0" title="0">return keys</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package persistence

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        badger "github.com/dgraph-io/badger/v4"
        "github.com/neogan74/konsul/internal/logger"
)

const (
        kvPrefix      = "kv:"
        servicePrefix = "svc:"
)

// BadgerEngine implements Engine using BadgerDB
type BadgerEngine struct {
        db  *badger.DB
        log logger.Logger
}

// NewBadgerEngine creates a new BadgerDB persistence engine
func NewBadgerEngine(dataDir string, syncWrites bool, log logger.Logger) (*BadgerEngine, error) <span class="cov7" title="6">{
        // Create directory if it doesn't exist
        if err := os.MkdirAll(dataDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create data directory: %w", err)
        }</span>

        <span class="cov7" title="6">opts := badger.DefaultOptions(dataDir)
        opts.SyncWrites = syncWrites
        opts.Logger = nil // Disable BadgerDB internal logging or wrap it

        // WAL configuration for crash recovery
        opts.ValueLogFileSize = 64 &lt;&lt; 20 // 64MB value log files
        opts.MemTableSize = 64 &lt;&lt; 20     // 64MB memtable
        opts.NumMemtables = 5            // Keep 5 memtables in memory
        opts.NumLevelZeroTables = 5      // Maximum L0 tables before compaction
        opts.NumLevelZeroTablesStall = 10 // Stall writes when this many L0 tables

        // Enable compression for better storage efficiency
        opts.Compression = 1 // Snappy compression

        // Configure for durability
        if syncWrites </span><span class="cov7" title="6">{
                opts.SyncWrites = true
                log.Info("WAL enabled with synchronous writes for maximum durability")
        }</span> else<span class="cov0" title="0"> {
                opts.SyncWrites = false
                log.Info("WAL enabled with asynchronous writes for better performance")
        }</span>

        <span class="cov7" title="6">db, err := badger.Open(opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open BadgerDB: %w", err)
        }</span>

        <span class="cov7" title="6">engine := &amp;BadgerEngine{
                db:  db,
                log: log,
        }

        // Start garbage collection routine
        go engine.runGarbageCollection()

        log.Info("BadgerDB persistence engine initialized with WAL support",
                logger.String("data_dir", dataDir),
                logger.String("sync_writes", fmt.Sprintf("%t", syncWrites)))

        return engine, nil</span>
}

func (b *BadgerEngine) runGarbageCollection() <span class="cov7" title="6">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                err := b.db.RunValueLogGC(0.5)
                if err != nil &amp;&amp; !errors.Is(err, badger.ErrNoRewrite) </span><span class="cov0" title="0">{
                        b.log.Warn("BadgerDB garbage collection failed", logger.Error(err))
                }</span>
        }
}

func (b *BadgerEngine) Get(key string) ([]byte, error) <span class="cov10" title="12">{
        var value []byte
        err := b.db.View(func(txn *badger.Txn) error </span><span class="cov10" title="12">{
                item, err := txn.Get([]byte(kvPrefix + key))
                if err != nil </span><span class="cov6" title="4">{
                        return err
                }</span>
                <span class="cov8" title="8">value, err = item.ValueCopy(nil)
                return err</span>
        })
        <span class="cov10" title="12">if errors.Is(err, badger.ErrKeyNotFound) </span><span class="cov6" title="4">{
                return nil, errors.New("key not found")
        }</span>
        <span class="cov8" title="8">return value, err</span>
}

func (b *BadgerEngine) Set(key string, value []byte) error <span class="cov4" title="3">{
        return b.db.Update(func(txn *badger.Txn) error </span><span class="cov4" title="3">{
                return txn.Set([]byte(kvPrefix+key), value)
        }</span>)
}

func (b *BadgerEngine) Delete(key string) error <span class="cov1" title="1">{
        return b.db.Update(func(txn *badger.Txn) error </span><span class="cov1" title="1">{
                return txn.Delete([]byte(kvPrefix + key))
        }</span>)
}

func (b *BadgerEngine) List(prefix string) ([]string, error) <span class="cov1" title="1">{
        var keys []string
        searchPrefix := kvPrefix + prefix

        err := b.db.View(func(txn *badger.Txn) error </span><span class="cov1" title="1">{
                opts := badger.DefaultIteratorOptions
                opts.PrefetchValues = false
                it := txn.NewIterator(opts)
                defer it.Close()

                prefixBytes := []byte(searchPrefix)
                for it.Seek(prefixBytes); it.ValidForPrefix(prefixBytes); it.Next() </span><span class="cov1" title="1">{
                        item := it.Item()
                        key := string(item.Key())
                        // Remove the kvPrefix from the key
                        keys = append(keys, strings.TrimPrefix(key, kvPrefix))
                }</span>
                <span class="cov1" title="1">return nil</span>
        })
        <span class="cov1" title="1">return keys, err</span>
}

func (b *BadgerEngine) GetService(name string) ([]byte, error) <span class="cov3" title="2">{
        var data []byte
        err := b.db.View(func(txn *badger.Txn) error </span><span class="cov3" title="2">{
                item, err := txn.Get([]byte(servicePrefix + name))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                // Check if expired
                <span class="cov1" title="1">if item.ExpiresAt() != 0 &amp;&amp; time.Now().Unix() &gt; int64(item.ExpiresAt()) </span><span class="cov0" title="0">{
                        return errors.New("service expired")
                }</span>

                <span class="cov1" title="1">data, err = item.ValueCopy(nil)
                return err</span>
        })
        <span class="cov3" title="2">if errors.Is(err, badger.ErrKeyNotFound) </span><span class="cov1" title="1">{
                return nil, errors.New("service not found")
        }</span>
        <span class="cov1" title="1">return data, err</span>
}

func (b *BadgerEngine) SetService(name string, data []byte, ttl time.Duration) error <span class="cov1" title="1">{
        return b.db.Update(func(txn *badger.Txn) error </span><span class="cov1" title="1">{
                e := badger.NewEntry([]byte(servicePrefix+name), data).WithTTL(ttl)
                return txn.SetEntry(e)
        }</span>)
}

func (b *BadgerEngine) DeleteService(name string) error <span class="cov0" title="0">{
        return b.db.Update(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                return txn.Delete([]byte(servicePrefix + name))
        }</span>)
}

func (b *BadgerEngine) ListServices() ([]string, error) <span class="cov3" title="2">{
        var names []string
        err := b.db.View(func(txn *badger.Txn) error </span><span class="cov3" title="2">{
                opts := badger.DefaultIteratorOptions
                opts.PrefetchValues = false
                it := txn.NewIterator(opts)
                defer it.Close()

                prefixBytes := []byte(servicePrefix)
                now := time.Now().Unix()

                for it.Seek(prefixBytes); it.ValidForPrefix(prefixBytes); it.Next() </span><span class="cov1" title="1">{
                        item := it.Item()
                        // Skip expired items
                        if item.ExpiresAt() != 0 &amp;&amp; now &gt; int64(item.ExpiresAt()) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov1" title="1">key := string(item.Key())
                        names = append(names, strings.TrimPrefix(key, servicePrefix))</span>
                }
                <span class="cov3" title="2">return nil</span>
        })
        <span class="cov3" title="2">return names, err</span>
}

func (b *BadgerEngine) BatchSet(items map[string][]byte) error <span class="cov1" title="1">{
        return b.db.Update(func(txn *badger.Txn) error </span><span class="cov1" title="1">{
                for key, value := range items </span><span class="cov4" title="3">{
                        if err := txn.Set([]byte(kvPrefix+key), value); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov1" title="1">return nil</span>
        })
}

func (b *BadgerEngine) BatchDelete(keys []string) error <span class="cov1" title="1">{
        return b.db.Update(func(txn *badger.Txn) error </span><span class="cov1" title="1">{
                for _, key := range keys </span><span class="cov3" title="2">{
                        if err := txn.Delete([]byte(kvPrefix + key)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov1" title="1">return nil</span>
        })
}

func (b *BadgerEngine) Close() error <span class="cov7" title="6">{
        return b.db.Close()
}</span>

func (b *BadgerEngine) Backup(path string) error <span class="cov1" title="1">{
        // Ensure backup directory exists
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        <span class="cov1" title="1">file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup file: %w", err)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        _, err = b.db.Backup(file, 0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("backup failed: %w", err)
        }</span>

        <span class="cov1" title="1">b.log.Info("Backup completed successfully", logger.String("path", path))
        return nil</span>
}

func (b *BadgerEngine) Restore(path string) error <span class="cov1" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open backup file: %w", err)
        }</span>
        <span class="cov1" title="1">defer file.Close()

        err = b.db.Load(file, 256)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("restore failed: %w", err)
        }</span>

        <span class="cov1" title="1">b.log.Info("Restore completed successfully", logger.String("path", path))
        return nil</span>
}

func (b *BadgerEngine) BeginTx() (Transaction, error) <span class="cov3" title="2">{
        txn := b.db.NewTransaction(true)
        return &amp;badgerTx{txn: txn}, nil
}</span>

// badgerTx implements Transaction for BadgerDB
type badgerTx struct {
        txn *badger.Txn
}

func (tx *badgerTx) Set(key string, value []byte) error <span class="cov4" title="3">{
        return tx.txn.Set([]byte(kvPrefix+key), value)
}</span>

func (tx *badgerTx) Delete(key string) error <span class="cov0" title="0">{
        return tx.txn.Delete([]byte(kvPrefix + key))
}</span>

func (tx *badgerTx) Commit() error <span class="cov1" title="1">{
        return tx.txn.Commit()
}</span>

func (tx *badgerTx) Rollback() error <span class="cov1" title="1">{
        tx.txn.Discard()
        return nil
}</span>

// ExportData exports all data to JSON (useful for debugging)
func (b *BadgerEngine) ExportData() (map[string]interface{}, error) <span class="cov0" title="0">{
        result := make(map[string]interface{})
        kvData := make(map[string]string)
        svcData := make(map[string]interface{})

        err := b.db.View(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                opts := badger.DefaultIteratorOptions
                it := txn.NewIterator(opts)
                defer it.Close()

                for it.Rewind(); it.Valid(); it.Next() </span><span class="cov0" title="0">{
                        item := it.Item()
                        key := string(item.Key())

                        var value []byte
                        err := item.Value(func(val []byte) error </span><span class="cov0" title="0">{
                                value = append([]byte{}, val...)
                                return nil
                        }</span>)
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if strings.HasPrefix(key, kvPrefix) </span><span class="cov0" title="0">{
                                kvData[strings.TrimPrefix(key, kvPrefix)] = string(value)
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(key, servicePrefix) </span><span class="cov0" title="0">{
                                var svcInfo map[string]interface{}
                                if err := json.Unmarshal(value, &amp;svcInfo); err == nil </span><span class="cov0" title="0">{
                                        svcData[strings.TrimPrefix(key, servicePrefix)] = svcInfo
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">result["kv"] = kvData
        result["services"] = svcData
        return result, err</span>
}

// ImportData imports data from JSON
func (b *BadgerEngine) ImportData(data map[string]interface{}) error <span class="cov0" title="0">{
        return b.db.Update(func(txn *badger.Txn) error </span><span class="cov0" title="0">{
                // Import KV data
                if kvData, ok := data["kv"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for key, value := range kvData </span><span class="cov0" title="0">{
                                if strVal, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        if err := txn.Set([]byte(kvPrefix+key), []byte(strVal)); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }

                // Import service data
                <span class="cov0" title="0">if svcData, ok := data["services"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for name, svcInfo := range svcData </span><span class="cov0" title="0">{
                                jsonData, err := json.Marshal(svcInfo)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if err := txn.Set([]byte(servicePrefix+name), jsonData); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov0" title="0">return nil</span>
        })
}</pre>
		
		<pre class="file" id="file47" style="display: none">package persistence

import (
        "fmt"

        "github.com/neogan74/konsul/internal/logger"
)

// NewEngine creates a persistence engine based on configuration
func NewEngine(cfg Config, log logger.Logger) (Engine, error) <span class="cov0" title="0">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                log.Info("Persistence disabled, using in-memory storage")
                return NewMemoryEngine(), nil
        }</span>

        <span class="cov0" title="0">switch cfg.Type </span>{
        case "memory":<span class="cov0" title="0">
                log.Info("Using in-memory persistence")
                return NewMemoryEngine(), nil</span>
        case "badger":<span class="cov0" title="0">
                log.Info("Using BadgerDB persistence",
                        logger.String("data_dir", cfg.DataDir),
                        logger.String("sync_writes", fmt.Sprintf("%t", cfg.SyncWrites)))
                return NewBadgerEngine(cfg.DataDir, cfg.SyncWrites, log)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported persistence type: %s", cfg.Type)</span>
        }
}</pre>
		
		<pre class="file" id="file48" style="display: none">package persistence

import (
        "encoding/json"
        "errors"
        "os"
        "strings"
        "sync"
        "time"
)

// MemoryEngine is an in-memory implementation of Engine
type MemoryEngine struct {
        mu       sync.RWMutex
        kvData   map[string][]byte
        svcData  map[string]serviceEntry
}

type serviceEntry struct {
        Data      []byte
        ExpiresAt time.Time
}

// NewMemoryEngine creates a new in-memory persistence engine
func NewMemoryEngine() *MemoryEngine <span class="cov8" title="6">{
        return &amp;MemoryEngine{
                kvData:  make(map[string][]byte),
                svcData: make(map[string]serviceEntry),
        }
}</span>

func (m *MemoryEngine) Get(key string) ([]byte, error) <span class="cov10" title="10">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if val, ok := m.kvData[key]; ok </span><span class="cov8" title="6">{
                return val, nil
        }</span>
        <span class="cov6" title="4">return nil, errors.New("key not found")</span>
}

func (m *MemoryEngine) Set(key string, value []byte) error <span class="cov5" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.kvData[key] = value
        return nil
}</span>

func (m *MemoryEngine) Delete(key string) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        delete(m.kvData, key)
        return nil
}</span>

func (m *MemoryEngine) List(prefix string) ([]string, error) <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var keys []string
        for key := range m.kvData </span><span class="cov5" title="3">{
                if strings.HasPrefix(key, prefix) </span><span class="cov5" title="3">{
                        keys = append(keys, key)
                }</span>
        }
        <span class="cov3" title="2">return keys, nil</span>
}

func (m *MemoryEngine) GetService(name string) ([]byte, error) <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if entry, ok := m.svcData[name]; ok </span><span class="cov3" title="2">{
                if time.Now().Before(entry.ExpiresAt) </span><span class="cov1" title="1">{
                        return entry.Data, nil
                }</span>
        }
        <span class="cov1" title="1">return nil, errors.New("service not found")</span>
}

func (m *MemoryEngine) SetService(name string, data []byte, ttl time.Duration) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.svcData[name] = serviceEntry{
                Data:      data,
                ExpiresAt: time.Now().Add(ttl),
        }
        return nil
}</span>

func (m *MemoryEngine) DeleteService(name string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        delete(m.svcData, name)
        return nil
}</span>

func (m *MemoryEngine) ListServices() ([]string, error) <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var names []string
        now := time.Now()
        for name, entry := range m.svcData </span><span class="cov3" title="2">{
                if now.Before(entry.ExpiresAt) </span><span class="cov1" title="1">{
                        names = append(names, name)
                }</span>
        }
        <span class="cov3" title="2">return names, nil</span>
}

func (m *MemoryEngine) BatchSet(items map[string][]byte) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for key, value := range items </span><span class="cov5" title="3">{
                m.kvData[key] = value
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (m *MemoryEngine) BatchDelete(keys []string) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, key := range keys </span><span class="cov3" title="2">{
                delete(m.kvData, key)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (m *MemoryEngine) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (m *MemoryEngine) Backup(path string) error <span class="cov1" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        data := map[string]interface{}{
                "kv":       m.kvData,
                "services": m.svcData,
        }

        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return os.WriteFile(path, jsonData, 0644)</span>
}

func (m *MemoryEngine) Restore(path string) error <span class="cov1" title="1">{
        jsonData, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">var data map[string]interface{}
        if err := json.Unmarshal(jsonData, &amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        // Clear existing data
        m.kvData = make(map[string][]byte)
        m.svcData = make(map[string]serviceEntry)

        // Restore KV data
        if kvData, ok := data["kv"].(map[string]interface{}); ok </span><span class="cov1" title="1">{
                for key, value := range kvData </span><span class="cov3" title="2">{
                        if strVal, ok := value.(string); ok </span><span class="cov3" title="2">{
                                m.kvData[key] = []byte(strVal)
                        }</span>
                }
        }

        // Restore service data would need proper unmarshaling
        // Simplified for now

        <span class="cov1" title="1">return nil</span>
}

func (m *MemoryEngine) BeginTx() (Transaction, error) <span class="cov3" title="2">{
        return &amp;memoryTx{engine: m, operations: make(map[string]interface{})}, nil
}</span>

// memoryTx implements Transaction for memory engine
type memoryTx struct {
        engine     *MemoryEngine
        operations map[string]interface{}
}

func (tx *memoryTx) Set(key string, value []byte) error <span class="cov5" title="3">{
        tx.operations[key] = value
        return nil
}</span>

func (tx *memoryTx) Delete(key string) error <span class="cov0" title="0">{
        tx.operations[key] = nil
        return nil
}</span>

func (tx *memoryTx) Commit() error <span class="cov1" title="1">{
        tx.engine.mu.Lock()
        defer tx.engine.mu.Unlock()

        for key, value := range tx.operations </span><span class="cov3" title="2">{
                if value == nil </span><span class="cov0" title="0">{
                        delete(tx.engine.kvData, key)
                }</span> else<span class="cov3" title="2"> {
                        tx.engine.kvData[key] = value.([]byte)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (tx *memoryTx) Rollback() error <span class="cov1" title="1">{
        tx.operations = make(map[string]interface{})
        return nil
}</pre>
		
		<pre class="file" id="file49" style="display: none">package ratelimit

import (
        "sync"
        "time"
)

// Limiter represents a token bucket rate limiter
type Limiter struct {
        rate       float64   // tokens per second
        burst      int       // maximum burst size
        tokens     float64   // current tokens
        lastUpdate time.Time // last token update time
        mu         sync.Mutex
}

// NewLimiter creates a new rate limiter with the given rate and burst
func NewLimiter(rate float64, burst int) *Limiter <span class="cov8" title="28">{
        return &amp;Limiter{
                rate:       rate,
                burst:      burst,
                tokens:     float64(burst),
                lastUpdate: time.Now(),
        }
}</span>

// Allow checks if a request is allowed based on the rate limit
func (l *Limiter) Allow() bool <span class="cov10" title="46">{
        l.mu.Lock()
        defer l.mu.Unlock()

        now := time.Now()
        elapsed := now.Sub(l.lastUpdate).Seconds()

        // Add tokens based on elapsed time
        l.tokens += elapsed * l.rate
        if l.tokens &gt; float64(l.burst) </span><span class="cov8" title="24">{
                l.tokens = float64(l.burst)
        }</span>

        <span class="cov10" title="46">l.lastUpdate = now

        // Check if we have at least one token
        if l.tokens &gt;= 1.0 </span><span class="cov9" title="38">{
                l.tokens -= 1.0
                return true
        }</span>

        <span class="cov5" title="8">return false</span>
}

// Tokens returns the current number of tokens (for testing/debugging)
func (l *Limiter) Tokens() float64 <span class="cov2" title="2">{
        l.mu.Lock()
        defer l.mu.Unlock()
        return l.tokens
}</span>

// Reset resets the limiter to full capacity
func (l *Limiter) Reset() <span class="cov1" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.tokens = float64(l.burst)
        l.lastUpdate = time.Now()
}</span>

// Store manages rate limiters for multiple clients
type Store struct {
        limiters map[string]*Limiter
        rate     float64
        burst    int
        mu       sync.RWMutex
        cleanup  time.Duration
}

// NewStore creates a new rate limiter store
func NewStore(rate float64, burst int, cleanupInterval time.Duration) *Store <span class="cov6" title="11">{
        store := &amp;Store{
                limiters: make(map[string]*Limiter),
                rate:     rate,
                burst:    burst,
                cleanup:  cleanupInterval,
        }

        // Start cleanup goroutine
        go store.cleanupLoop()

        return store
}</span>

// GetLimiter gets or creates a limiter for the given key
func (s *Store) GetLimiter(key string) *Limiter <span class="cov9" title="37">{
        s.mu.RLock()
        limiter, exists := s.limiters[key]
        s.mu.RUnlock()

        if exists </span><span class="cov6" title="12">{
                return limiter
        }</span>

        // Create new limiter
        <span class="cov8" title="25">s.mu.Lock()
        defer s.mu.Unlock()

        // Double-check in case another goroutine created it
        if limiter, exists := s.limiters[key]; exists </span><span class="cov0" title="0">{
                return limiter
        }</span>

        <span class="cov8" title="25">limiter = NewLimiter(s.rate, s.burst)
        s.limiters[key] = limiter
        return limiter</span>
}

// Allow checks if a request from the given key is allowed
func (s *Store) Allow(key string) bool <span class="cov9" title="31">{
        limiter := s.GetLimiter(key)
        return limiter.Allow()
}</span>

// Reset resets the limiter for the given key
func (s *Store) Reset(key string) <span class="cov3" title="3">{
        s.mu.Lock()
        defer s.mu.Unlock()
        delete(s.limiters, key)
}</span>

// ResetAll resets all limiters
func (s *Store) ResetAll() <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.limiters = make(map[string]*Limiter)
}</span>

// Count returns the number of tracked limiters
func (s *Store) Count() int <span class="cov5" title="6">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.limiters)
}</span>

// cleanupLoop periodically removes unused limiters
func (s *Store) cleanupLoop() <span class="cov1" title="1">{
        if s.cleanup == 0 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(s.cleanup)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                s.cleanupExpired()
        }</span>
}

// cleanup removes limiters that haven't been used recently
func (s *Store) cleanupExpired() <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        now := time.Now()
        threshold := 5 * time.Minute // Remove limiters idle for 5 minutes

        for key, limiter := range s.limiters </span><span class="cov0" title="0">{
                limiter.mu.Lock()
                idle := now.Sub(limiter.lastUpdate)
                limiter.mu.Unlock()

                if idle &gt; threshold </span><span class="cov0" title="0">{
                        delete(s.limiters, key)
                }</span>
        }
}

// GetClients returns information about all active clients
func (s *Store) GetClients(clientType string) []ClientInfo <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        clients := make([]ClientInfo, 0, len(s.limiters))
        for key, limiter := range s.limiters </span><span class="cov0" title="0">{
                limiter.mu.Lock()
                info := ClientInfo{
                        Identifier: key,
                        Type:       clientType,
                        Tokens:     limiter.tokens,
                        MaxTokens:  limiter.burst,
                        Rate:       limiter.rate,
                        LastUpdate: limiter.lastUpdate.Format(time.RFC3339),
                }
                limiter.mu.Unlock()
                clients = append(clients, info)
        }</span>

        <span class="cov0" title="0">return clients</span>
}

// GetClientStatus returns status for a specific client
func (s *Store) GetClientStatus(identifier string, clientType string) *ClientInfo <span class="cov0" title="0">{
        s.mu.RLock()
        limiter, exists := s.limiters[identifier]
        s.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">limiter.mu.Lock()
        defer limiter.mu.Unlock()

        return &amp;ClientInfo{
                Identifier: identifier,
                Type:       clientType,
                Tokens:     limiter.tokens,
                MaxTokens:  limiter.burst,
                Rate:       limiter.rate,
                LastUpdate: limiter.lastUpdate.Format(time.RFC3339),
        }</span>
}

// Config represents rate limiter configuration
type Config struct {
        Enabled         bool
        RequestsPerSec  float64
        Burst           int
        ByIP            bool
        ByAPIKey        bool
        CleanupInterval time.Duration
}

// Service manages rate limiting with different strategies
type Service struct {
        config   Config
        ipStore  *Store
        keyStore *Store
}

// NewService creates a new rate limiting service
func NewService(config Config) *Service <span class="cov4" title="5">{
        var ipStore, keyStore *Store

        if config.ByIP </span><span class="cov3" title="3">{
                ipStore = NewStore(config.RequestsPerSec, config.Burst, config.CleanupInterval)
        }</span>

        <span class="cov4" title="5">if config.ByAPIKey </span><span class="cov3" title="3">{
                keyStore = NewStore(config.RequestsPerSec, config.Burst, config.CleanupInterval)
        }</span>

        <span class="cov4" title="5">return &amp;Service{
                config:   config,
                ipStore:  ipStore,
                keyStore: keyStore,
        }</span>
}

// AllowIP checks if a request from the given IP is allowed
func (s *Service) AllowIP(ip string) bool <span class="cov7" title="19">{
        if !s.config.ByIP || s.ipStore == nil </span><span class="cov6" title="10">{
                return true
        }</span>
        <span class="cov6" title="9">return s.ipStore.Allow(ip)</span>
}

// AllowAPIKey checks if a request with the given API key is allowed
func (s *Service) AllowAPIKey(apiKey string) bool <span class="cov8" title="20">{
        if !s.config.ByAPIKey || s.keyStore == nil </span><span class="cov6" title="10">{
                return true
        }</span>
        <span class="cov6" title="10">return s.keyStore.Allow(apiKey)</span>
}

// ResetIP resets the rate limit for a specific IP
func (s *Service) ResetIP(ip string) <span class="cov1" title="1">{
        if s.ipStore != nil </span><span class="cov1" title="1">{
                s.ipStore.Reset(ip)
        }</span>
}

// ResetAPIKey resets the rate limit for a specific API key
func (s *Service) ResetAPIKey(apiKey string) <span class="cov1" title="1">{
        if s.keyStore != nil </span><span class="cov1" title="1">{
                s.keyStore.Reset(apiKey)
        }</span>
}

// Stats returns rate limiting statistics
func (s *Service) Stats() map[string]interface{} <span class="cov1" title="1">{
        stats := make(map[string]interface{})

        if s.ipStore != nil </span><span class="cov1" title="1">{
                stats["ip_limiters"] = s.ipStore.Count()
        }</span>

        <span class="cov1" title="1">if s.keyStore != nil </span><span class="cov1" title="1">{
                stats["apikey_limiters"] = s.keyStore.Count()
        }</span>

        <span class="cov1" title="1">return stats</span>
}

// GetConfig returns the current rate limit configuration
func (s *Service) GetConfig() Config <span class="cov0" title="0">{
        return s.config
}</span>

// ResetAllIP resets all IP-based rate limiters
func (s *Service) ResetAllIP() <span class="cov0" title="0">{
        if s.ipStore != nil </span><span class="cov0" title="0">{
                s.ipStore.ResetAll()
        }</span>
}

// ResetAllAPIKey resets all API-key-based rate limiters
func (s *Service) ResetAllAPIKey() <span class="cov0" title="0">{
        if s.keyStore != nil </span><span class="cov0" title="0">{
                s.keyStore.ResetAll()
        }</span>
}

// ClientInfo represents information about a rate-limited client
type ClientInfo struct {
        Identifier string  `json:"identifier"`
        Type       string  `json:"type"`        // "ip" or "apikey"
        Tokens     float64 `json:"tokens"`      // Current available tokens
        MaxTokens  int     `json:"max_tokens"`  // Burst size
        Rate       float64 `json:"rate"`        // Tokens per second
        LastUpdate string  `json:"last_update"` // Last activity timestamp
}

// GetActiveClients returns list of currently tracked clients
func (s *Service) GetActiveClients(filterType string) []ClientInfo <span class="cov0" title="0">{
        var clients []ClientInfo

        if filterType == "all" || filterType == "ip" </span><span class="cov0" title="0">{
                if s.ipStore != nil </span><span class="cov0" title="0">{
                        clients = append(clients, s.ipStore.GetClients("ip")...)
                }</span>
        }

        <span class="cov0" title="0">if filterType == "all" || filterType == "apikey" </span><span class="cov0" title="0">{
                if s.keyStore != nil </span><span class="cov0" title="0">{
                        clients = append(clients, s.keyStore.GetClients("apikey")...)
                }</span>
        }

        <span class="cov0" title="0">return clients</span>
}

// GetClientStatus returns status for a specific client
func (s *Service) GetClientStatus(identifier string) *ClientInfo <span class="cov0" title="0">{
        // Try IP store first
        if s.ipStore != nil </span><span class="cov0" title="0">{
                if info := s.ipStore.GetClientStatus(identifier, "ip"); info != nil </span><span class="cov0" title="0">{
                        return info
                }</span>
        }

        // Try API key store
        <span class="cov0" title="0">if s.keyStore != nil </span><span class="cov0" title="0">{
                if info := s.keyStore.GetClientStatus(identifier, "apikey"); info != nil </span><span class="cov0" title="0">{
                        return info
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateConfig dynamically updates rate limit configuration
// Returns true if changes were applied
func (s *Service) UpdateConfig(requestsPerSec *float64, burst *int) bool <span class="cov0" title="0">{
        changed := false

        if requestsPerSec != nil &amp;&amp; *requestsPerSec != s.config.RequestsPerSec </span><span class="cov0" title="0">{
                s.config.RequestsPerSec = *requestsPerSec
                changed = true
        }</span>

        <span class="cov0" title="0">if burst != nil &amp;&amp; *burst != s.config.Burst </span><span class="cov0" title="0">{
                s.config.Burst = *burst
                changed = true
        }</span>

        // Note: Changes only affect new limiters
        // Existing limiters retain their original configuration
        // To apply to all, would need to reset all limiters

        <span class="cov0" title="0">return changed</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package store

import (
        "sync"

        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/persistence"
)

type KVStore struct {
        Data   map[string]string
        Mutex  sync.RWMutex
        engine persistence.Engine
        log    logger.Logger
}

// NewKVStore creates a KV store with optional persistence
func NewKVStore() *KVStore <span class="cov3" title="9">{
        return &amp;KVStore{
                Data: make(map[string]string),
                log:  logger.GetDefault(),
        }
}</span>

// NewKVStoreWithPersistence creates a KV store with persistence engine
func NewKVStoreWithPersistence(engine persistence.Engine, log logger.Logger) (*KVStore, error) <span class="cov0" title="0">{
        store := &amp;KVStore{
                Data:   make(map[string]string),
                engine: engine,
                log:    log,
        }

        // Load existing data from persistence if available
        if engine != nil </span><span class="cov0" title="0">{
                if err := store.loadFromPersistence(); err != nil </span><span class="cov0" title="0">{
                        log.Warn("Failed to load KV data from persistence", logger.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return store, nil</span>
}

func (kv *KVStore) loadFromPersistence() error <span class="cov0" title="0">{
        if kv.engine == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">keys, err := kv.engine.List("")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                value, err := kv.engine.Get(key)
                if err != nil </span><span class="cov0" title="0">{
                        kv.log.Warn("Failed to load key from persistence",
                                logger.String("key", key),
                                logger.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">kv.Data[key] = string(value)</span>
        }

        <span class="cov0" title="0">kv.log.Info("Loaded KV data from persistence",
                logger.Int("keys", len(keys)))
        return nil</span>
}

func (kv *KVStore) Get(key string) (string, bool) <span class="cov10" title="12024">{
        kv.Mutex.RLock()
        defer kv.Mutex.RUnlock()
        value, ok := kv.Data[key]
        return value, ok
}</span>

func (kv *KVStore) Set(key, value string) <span class="cov9" title="11018">{
        kv.Mutex.Lock()
        defer kv.Mutex.Unlock()

        kv.Data[key] = value

        // Persist to storage if engine is available
        if kv.engine != nil </span><span class="cov0" title="0">{
                if err := kv.engine.Set(key, []byte(value)); err != nil </span><span class="cov0" title="0">{
                        kv.log.Error("Failed to persist key",
                                logger.String("key", key),
                                logger.Error(err))
                }</span>
        }
}

func (kv *KVStore) Delete(key string) <span class="cov7" title="1003">{
        kv.Mutex.Lock()
        defer kv.Mutex.Unlock()

        delete(kv.Data, key)

        // Delete from persistence if engine is available
        if kv.engine != nil </span><span class="cov0" title="0">{
                if err := kv.engine.Delete(key); err != nil </span><span class="cov0" title="0">{
                        kv.log.Error("Failed to delete key from persistence",
                                logger.String("key", key),
                                logger.Error(err))
                }</span>
        }
}

func (kv *KVStore) List() []string <span class="cov0" title="0">{
        kv.Mutex.RLock()
        defer kv.Mutex.RUnlock()
        keys := make([]string, 0, len(kv.Data))
        for key := range kv.Data </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// BatchSet sets multiple key-value pairs atomically
func (kv *KVStore) BatchSet(items map[string]string) error <span class="cov0" title="0">{
        kv.Mutex.Lock()
        defer kv.Mutex.Unlock()

        // Update in-memory store
        for key, value := range items </span><span class="cov0" title="0">{
                kv.Data[key] = value
        }</span>

        // Persist if engine is available
        <span class="cov0" title="0">if kv.engine != nil </span><span class="cov0" title="0">{
                byteItems := make(map[string][]byte)
                for key, value := range items </span><span class="cov0" title="0">{
                        byteItems[key] = []byte(value)
                }</span>
                <span class="cov0" title="0">return kv.engine.BatchSet(byteItems)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// BatchDelete deletes multiple keys atomically
func (kv *KVStore) BatchDelete(keys []string) error <span class="cov0" title="0">{
        kv.Mutex.Lock()
        defer kv.Mutex.Unlock()

        // Delete from in-memory store
        for _, key := range keys </span><span class="cov0" title="0">{
                delete(kv.Data, key)
        }</span>

        // Delete from persistence if engine is available
        <span class="cov0" title="0">if kv.engine != nil </span><span class="cov0" title="0">{
                return kv.engine.BatchDelete(keys)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the persistence engine
func (kv *KVStore) Close() error <span class="cov0" title="0">{
        if kv.engine != nil </span><span class="cov0" title="0">{
                return kv.engine.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file51" style="display: none">package store

import (
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/neogan74/konsul/internal/healthcheck"
        "github.com/neogan74/konsul/internal/logger"
        "github.com/neogan74/konsul/internal/persistence"
)

type Service struct {
        Name    string                        `json:"name"`
        Address string                        `json:"address"`
        Port    int                           `json:"port"`
        Checks  []*healthcheck.CheckDefinition `json:"checks,omitempty"`
}

type ServiceEntry struct {
        Service   Service   `json:"service"`
        ExpiresAt time.Time `json:"expires_at"`
}

type ServiceStore struct {
        Data           map[string]ServiceEntry
        Mutex          sync.RWMutex
        TTL            time.Duration
        engine         persistence.Engine
        log            logger.Logger
        healthManager  *healthcheck.Manager
}

func NewServiceStore() *ServiceStore <span class="cov8" title="7">{
        return &amp;ServiceStore{
                Data:          make(map[string]ServiceEntry),
                TTL:           30 * time.Second, // default TTL
                log:           logger.GetDefault(),
                healthManager: healthcheck.NewManager(logger.GetDefault()),
        }
}</span>

func NewServiceStoreWithTTL(ttl time.Duration) *ServiceStore <span class="cov0" title="0">{
        return &amp;ServiceStore{
                Data:          make(map[string]ServiceEntry),
                TTL:           ttl,
                log:           logger.GetDefault(),
                healthManager: healthcheck.NewManager(logger.GetDefault()),
        }
}</span>

// NewServiceStoreWithPersistence creates a service store with persistence engine
func NewServiceStoreWithPersistence(ttl time.Duration, engine persistence.Engine, log logger.Logger) (*ServiceStore, error) <span class="cov0" title="0">{
        store := &amp;ServiceStore{
                Data:          make(map[string]ServiceEntry),
                TTL:           ttl,
                engine:        engine,
                log:           log,
                healthManager: healthcheck.NewManager(log),
        }

        // Load existing data from persistence if available
        if engine != nil </span><span class="cov0" title="0">{
                if err := store.loadFromPersistence(); err != nil </span><span class="cov0" title="0">{
                        log.Warn("Failed to load service data from persistence", logger.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return store, nil</span>
}

func (s *ServiceStore) loadFromPersistence() error <span class="cov0" title="0">{
        if s.engine == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">services, err := s.engine.ListServices()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">loaded := 0
        for _, name := range services </span><span class="cov0" title="0">{
                data, err := s.engine.GetService(name)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Warn("Failed to load service from persistence",
                                logger.String("service", name),
                                logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">var entry ServiceEntry
                if err := json.Unmarshal(data, &amp;entry); err != nil </span><span class="cov0" title="0">{
                        s.log.Warn("Failed to unmarshal service data",
                                logger.String("service", name),
                                logger.Error(err))
                        continue</span>
                }

                // Only load non-expired services
                <span class="cov0" title="0">if entry.ExpiresAt.After(time.Now()) </span><span class="cov0" title="0">{
                        s.Data[name] = entry
                        loaded++
                }</span>
        }

        <span class="cov0" title="0">s.log.Info("Loaded service data from persistence",
                logger.Int("services", loaded))
        return nil</span>
}

func (s *ServiceStore) Register(service Service) <span class="cov10" title="9">{
        s.Mutex.Lock()
        defer s.Mutex.Unlock()

        entry := ServiceEntry{
                Service:   service,
                ExpiresAt: time.Now().Add(s.TTL),
        }
        s.Data[service.Name] = entry

        // Register health checks
        for _, checkDef := range service.Checks </span><span class="cov0" title="0">{
                // Set service ID for the check
                if checkDef.ServiceID == "" </span><span class="cov0" title="0">{
                        checkDef.ServiceID = service.Name
                }</span>

                // Set check name if not provided
                <span class="cov0" title="0">if checkDef.Name == "" </span><span class="cov0" title="0">{
                        checkDef.Name = fmt.Sprintf("%s-health", service.Name)
                }</span>

                <span class="cov0" title="0">_, err := s.healthManager.AddCheck(checkDef)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Failed to add health check",
                                logger.String("service", service.Name),
                                logger.String("check", checkDef.Name),
                                logger.Error(err))
                }</span>
        }

        // Persist to storage if engine is available
        <span class="cov10" title="9">if s.engine != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(entry)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Failed to marshal service entry",
                                logger.String("service", service.Name),
                                logger.Error(err))
                        return
                }</span>

                <span class="cov0" title="0">if err := s.engine.SetService(service.Name, data, s.TTL); err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Failed to persist service",
                                logger.String("service", service.Name),
                                logger.Error(err))
                }</span>
        }
}

func (s *ServiceStore) List() []Service <span class="cov5" title="3">{
        s.Mutex.RLock()
        defer s.Mutex.RUnlock()

        services := make([]Service, 0, len(s.Data))
        now := time.Now()
        for _, entry := range s.Data </span><span class="cov6" title="4">{
                if entry.ExpiresAt.After(now) </span><span class="cov5" title="3">{
                        services = append(services, entry.Service)
                }</span>
        }
        <span class="cov5" title="3">return services</span>
}

func (s *ServiceStore) ListAll() []ServiceEntry <span class="cov0" title="0">{
        s.Mutex.RLock()
        defer s.Mutex.RUnlock()

        entries := make([]ServiceEntry, 0, len(s.Data))
        for _, entry := range s.Data </span><span class="cov0" title="0">{
                entries = append(entries, entry)
        }</span>
        <span class="cov0" title="0">return entries</span>
}

func (s *ServiceStore) Get(name string) (Service, bool) <span class="cov8" title="6">{
        s.Mutex.RLock()
        defer s.Mutex.RUnlock()

        entry, ok := s.Data[name]
        if !ok || entry.ExpiresAt.Before(time.Now()) </span><span class="cov5" title="3">{
                return Service{}, false
        }</span>
        <span class="cov5" title="3">return entry.Service, true</span>
}

func (s *ServiceStore) Heartbeat(name string) bool <span class="cov5" title="3">{
        s.Mutex.Lock()
        defer s.Mutex.Unlock()

        entry, ok := s.Data[name]
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov3" title="2">entry.ExpiresAt = time.Now().Add(s.TTL)
        s.Data[name] = entry

        // Update in persistence if engine is available
        if s.engine != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(entry)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Failed to marshal service entry",
                                logger.String("service", name),
                                logger.Error(err))
                        return true
                }</span>

                <span class="cov0" title="0">if err := s.engine.SetService(name, data, s.TTL); err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Failed to update service heartbeat in persistence",
                                logger.String("service", name),
                                logger.Error(err))
                }</span>
        }

        <span class="cov3" title="2">return true</span>
}

func (s *ServiceStore) Deregister(name string) <span class="cov1" title="1">{
        s.Mutex.Lock()
        defer s.Mutex.Unlock()

        delete(s.Data, name)

        // Delete from persistence if engine is available
        if s.engine != nil </span><span class="cov0" title="0">{
                if err := s.engine.DeleteService(name); err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Failed to delete service from persistence",
                                logger.String("service", name),
                                logger.Error(err))
                }</span>
        }
}

func (s *ServiceStore) CleanupExpired() int <span class="cov1" title="1">{
        s.Mutex.Lock()
        defer s.Mutex.Unlock()

        now := time.Now()
        count := 0
        expiredServices := make([]string, 0)

        for name, entry := range s.Data </span><span class="cov3" title="2">{
                if entry.ExpiresAt.Before(now) </span><span class="cov1" title="1">{
                        delete(s.Data, name)
                        expiredServices = append(expiredServices, name)
                        count++
                }</span>
        }

        // Delete expired services from persistence
        <span class="cov1" title="1">if s.engine != nil &amp;&amp; len(expiredServices) &gt; 0 </span><span class="cov0" title="0">{
                for _, name := range expiredServices </span><span class="cov0" title="0">{
                        if err := s.engine.DeleteService(name); err != nil </span><span class="cov0" title="0">{
                                s.log.Error("Failed to delete expired service from persistence",
                                        logger.String("service", name),
                                        logger.Error(err))
                        }</span>
                }
        }

        <span class="cov1" title="1">return count</span>
}

// GetHealthChecks returns all health checks for a service
func (s *ServiceStore) GetHealthChecks(serviceName string) []*healthcheck.Check <span class="cov0" title="0">{
        checks := s.healthManager.ListChecks()
        var serviceChecks []*healthcheck.Check
        for _, check := range checks </span><span class="cov0" title="0">{
                if check.ServiceID == serviceName </span><span class="cov0" title="0">{
                        serviceChecks = append(serviceChecks, check)
                }</span>
        }
        <span class="cov0" title="0">return serviceChecks</span>
}

// GetAllHealthChecks returns all health checks
func (s *ServiceStore) GetAllHealthChecks() []*healthcheck.Check <span class="cov0" title="0">{
        return s.healthManager.ListChecks()
}</span>

// UpdateTTLCheck updates a TTL-based health check
func (s *ServiceStore) UpdateTTLCheck(checkID string) error <span class="cov0" title="0">{
        return s.healthManager.UpdateTTLCheck(checkID)
}</span>

// Close closes the persistence engine and health manager
func (s *ServiceStore) Close() error <span class="cov0" title="0">{
        s.healthManager.Stop()
        if s.engine != nil </span><span class="cov0" title="0">{
                return s.engine.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file52" style="display: none">package telemetry

import (
        "context"
        "fmt"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
        "go.opentelemetry.io/otel/trace"
)

// TracingConfig contains OpenTelemetry tracing configuration
type TracingConfig struct {
        Enabled        bool
        Endpoint       string // OTLP endpoint (e.g., "tempo:4318")
        ServiceName    string
        ServiceVersion string
        Environment    string
        SamplingRatio  float64 // 0.0 to 1.0, where 1.0 = 100% sampling
        InsecureConn   bool    // Use insecure connection
}

// TracerProvider wraps the OpenTelemetry tracer provider
type TracerProvider struct {
        provider *sdktrace.TracerProvider
        tracer   trace.Tracer
}

// InitTracing initializes OpenTelemetry tracing
func InitTracing(ctx context.Context, config TracingConfig) (*TracerProvider, error) <span class="cov0" title="0">{
        if !config.Enabled </span><span class="cov0" title="0">{
                // Return a no-op tracer provider
                return &amp;TracerProvider{
                        provider: sdktrace.NewTracerProvider(),
                        tracer:   otel.Tracer(config.ServiceName),
                }, nil
        }</span>

        // Create OTLP HTTP exporter
        <span class="cov0" title="0">opts := []otlptracehttp.Option{
                otlptracehttp.WithEndpoint(config.Endpoint),
        }

        if config.InsecureConn </span><span class="cov0" title="0">{
                opts = append(opts, otlptracehttp.WithInsecure())
        }</span>

        <span class="cov0" title="0">exporter, err := otlptracehttp.New(ctx, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create OTLP exporter: %w", err)
        }</span>

        // Create resource with service information
        <span class="cov0" title="0">res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceName(config.ServiceName),
                        semconv.ServiceVersion(config.ServiceVersion),
                        semconv.DeploymentEnvironment(config.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // Create sampler based on sampling ratio
        <span class="cov0" title="0">var sampler sdktrace.Sampler
        if config.SamplingRatio &gt;= 1.0 </span><span class="cov0" title="0">{
                sampler = sdktrace.AlwaysSample()
        }</span> else<span class="cov0" title="0"> if config.SamplingRatio &lt;= 0.0 </span><span class="cov0" title="0">{
                sampler = sdktrace.NeverSample()
        }</span> else<span class="cov0" title="0"> {
                sampler = sdktrace.TraceIDRatioBased(config.SamplingRatio)
        }</span>

        // Create tracer provider
        <span class="cov0" title="0">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter,
                        sdktrace.WithMaxExportBatchSize(512),
                        sdktrace.WithBatchTimeout(5*time.Second),
                        sdktrace.WithMaxQueueSize(2048),
                ),
                sdktrace.WithResource(res),
                sdktrace.WithSampler(sampler),
        )

        // Set global tracer provider
        otel.SetTracerProvider(tp)

        // Set global propagator for context propagation (W3C Trace Context)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        // Create tracer
        tracer := otel.Tracer(config.ServiceName)

        return &amp;TracerProvider{
                provider: tp,
                tracer:   tracer,
        }, nil</span>
}

// Shutdown gracefully shuts down the tracer provider
func (tp *TracerProvider) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if tp.provider == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return tp.provider.Shutdown(ctx)</span>
}

// Tracer returns the configured tracer
func (tp *TracerProvider) Tracer() trace.Tracer <span class="cov0" title="0">{
        return tp.tracer
}</span>

// GetTracer returns the global tracer
func GetTracer(name string) trace.Tracer <span class="cov0" title="0">{
        return otel.Tracer(name)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package template

import (
        "context"
        "fmt"
        "sync"

        "github.com/neogan74/konsul/internal/logger"
)

// Engine is the main template engine orchestrator
type Engine struct {
        config   Config
        renderer *Renderer
        watchers []*Watcher
        log      logger.Logger
        ctx      context.Context
        cancel   context.CancelFunc
        wg       sync.WaitGroup
}

// New creates a new template engine
func New(config Config, kvStore KVStoreReader, serviceStore ServiceStoreReader, log logger.Logger) *Engine <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        renderCtx := &amp;RenderContext{
                KVStore:      kvStore,
                ServiceStore: serviceStore,
                DryRun:       config.DryRun,
        }

        return &amp;Engine{
                config:   config,
                renderer: NewRenderer(renderCtx),
                log:      log,
                ctx:      ctx,
                cancel:   cancel,
        }
}</span>

// RunOnce renders all templates once and exits
func (e *Engine) RunOnce() error <span class="cov0" title="0">{
        e.log.Info("Running template engine in once mode",
                logger.Int("templates", len(e.config.Templates)))

        var errs []error
        for _, tmpl := range e.config.Templates </span><span class="cov0" title="0">{
                result, err := e.renderer.Render(tmpl)
                if err != nil </span><span class="cov0" title="0">{
                        e.log.Error("Failed to render template",
                                logger.String("source", tmpl.Source),
                                logger.Error(err))
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov0" title="0">e.logResult(result)</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to render %d templates", len(errs))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Run starts the template engine in watch mode
func (e *Engine) Run(ctx context.Context) error <span class="cov0" title="0">{
        e.log.Info("Starting template engine in watch mode",
                logger.Int("templates", len(e.config.Templates)))

        // Render templates once at startup
        if err := e.RunOnce(); err != nil </span><span class="cov0" title="0">{
                e.log.Warn("Initial template render had errors", logger.Error(err))
        }</span>

        // Start watchers for each template
        <span class="cov0" title="0">for _, tmpl := range e.config.Templates </span><span class="cov0" title="0">{
                watcher := NewWatcher(e, tmpl)
                e.watchers = append(e.watchers, watcher)

                e.wg.Add(1)
                go func(w *Watcher) </span><span class="cov0" title="0">{
                        defer e.wg.Done()
                        w.Watch(ctx)
                }</span>(watcher)
        }

        // Wait for context cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()

        e.log.Info("Shutting down template engine")
        e.cancel()
        e.wg.Wait()

        return nil</span>
}

// Stop stops the template engine
func (e *Engine) Stop() <span class="cov0" title="0">{
        e.cancel()
        e.wg.Wait()
}</span>

// RenderTemplate renders a single template
func (e *Engine) RenderTemplate(tmpl TemplateConfig) (*RenderResult, error) <span class="cov0" title="0">{
        return e.renderer.Render(tmpl)
}</span>

// logResult logs the result of a template render
func (e *Engine) logResult(result *RenderResult) <span class="cov0" title="0">{
        fields := []logger.Field{
                logger.String("source", result.Template.Source),
                logger.String("destination", result.Template.Destination),
                logger.Duration("duration", result.Duration),
        }

        if result.Error != nil </span><span class="cov0" title="0">{
                e.log.Error("Template render failed", append(fields, logger.Error(result.Error))...)
                return
        }</span>

        <span class="cov0" title="0">if e.config.DryRun </span><span class="cov0" title="0">{
                e.log.Info("Template rendered (dry-run)",
                        append(fields,
                                logger.Int("content_size", len(result.Content)))...)
                return
        }</span>

        <span class="cov0" title="0">if result.Written </span><span class="cov0" title="0">{
                fields = append(fields, logger.String("written", "true"))
        }</span>

        <span class="cov0" title="0">if result.CommandExecuted </span><span class="cov0" title="0">{
                fields = append(fields,
                        logger.String("command_executed", "true"),
                        logger.String("command", result.Template.Command))
        }</span>

        <span class="cov0" title="0">e.log.Info("Template rendered successfully", fields...)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package template

import (
        "bytes"
        "context"
        "fmt"
        "os/exec"
        "time"
)

// Executor handles command execution after template rendering
type Executor struct {
        defaultTimeout time.Duration
}

// NewExecutor creates a new command executor
func NewExecutor() *Executor <span class="cov10" title="4">{
        return &amp;Executor{
                defaultTimeout: 30 * time.Second,
        }
}</span>

// Execute runs a command with optional timeout
func (e *Executor) Execute(command string, timeout time.Duration) (string, error) <span class="cov0" title="0">{
        if command == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Use default timeout if not specified
        <span class="cov0" title="0">if timeout == 0 </span><span class="cov0" title="0">{
                timeout = e.defaultTimeout
        }</span>

        // Create context with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // Parse command (simple shell invocation)
        cmd := exec.CommandContext(ctx, "sh", "-c", command)

        // Capture output
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Execute command
        err := cmd.Run()

        // Combine stdout and stderr
        output := stdout.String()
        if stderr.Len() &gt; 0 </span><span class="cov0" title="0">{
                if output != "" </span><span class="cov0" title="0">{
                        output += "\n"
                }</span>
                <span class="cov0" title="0">output += stderr.String()</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Check if context was canceled (timeout)
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return output, fmt.Errorf("command timed out after %v: %s", timeout, output)
                }</span>
                <span class="cov0" title="0">return output, fmt.Errorf("command failed: %w\nOutput: %s", err, output)</span>
        }

        <span class="cov0" title="0">return output, nil</span>
}

// ExecuteWithRetry runs a command with retry logic
func (e *Executor) ExecuteWithRetry(command string, timeout time.Duration, maxRetries int) (string, error) <span class="cov0" title="0">{
        var lastErr error
        var output string

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // Exponential backoff
                        backoff := time.Duration(attempt*attempt) * time.Second
                        time.Sleep(backoff)
                }</span>

                <span class="cov0" title="0">output, lastErr = e.Execute(command, timeout)
                if lastErr == nil </span><span class="cov0" title="0">{
                        return output, nil
                }</span>
        }

        <span class="cov0" title="0">return output, fmt.Errorf("command failed after %d attempts: %w", maxRetries+1, lastErr)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package template

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"
)

// FuncMap returns the template function map
func (ctx *RenderContext) FuncMap() template.FuncMap <span class="cov8" title="6">{
        return template.FuncMap{
                // KV Store functions
                "kv":     ctx.kv,
                "kvTree": ctx.kvTree,
                "kvList": ctx.kvList,

                // Service discovery functions
                "service":  ctx.service,
                "services": ctx.services,

                // Utility functions
                "env":  env,
                "file": file,

                // String manipulation
                "toLower":   strings.ToLower,
                "toUpper":   strings.ToUpper,
                "trim":      strings.TrimSpace,
                "split":     strings.Split,
                "join":      strings.Join,
                "replace":   strings.ReplaceAll,
                "contains":  strings.Contains,
                "hasPrefix": strings.HasPrefix,
                "hasSuffix": strings.HasSuffix,
        }
}</span>

// kv retrieves a value from the KV store
// Usage: {{ kv "config/database/host" }}
func (ctx *RenderContext) kv(key string) (string, error) <span class="cov10" title="9">{
        if ctx.KVStore == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("KV store not available")
        }</span>

        <span class="cov10" title="9">value, ok := ctx.KVStore.Get(key)
        if !ok </span><span class="cov1" title="1">{
                return "", fmt.Errorf("key not found: %s", key)
        }</span>
        <span class="cov9" title="8">return value, nil</span>
}

// kvTree retrieves all key-value pairs under a prefix
// Usage: {{ range kvTree "config/" }}{{ .Key }}: {{ .Value }}{{ end }}
func (ctx *RenderContext) kvTree(prefix string) ([]KVPair, error) <span class="cov1" title="1">{
        if ctx.KVStore == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("KV store not available")
        }</span>

        <span class="cov1" title="1">keys := ctx.KVStore.List()
        var pairs []KVPair

        for _, key := range keys </span><span class="cov6" title="4">{
                if strings.HasPrefix(key, prefix) </span><span class="cov5" title="3">{
                        if value, ok := ctx.KVStore.Get(key); ok </span><span class="cov5" title="3">{
                                pairs = append(pairs, KVPair{
                                        Key:   key,
                                        Value: value,
                                })
                        }</span>
                }
        }

        <span class="cov1" title="1">return pairs, nil</span>
}

// kvList returns all keys under a prefix
// Usage: {{ range kvList "config/" }}{{ . }}{{ end }}
func (ctx *RenderContext) kvList(prefix string) ([]string, error) <span class="cov0" title="0">{
        if ctx.KVStore == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("KV store not available")
        }</span>

        <span class="cov0" title="0">keys := ctx.KVStore.List()
        var filtered []string

        for _, key := range keys </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, prefix) </span><span class="cov0" title="0">{
                        filtered = append(filtered, key)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

// service retrieves all instances of a service
// Usage: {{ range service "web" }}{{ .Address }}:{{ .Port }}{{ end }}
func (ctx *RenderContext) service(name string) ([]Service, error) <span class="cov3" title="2">{
        if ctx.ServiceStore == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service store not available")
        }</span>

        // Get specific service
        <span class="cov3" title="2">svc, ok := ctx.ServiceStore.Get(name)
        if !ok </span><span class="cov1" title="1">{
                return []Service{}, nil // Return empty slice if service not found
        }</span>

        <span class="cov1" title="1">return []Service{svc}, nil</span>
}

// services retrieves all registered services
// Usage: {{ range services }}{{ .Name }}: {{ .Address }}:{{ .Port }}{{ end }}
func (ctx *RenderContext) services() ([]Service, error) <span class="cov3" title="2">{
        if ctx.ServiceStore == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service store not available")
        }</span>

        <span class="cov3" title="2">return ctx.ServiceStore.List(), nil</span>
}

// env retrieves an environment variable
// Usage: {{ env "HOME" }}
func env(key string) string <span class="cov3" title="2">{
        return os.Getenv(key)
}</span>

// file reads a file and returns its contents
// Usage: {{ file "/etc/hostname" }}
func file(path string) (string, error) <span class="cov3" title="2">{
        // Resolve path
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to resolve path %s: %w", path, err)
        }</span>

        // Read file
        <span class="cov3" title="2">content, err := os.ReadFile(absPath)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to read file %s: %w", absPath, err)
        }</span>

        <span class="cov1" title="1">return string(content), nil</span>
}

// KVPair represents a key-value pair
type KVPair struct {
        Key   string
        Value string
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package template

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"
        "time"
)

// Renderer handles template rendering
type Renderer struct {
        ctx      *RenderContext
        executor *Executor
}

// NewRenderer creates a new template renderer
func NewRenderer(ctx *RenderContext) *Renderer <span class="cov10" title="4">{
        return &amp;Renderer{
                ctx:      ctx,
                executor: NewExecutor(),
        }
}</span>

// Render renders a template with the given configuration
func (r *Renderer) Render(config TemplateConfig) (*RenderResult, error) <span class="cov10" title="4">{
        start := time.Now()
        result := &amp;RenderResult{
                Template: config,
        }

        // Read template source
        templateContent, err := os.ReadFile(config.Source)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to read template source %s: %w", config.Source, err)
                result.Duration = time.Since(start)
                return result, result.Error
        }</span>

        // Parse and execute template
        <span class="cov10" title="4">tmpl, err := template.New(filepath.Base(config.Source)).
                Funcs(r.ctx.FuncMap()).
                Parse(string(templateContent))
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to parse template %s: %w", config.Source, err)
                result.Duration = time.Since(start)
                return result, result.Error
        }</span>

        // Execute template
        <span class="cov10" title="4">var buf strings.Builder
        if err := tmpl.Execute(&amp;buf, nil); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Errorf("failed to execute template %s: %w", config.Source, err)
                result.Duration = time.Since(start)
                return result, result.Error
        }</span>

        <span class="cov10" title="4">result.Content = buf.String()
        result.Duration = time.Since(start)

        // In dry-run mode, don't write or execute
        if r.ctx.DryRun </span><span class="cov5" title="2">{
                return result, nil
        }</span>

        // Write to destination
        <span class="cov5" title="2">if config.Destination != "" </span><span class="cov5" title="2">{
                if err := r.writeFile(config); err != nil </span><span class="cov0" title="0">{
                        result.Error = err
                        return result, err
                }</span>
                <span class="cov5" title="2">result.Written = true</span>
        }

        // Execute command if specified
        <span class="cov5" title="2">if config.Command != "" </span><span class="cov0" title="0">{
                output, err := r.executeCommand(config)
                result.CommandOutput = output
                if err != nil </span><span class="cov0" title="0">{
                        result.Error = err
                        return result, err
                }</span>
                <span class="cov0" title="0">result.CommandExecuted = true</span>
        }

        <span class="cov5" title="2">return result, nil</span>
}

// writeFile writes the rendered content to the destination file
func (r *Renderer) writeFile(config TemplateConfig) error <span class="cov5" title="2">{
        // Ensure destination directory exists
        destDir := filepath.Dir(config.Destination)
        if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory %s: %w", destDir, err)
        }</span>

        // Create backup if requested
        <span class="cov5" title="2">if config.Backup </span><span class="cov1" title="1">{
                if _, err := os.Stat(config.Destination); err == nil </span><span class="cov1" title="1">{
                        backupPath := config.Destination + ".bak"
                        if err := copyFile(config.Destination, backupPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create backup: %w", err)
                        }</span>
                }
        }

        // Write to temporary file first (atomic write)
        <span class="cov5" title="2">tempPath := config.Destination + ".tmp"
        perms := os.FileMode(config.Perms)
        if perms == 0 </span><span class="cov0" title="0">{
                perms = 0644 // Default permissions
        }</span>

        <span class="cov5" title="2">if err := os.WriteFile(tempPath, []byte(r.getRenderedContent(config)), perms); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temporary file: %w", err)
        }</span>

        // Atomic rename
        <span class="cov5" title="2">if err := os.Rename(tempPath, config.Destination); err != nil </span><span class="cov0" title="0">{
                os.Remove(tempPath) // Clean up temp file
                return fmt.Errorf("failed to rename file: %w", err)
        }</span>

        <span class="cov5" title="2">return nil</span>
}

// getRenderedContent retrieves the rendered content for a config
// This is a placeholder - in practice, the content would be passed through
func (r *Renderer) getRenderedContent(config TemplateConfig) string <span class="cov5" title="2">{
        // This will be replaced with proper content passing
        // For now, re-render (not ideal, but works for initial implementation)
        templateContent, err := os.ReadFile(config.Source)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov5" title="2">tmpl, err := template.New(filepath.Base(config.Source)).
                Funcs(r.ctx.FuncMap()).
                Parse(string(templateContent))
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov5" title="2">var buf strings.Builder
        if err := tmpl.Execute(&amp;buf, nil); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov5" title="2">return buf.String()</span>
}

// executeCommand executes the post-render command
func (r *Renderer) executeCommand(config TemplateConfig) (string, error) <span class="cov0" title="0">{
        timeout := config.CommandTimeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 30 * time.Second // Default timeout
        }</span>

        <span class="cov0" title="0">return r.executor.Execute(config.Command, timeout)</span>
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error <span class="cov1" title="1">{
        data, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">info, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return os.WriteFile(dst, data, info.Mode())</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package template

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "time"

        "go.uber.org/zap"
)

// Watcher watches for changes and triggers template re-renders
type Watcher struct {
        engine        *Engine
        template      TemplateConfig
        lastHash      string
        lastRender    time.Time
        pendingRender bool
        minWait       time.Duration
        maxWait       time.Duration
}

// NewWatcher creates a new watcher for a template
func NewWatcher(engine *Engine, template TemplateConfig) *Watcher <span class="cov0" title="0">{
        minWait := 2 * time.Second
        maxWait := 10 * time.Second

        // Use template-specific wait config if available
        if template.Wait != nil </span><span class="cov0" title="0">{
                minWait = template.Wait.Min
                maxWait = template.Wait.Max
        }</span> else<span class="cov0" title="0"> if engine.config.Wait != nil </span><span class="cov0" title="0">{
                // Fall back to global wait config
                minWait = engine.config.Wait.Min
                maxWait = engine.config.Wait.Max
        }</span>

        <span class="cov0" title="0">return &amp;Watcher{
                engine:   engine,
                template: template,
                minWait:  minWait,
                maxWait:  maxWait,
        }</span>
}

// Watch starts watching for changes
func (w *Watcher) Watch(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(w.minWait)
        defer ticker.Stop()

        maxWaitTimer := time.NewTimer(w.maxWait)
        defer maxWaitTimer.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Check if content has changed
                        if w.hasChanged() </span><span class="cov0" title="0">{
                                if !w.pendingRender </span><span class="cov0" title="0">{
                                        // First change detected, start waiting
                                        w.pendingRender = true
                                        maxWaitTimer.Reset(w.maxWait)
                                }</span>
                        }

                case &lt;-maxWaitTimer.C:<span class="cov0" title="0">
                        // Max wait time reached, render if there's a pending change
                        if w.pendingRender </span><span class="cov0" title="0">{
                                w.render()
                                w.pendingRender = false
                        }</span>
                        <span class="cov0" title="0">maxWaitTimer.Reset(w.maxWait)</span>
                }
        }
}

// hasChanged checks if the rendered content would be different
func (w *Watcher) hasChanged() bool <span class="cov0" title="0">{
        // Render to a temporary buffer to compute hash
        result, err := w.engine.RenderTemplate(w.template)
        if err != nil </span><span class="cov0" title="0">{
                // If render fails, consider it unchanged to avoid error loops
                return false
        }</span>

        // Compute hash of rendered content
        <span class="cov0" title="0">hash := computeHash(result.Content)

        // Check if hash has changed
        if hash != w.lastHash </span><span class="cov0" title="0">{
                w.lastHash = hash
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// render triggers a template re-render
func (w *Watcher) render() <span class="cov0" title="0">{
        // Respect minimum wait time between renders
        if time.Since(w.lastRender) &lt; w.minWait </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">result, err := w.engine.RenderTemplate(w.template)
        if err != nil </span><span class="cov0" title="0">{
                w.engine.log.Error("Failed to render template in watch mode",
                        zap.String("template", w.template.Source),
                        zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">w.engine.logResult(result)
        w.lastRender = time.Now()</span>
}

// computeHash computes SHA256 hash of content
func computeHash(content string) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write([]byte(content))
        return hex.EncodeToString(h.Sum(nil))
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package tls

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "os"
        "time"
)

// GenerateSelfSignedCert generates a self-signed TLS certificate for development
func GenerateSelfSignedCert(certFile, keyFile string) error <span class="cov0" title="0">{
        // Generate private key
        privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Create certificate template
        <span class="cov0" title="0">serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
        serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate serial number: %w", err)
        }</span>

        <span class="cov0" title="0">notBefore := time.Now()
        notAfter := notBefore.Add(365 * 24 * time.Hour) // Valid for 1 year

        template := x509.Certificate{
                SerialNumber: serialNumber,
                Subject: pkix.Name{
                        Organization: []string{"Konsul Development"},
                        CommonName:   "localhost",
                },
                NotBefore:             notBefore,
                NotAfter:              notAfter,
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
                DNSNames:              []string{"localhost"},
                IPAddresses:           []net.IP{net.ParseIP("127.0.0.1")},
        }

        // Create self-signed certificate
        derBytes, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        // Write certificate to file
        <span class="cov0" title="0">certOut, err := os.Create(certFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open cert file for writing: %w", err)
        }</span>
        <span class="cov0" title="0">defer certOut.Close()

        if err := pem.Encode(certOut, &amp;pem.Block{Type: "CERTIFICATE", Bytes: derBytes}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write certificate: %w", err)
        }</span>

        // Write private key to file
        <span class="cov0" title="0">keyOut, err := os.OpenFile(keyFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open key file for writing: %w", err)
        }</span>
        <span class="cov0" title="0">defer keyOut.Close()

        privBytes, err := x509.MarshalECPrivateKey(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal private key: %w", err)
        }</span>

        <span class="cov0" title="0">if err := pem.Encode(keyOut, &amp;pem.Block{Type: "EC PRIVATE KEY", Bytes: privBytes}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write private key: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
